{
  "version": 39,
  "versionMessage": "Correzioni ad alias 'ub/us/usastaffa' e 'tool socket', Where e altro. Aggiunto tool ident.",
  "requiresClientMajor": 1,
  "requiresClientMinor": 6,
  "requiresClientRevision": 2,
  "text-color": "green-on-black",
  "wrap-lines": true,
  "utf8Enabled": false,
  "mxpEnabled": true,
  "enable-aliases": true,
  "enable-triggers": true,
  "font-size": "small-font",
  "font": "consolas",
  "colorsEnabled": true,
  "logTime": false,
  "debugScripts": false,
  "defaultAnsiFg": [
    "white",
    "low"
  ],
  "defaultAnsiBg": [
    "black",
    "low"
  ],
  "variables": [
    [
      "autoKillMobs",
      {
        "name": "autoKillMobs",
        "value": "guardia|armiere|statua golem|giardiniere|carceriere|brok capo carceriere|baltar capo cuoco|cuoco|grosso orso|strano giardiniere|falstaff incubo cavallo|pericoloso zombie|scheletro|taglialegna|grosso albero|cacciatore|commerciante assonnato guerriero|guardiaforestale|guardia forestale|orco scuro ladro|sailtril cuoco|guardiaforestale elfica|viandante viaggiatore|orso|elfo scuro addormentato guerriero|golem fulmini|welb monaco|serpente strisciante|fentig oscuro ranger|plint paladino|troll addormentato|angelo cacciatore|elementale fuoco grosso evocazione|panaj mastro druido|gnollo guerriero|salice piangente|efeliv druido elfo|seriev lizardman|fresius cacciatore|nikolaiv sacerdote|Desser titano guardiano|gigante colline|sinister titano guardiano|guardia geldor|spirito narhaeld|spirito midra|spirito alhart|spirito nithus|spirito erohar|spirito anisha|spirito runha|bandito banda|spirito nohel|essere non-morto|spirito bandito|spirito argha|spirito armidas|spirito eramos|spirito nathael|spirito narthas|spirito orothos|guardia villaggio cancello|guardia villaggio strade|abitante donna|abitante villaggio|forestiero viaggiatore|stalliere uomo|Igor sfregiato uomo|contadino uomo|vignaiolo|Baglio mugnaio|contadino donna|grappa cane capovillaggio|Garlos Manodiferro capovillaggio Toewin|vecchio portiere|guardia grigia|statua azzurra|anfitrione|blizzy|pontiere|comandante compagnia|albero marrone scuro|gigante tempeste|bart nano esploratore|monaco impazzito pericoloso|guardia scelta|eruvio magazziniere|kurt cuoco avamposto|Vertor capitanoavamposto|elfo scuro|poirot mercante|guardiaboschi|dron mercante|Eldrik taglialegna|ranger midia|custode magazziniere magazzino|faelin dei discendente|wegendel licantropo|keltor ranger elfo|albero antico morente|gigante nuvole generico|ertat elfo chierico|kevlar fabbro errante|angelo maggiore|angelo minore|Daff goodangel|enorme ciclope|golem roccia rossa|presenza malvagia|wight|drago bronzo|titano gigantesco|golem argento|matteo bardo|Falmer Elfo|Avventuriero|Gigante Colline|Guardia Whiterun|Guardia Riften|Guardia Windhelm|Guardia Winterhold|Guardia Dawnstar|Guardia Solitude|Guardia Markarth|Ragno-Skyrim|Nimhe|Guardia Falkreath|guardia lankar",
        "class": ""
      }
    ],
    [
      "dangerMobs",
      {
        "name": "dangerMobs",
        "value": "karoz barbaro errante",
        "class": ""
      }
    ],
    [
      "Mobs",
      {
        "name": "Mobs",
        "value": "",
        "class": ""
      }
    ],
    [
      "roundtime",
      {
        "name": "roundtime",
        "value": 4000,
        "class": ""
      }
    ],
    [
      "autokill",
      {
        "name": "autokill",
        "value": false,
        "class": ""
      }
    ],
    [
      "Immortal",
      {
        "name": "Immortal",
        "value": false,
        "class": ""
      }
    ],
    [
      "autofuryButton",
      {
        "name": "autofuryButton",
        "class": "",
        "value": "AutoFury"
      }
    ],
    [
      "renting",
      {
        "name": "renting",
        "class": "",
        "value": false
      }
    ],
    [
      "ImmortalTrigger",
      {
        "name": "ImmortalTrigger",
        "class": "",
        "value": false
      }
    ],
    [
      "initDone",
      {
        "name": "initDone",
        "class": "",
        "value": false
      }
    ]
  ],
  "script_events": [
    [
	  "CommandExecuted",
	  [
	    {
		  "type":"CommandExecuted",
		  "condition":"false",
		  "id":"afkReset",
		  "value":"if (args.command.toLowerCase() != \"afk\") {\n  send(\"afk false\")\n}",
		  "class":"",
		  "enabled":true
		}
	  ]
	],
    [
      "VariableChanged",
      [
        {
          "type": "VariableChanged",
          "condition": "Gruppo",
          "id": "printGruppo",
          "value": "send(\"printGruppo\");",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSTank",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSTankCond",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSMob",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSMobCond",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSSpells",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "Gruppo",
          "id": "checkAcl",
          "value": "if (classEnabled(\"autocleric\")) send(\"cura\");",
          "class": "autocleric",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSLag",
          "id": "checkAcl2",
          "value": "if (classEnabled(\"autocleric\")) send(\"cura\");",
          "class": "autocleric",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSGold,TSBank",
          "id": "",
          "value": "send(\"generaGold\");",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSTank,TSTankCond",
          "id": "checkAass",
          "value": "send(\"checkAssist\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "Mobs,TSLag",
          "id": "",
          "value": "delay(\"mobchanged\", 20, ()=>{\n  if (this.Mobs && this.TSLag != \"+\") {\n      send(\"autokillcheck\")\n  }\n});",
          "class": "autokill",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSRoom",
          "id": "",
          "value": "print(\"Sei a: '\" + this.RoomName + \"', Vnum: \"+this.TSRoom);",
          "class": "debug",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSRoom",
          "id": "",
          "value": "this.pauseAutocleric = false;\nthis.preventAntispalm = false;\nif (this.temp_dice)\n  delete this.temp_dice;\ntoggleTrigger(\"dice\", false);\nsetTimeout(()=>send(\"onroomenter \" + this.TSRoom),0)\ndelay(\"aspettomapper\", 1, () => {\n  if (mapper.current) {\n      send(\"onroomenter \" + mapper.current.id)\n  }\n})\nthis.roomTraps=[];\ntoggleTrigger(\"disarm-click\", false);\n",
          "class": "",
          "enabled": true
        }
      ]
    ],
    [
      "ConnectionState",
      [
        {
          "type": "ConnectionState",
          "condition": "telnet",
          "id": "",
          "value": "this.Mobs = \"\";\nsend(\"generaFunzioni\")",
          "class": "",
          "enabled": true
        }
      ]
    ]
  ],
  "triggers": [
    {
      "pattern": "^Tempora Sanguinis e l'Impero Celeste ti danno il benvenuto\\.|^Riconnessione in corso\\.",
      "id": "inizializzazione",
      "value": "if (line.indexOf(\"Riconnessione\")>-1) {\n  send(\"initialize\")\n}\ndelay(\"postinitialize\", 1000, () => this.postInit ? this.postInit() : false)\ntoggleClass(\"login\", false)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^   TUTTI GLI IMMORTALI|^Per avere una breve spiegazione dei comandi per Dei",
      "id": "",
      "value": "this.ImmortalTrigger = true;\nif (this.Immortal != true) {\n  this.Immortal = true\n  toggleClass(\"immortal\",true)\n  if (line.indexOf(\"Per avere\")>-1) {\n  \tthis.initDone = false\n    send(\"initialize\")\n    delay(\"postinitialize\", 1000, () => this.postInit ? this.postInit() : false)\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Connessione a \"Tempora Sanguinis",
      "id": "",
      "value": "send(\"preinit\")",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Sei a sedere! Non puoi farlo!|^Non sarebbe meglio che ti alzassi prima?",
      "id": "",
      "value": "this.seduto = true;\nif (!this.memorizing) {\n\tsend(\"stand\");\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ti alzi\\.|^Sei gia' in piedi\\.",
      "id": "",
      "value": "this.seduto = false;\nthis.alzando = false;\nif (this.memorizing) delete this.memorizing",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(\\([^)']+\\) )?(OT:)?\\[?([^\\]]+)?\\]?(?:Tu)? ?((?:ti )?[cC]hied[ei](?: a [^,]+)?,?|url[ai]|dic[ei] agli Eroi|(?:ti )?sussurr[ia](?: a [^,]+)?,?|dic[ei](?: a [^,]+,)?|dic[ei] al gruppo|(?:ti )?mand[ai] il pensiero(?: a [^,]+)?,|(?:ti )?mand[ai] il messaggio(?: a [^,]+)?,|ti dice) '(.*)'$",
      "id": "capSocial",
      "value": "function isMob(str) {\n  let mob = false;\n  if (str.toLowerCase().indexOf(\"strillone\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"dhethor\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"guardia \")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"matteo\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"elminster\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"eowarion\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"uno \")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"una \")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"biff\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\",\")!=-1) mob = true;\n  if (str.toLowerCase().startsWith(\"il \")) mob = true;\n  if (str.toLowerCase().startsWith(\"l'\")) mob = true;\n  if (str.toLowerCase().startsWith(\"la \")) mob = true;\n  if (str.toLowerCase().startsWith(\"lo \")) mob = true;\n  if (str.toLowerCase().startsWith(\"un \")) mob = true;\n  if (str.toLowerCase().startsWith(\"una \")) mob = true;\n  if (str.toLowerCase().startsWith(\"uno \")) mob = true;\n  return mob;\n}\nlet time=new Date().getHours()+\":\"+new Date().getMinutes();\nlet gtPg = (match[3]||\"Tu\").split(\"]\")[0];\nconst firstWord = gtPg.split(\"[\")[0].split(\" \")[0]\ngtPg = gtPg || \"Tu\";\nif (!isMob((match[3]||\"\")) &&\n  match[5].indexOf(\"(trigger)\")==-1 &&\n   match[0].indexOf(\"al gruppo\")==-1) {\n  //cap(\"Social\");\n  /*for (let i = 0; i < 6; i++) {\n    print(i + \":\" + match[i]);\n  }*/\n  let tipo = \"\";\n  gtPg = color(firstWord, \"lightgray\");\n  let textColor = \"yellow\"\n  if (match[2] && match[2]==\"OT:\") {\n    tipo=\"OT\"\n    textColor = \"yellowgreen\"\n  } else if (!match[3] && match[4].startsWith(\"Chiedi a \")) {\n    tipo=\"Ask\"\n    textColor=\"cyan\"\n    gtPg = \"Tu a \" + match[4].trim().replace(\"Chiedi a \",\"\").split(/[^a-z]/i)[0]\n    gtPg = color(gtPg, \"lightgray\");\n  } else if (match[1] && match[1].trim().startsWith(\"(\") && match[1].trim().endsWith(\")\")) {\n    tipo=\"Guild\"\n    textColor=\"#4eb2f9\"\n  } else if (match[4] && match[4].trim()==\"urli\" && match[3] && match[3].trim()==\"Tu\") {\n    tipo=\"Shout\"\n    textColor=\"red\"\n  } else if (match[4] && match[4].trim()==\"dici agli Eroi\" && match[3] && match[3].trim()==\"Tu\") {\n    tipo=\"Hero\"\n    textColor=\"yellow\"\n  } else if (match[4] && match[4].trim()==\"dici\" && match[3] && (match[3].trim()==\"Tu\" || match[3].trim()==\"Con i segni\")) {\n     if (match[3].trim().endsWith(\"i segni\")) {\n      \ttipo=\"Sign\"\n    \ttextColor=\"yellowgreen\"\n       gtPg = color(\"Tu\", \"lightgray\");\n    } else {\n    \ttipo=\"Gos\"\n    \ttextColor=\"yellow\"\n    }\n  } else if (match[4] && match[4].trim()==\"dice\" && match[3] && !match[3].trim().endsWith(\"ti\")) {\n    if (match[3].trim().endsWith(\"con i segni\")) {\n      \ttipo=\"Sign\"\n    \ttextColor=\"yellowgreen\"\n    } else {\n    \ttipo=\"Gos\"\n    \ttextColor=\"yellow\"\n    }\n  } else if (match[4] && match[4].trim()==\"ti chiede\") {\n    tipo=\"Ask\"\n    textColor=\"cyan\"\n  } else if (match[4] && match[4].trim()==\"dice agli Eroi\") {\n    tipo=\"Hero\"\n    textColor=\"yellow\"\n  } else if (match[4] && match[4].trim()==\"urla\") {\n    tipo=\"Shout\"\n    textColor=\"red\"\n  } else if (match[4] && match[4].trim()==\"ti manda il pensiero,\") {\n    tipo=\"Tele\"\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim()==\"ti manda il messaggio,\") {\n    tipo=\"Mess\"\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"ti dice\")) {\n    tipo=\"Tell\"\n    let tmp = match[3].trim().split(/[^a-z]/i)[0]\n    gtPg=color(tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"dici a \")) {\n    tipo=\"Tell\"\n    let tmp = match[4].trim().replace(\"dici a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"mandi il messaggio a \")) {\n    tipo=\"Mess\"\n    let tmp = match[4].trim().replace(\"mandi il messaggio a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"mandi il pensiero a \")) {\n    tipo=\"Tele\"\n    let tmp = match[4].trim().replace(\"mandi il pensiero a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"sussurri a \")) {\n    tipo=\"Suss\"\n    let tmp = match[4].trim().replace(\"sussurri a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"ti sussurra,\")) {\n    tipo=\"Suss\"\n    let tmp = match[3].trim().split(/[^a-z]/i)[0]\n    gtPg=color(tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  }\n  if (match[5]==\"ping\" && gtPg.indexOf(\"Tu \")==-1) {\n    print(\"Ti sta cercando \" + gtPg + \"!\")\n    switch (tipo) {\n      case 'Tele':\n      case 'Mess':\n      case 'Tell':\n        playAudio(\"./sounds/disconnect.ogg\")\n        break;\n    }\n  }\n  tipo=color(tipo, \"lightgray\")\n  /*19.08.24 bug fix presenza di < e >*/\n  let match5 = match[5];\n  match5 = match5.replace(/</gi,\"&lt;\").replace(/>/gi,\"&gt;\");\n  let detto = color(match5, textColor);\n  if (this.afk) {\n    time=color(\"@\" +time,\"gray\");\n  } else {\n    time=\"\";\n  }\n  print(`[${tipo}]${time}:${gtPg}> ${detto}`,\"Social\")\n}\nif (!isMob((gtPg||\"\")) &&\n  match[5].indexOf(\"(trigger)\")==-1) {\n  if (match[0].indexOf(\"al gruppo\")!=-1) {\n    gtPg = color(firstWord+\":\", \"lightgray\");\n    let detto = color(\" \"+match[5], \"#6060FF\");\n    print(`${gtPg}`,\"Group Tell\")\n  \tprint(`${detto}`,\"Group Tell\")\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^([\\w\\- \\']+) inizia a seguirti",
      "id": "",
      "value": "  let pg = this.cleanupName(match[1]);\n  send(\"group \"+ pg)\n",
      "regex": true,
      "is_script": true,
      "class": "autogroup",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Hai fame.|Hai sete.)",
      "id": "",
      "value": "if (this.feastTimeout) {\n  clearTimeout(this.feastTimeout);\n}\n// il random e' in caso qualcun altro faccia feast nel frattempo\nthis.feastTimeout = setTimeout(()=> {\n  if (!this.feastFatto) {\n    if (this.healtype==\"C\" || this.canPlay) {\n      send(\"cast 'hero'\")\n    } else {\n      send(\"feast\");\n    }\n  }\n  this.feastFatto = false;\n}, (Math.round(Math.random()*10) * 1000));",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Prendi parte ad un magnifico banchetto preparato da",
      "id": "",
      "value": "this.feastFatto = true;",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(La campana benedetta della chiesa di Midia marca un'altra ora.|Un altro granello di sabbia scivola nella clessidra di Martinus.|La clessidra astrale viene capovolta nuovamente.|Ti accorgi che un'altra ora e' passata.|Un'altra pagina dell'eterna storia dell'Impero Celeste e' stata scritta.)",
      "id": "tickTrigger",
      "value": "send(\"tickProc\");",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ti perdi nei tuoi pensieri",
      "id": "",
      "value": "~afk",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^C'erano (\\d+) monete\\.",
      "id": "",
      "value": "if (this.pgInGruppo().length > 1) {\n\tsend(\"split \" + match[1])\n}",
      "regex": true,
      "is_script": true,
      "class": "autosplit",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.*) (si immerge nello stagno\\.|entra in un Portale Luminoso, e scompare!|chiude gli occhi e sparisce all'istante)",
      "id": "stagno_portale",
      "value": "if (this.Gruppo && this.Gruppo.length && this.autofollow) {\n  if (this.isCapogruppo(match[1].split(\" \")[0])) {\n    if (match[2].indexOf(\"stagno\")!=-1) {\n      send(\"es\");\n    } else if (match[2].indexOf(\"sparisce\")!=-1) {\n      if (this.healtype.indexOf(\"C\")>-1 || this.canPlay)\n        send(\"+word\");\n      else\n        send(\"rec rito\");\n    } else {\n      send(\"ep\");\n    }\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "autofollow",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.*) ti ordina '(.*)'",
      "id": "order",
      "value": "if (this.isCapogruppo(match[1]) && this.autoorder) {\n  this.parlaStato = true;\n    send(\"followorder \" + match[2]);\n  this.parlaStato = this.afk;\n}",
      "regex": true,
      "is_script": true,
      "class": "autoorder",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Smetti di seguire",
      "id": "",
      "value": "soloSettings",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Sei entrat(o|a) a far parte del gruppo di",
      "id": "",
      "value": "send(\"groupSettings\");\nthis.listaAutosanc = [];",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^\\[(.+)\\] dice al gruppo '(\\w+)\\:(.+)'",
      "id": "orderGt",
      "value": "if (this.autoorder && this.isCapogruppo(match[1]) &&\n    (match[2] == \"tutti\" || this.TSPersonaggio.toLowerCase().indexOf(match[2].toLowerCase())==0)) {\n  this.parlaStato = true;\n  send(\"followorder \"+match[3].trim());\n  this.parlaStato = this.afk;\n}",
      "regex": true,
      "is_script": true,
      "class": "order",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^L'aura rossa intorno al tuo corpo svanisce",
      "id": "",
      "value": "if (this.selfshield) {\n  setTimeout(()=>{\n  \tsend(\"fs\");\n  }, 2000);\n}",
      "regex": false,
      "is_script": true,
      "class": "selfshield",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(La Luce Divina smette di illuminarti|La Natura smette di proteggerti)",
      "id": "triggerSelfsanc",
      "value": "if (this.selfsanc && (this.healtype==\"C\" || this.TSSettore!=\"Chiuso\")) {\n   setTimeout(()=>{\n    if (this.TSSpells.toLowerCase().indexOf(\"s\") != -1) return;\n    if (this.healtype==\"C\" && (!this.casttype||this.casttype==\"C\") && !this.canBash && !this.canStab && this.pgInGruppo()?.length>1) {\n      send(\"pray gard\");\n    } else {\n  \t\tsend(\"sanc\");\n    }\n  }, 1000);\n}",
      "regex": true,
      "is_script": true,
      "class": "selfsanc",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(?:La Luce Divina smette di illuminare (?<nome>[^.]+)|L'aura di protezione attorno a (?<nome2>[^.]+) si dissolve|La Natura smette di proteggere (?<nome3>[^.]+))",
      "id": "triggerAutosanc",
      "value": "let pg = match.groups.nome || match.groups.nome2 || match.groups.nome3;\nlet druid = match.groups.nome2 || match.groups.nome3;\nif (druid && this.healtype==\"D\" ||\n    !druid && this.healtype==\"C\") {\n  pg = this.titleCase(pg.split(\" \")[0]);\n  if (this?.listaAutosanc == undefined) return;\n  if (this.listaAutosanc.indexOf(pg)!=-1) {\n      if (!this.nosanc) this.nosanc={};\n      if (this.nosanc[pg]) return;\n      this.nosanc[pg]=true\n      send(\"sanc \" + pg);\n      setTimeout(()=>{\n        delete this.nosanc[pg]\n      },10000);\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "autosanc",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Il tuo gruppo e' stato rimosso",
      "id": "",
      "value": "soloSettings",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Il tuo allineamento e'\\: \\w+ \\(([^\\)]+)\\)",
      "id": "",
      "value": "this.diciStatus(\"Align: \" + match[1]);\ntoggleClass(\"gtalign\", false)",
      "regex": true,
      "is_script": true,
      "class": "gtalign",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Spiacente, non c'e' spazio per entrare li'",
      "id": "",
      "value": "sayStatus Non c'e' spazio per entrare li'!",
      "regex": false,
      "is_script": false,
      "class": "indietro",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) (va|vola) verso",
      "id": "",
      "value": "if (this.preventCheckRimastoIndietro) {\n  this.preventCheckRimastoIndietro=false;\n  return;\n}\nif (this.isCapogruppo(match[1])) {\n  this.checkRimastoIndietro = true;\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Segui (.+)\\.",
      "id": "",
      "value": "if (this.isCapogruppo(match[1])) {\n  this.checkRimastoIndietro = false;\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Intravedi (.+) nel corpo di",
      "id": "lootRandomPop",
      "value": "print(color(\"&lt;&lt; -- INTRAVEDO LOOT !!! -- &gt;&gt;\",\"black\",\"yellow\",true, true, true));  \n/*if (this.pgInGruppo().length < 2 || this.isCapogruppo(this.TSPersonaggio)) {\n  let loot = \"\";\n  if (match[1].toLowerCase().indexOf(\"cristallo\")!=-1) loot = \"cristallo\";\n  if (match[1].toLowerCase().indexOf(\"gemma\")!=-1) loot = \"gemma\";\n  if (match[1].toLowerCase().indexOf(\"sangue\")!=-1) loot = \"goccia\";\n  if (match[1].toLowerCase().indexOf(\"ramo\")!=-1) loot = \"ramo\";\n  if (loot.length) {\n    send(`get ${loot} corpo`);\n    send(`get ${loot} ossa`);\n  }\n}*/",
      "regex": true,
      "is_script": true,
      "class": "autoloot|random",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Spiacente, quella locazione e' privata|Spiacente, non c'e' spazio per entrare li)",
      "id": "",
      "value": "if (this.grandezzaGruppo > 1) {\n  delay(\"privata\", 1000, () => send(\"gtTrigger Non c'e' spazio per seguire!\"));\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Ma se non sei alla tastiera, dove vuoi andare?",
      "id": "",
      "value": "~afk",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Con una rapida mossa della sua arma, (.+) colpisce con decisione il tuo braccio|(.+) esegue un rapido calcio, che va a colpire la tua mano con estrema precisione)",
      "id": "",
      "value": "if (this.ultimaArma) {\n  send(\"~wield \" + this.ultimaArma);\n} else {\n  if (this.armaPrimaria) {\n    const armi = [this.armaBlunt,this.armaSlash,this.armaPierce]\n    for (let arma of armi) {\n      if (arma) send(\"wield \" + arma)\n    }\n  } else {\n    print(\"ARMA NON REIMPUGNATA\");\n    print(\"Definire l'arma primaria nel setup\");\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "combat",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^!?H:.*\\>",
      "id": "gagprompt",
      "value": "gag();",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": false,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^La Luce Divina che ti illumina inizia ad attenuarsi.",
      "id": "",
      "value": "if (window.sancTimeout) {\n  clearTimeout(window.sancTimeout);\n  window.sancTimeout = null;\n}\nwindow.sancTimeout = setTimeout(()=>{\n  this.scadenzaSanc = true;\n  window.sancTimeout = null;\n},100000);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^L'aura rossa intorno al tuo corpo inizia a sbiadire.",
      "id": "",
      "value": "if (window.scudoTimeout) {\n  clearTimeout(window.scudoTimeout);\n  window.scudoTimeout = null;\n}\nwindow.scudoTimeout = setTimeout(()=>{\n  this.scadenzaScudo = true;\n  window.scudoTimeout = null;\n},100000);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Chi\\?|Pugnalare chi\\?|Nessuno con quel nome qui)",
      "id": "",
      "value": "if (this.autokill)\n  send(\"look\");",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Ricevi|Ricevi la parte di esperienza di|La tua parte di esperienza e' di) ([^\\d]+)?(in )?(\\d+) punti",
      "id": "",
      "value": "let quantita = Number(match[4])\nthis.stat(\"XP\", quantita/1000000)\nif (isNaN(this._stat_xpsess)) this._stat_xpsess=0;\nthis._stat_xpsess+=quantita/1000000;",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Ricevi (\\d+) [Ss]igilli (?:del |dell' ?|della )?(\\w+)",
      "id": "",
      "value": "const tipo = match[2].toLowerCase()\nconst quantita = Number(match[1])\nswitch (tipo) {\n  case 'divini':\n    this.TSSigDivini = Number(this.TSSigDivini)+quantita;\n    this.stat(\"Divini\", quantita)\n    if (!this._stat_pqsess) this._stat_pqsess=0;\n    this._stat_pqsess+=quantita;\n    break;\n  case 'terra':\n    this.TSSigTerra = Number(this.TSSigTerra)+quantita;\n    this.stat(\"Terra\", quantita)\n    break;\n  case 'aria':\n    this.TSSigAria = Number(this.TSSigAria)+quantita;\n    this.stat(\"Aria\", quantita)\n    break;\n  case 'acqua':\n    this.TSSigAcqua = Number(this.TSSigAcqua)+quantita;\n    this.stat(\"Acqua\", quantita)\n    break;\n  case 'fuoco':\n    this.TSSigFuoco = Number(this.TSSigFuoco)+quantita;\n    this.stat(\"Fuoco\", quantita)\n    break;\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Hai smesso di combattere\\.$",
      "id": "",
      "value": "this.TSTank=\"\";\nthis.TSTankCond=\"\";\nthis.TSMob=\"\";",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Il freddo che (.+) emette ti congela!",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"ic\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) ti colpisce con la sua palla di fuoco! - OUCH",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"if\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Urli di dolore quando vieni colpit[oa] dall'elettricita' di",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"ie\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Non riesci ad evitare l'attacco acido di",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"ia\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Fallisci il tuo tentativo di salvataggio",
      "id": "",
      "value": "this.TSTank=\"\"\nthis.TSMob=\"\"",
      "regex": false,
      "is_script": true,
      "class": "autorescue",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Manchi (.+)\\.",
      "id": "",
      "value": "if (!this.missARound) this.missARound = 0;\nif (!this.cambiArma) {\n  this.cambiArma = 0;\n  this.impugnatoArma=true;\n}\nthis.missARound++;\nif (this.cambiArma<2 && this.impugnatoArma==true) {\n  if (this.missARound>=Number(this.numeroAttacchi)) {\n    this.cambiArma++;\n    this.impugnatoArma = false;\n    rotazioneArmi()\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "autoarmi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^!?H:.*\\>",
      "id": "",
      "value": "this.missARound = 0;",
      "regex": true,
      "is_script": true,
      "class": "autoarmi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.*) e' morto|a! R\\.I\\.P\\.",
      "id": "",
      "value": "this.cambiArma = 0;\nthis.impugnatoArma=true;\nthis.Mobs = \"\";\nthis.returnRoom = null;\nthis.stabTarget = null;\nthis.preventAntispalm = false;\nthis.disableCheckAssist=false;\nthis.preventAutoassist=false;\nif (this.autokill || this.onetimeLook) {\n  this.onetimeLook=false;\n\tdelay(\"aklook\", 1000, () => send(\"look\"));\n}\nif (this.armaPrimaria && this.autoarmi && (this.zoneDaNonRimettereArma||0).toString()!=\"0\") {\n  delay(\"rimettiArma\",1000,()=>{\n    if (this.inCombat()) return;\n    let nozone = (this.zoneDaNonRimettereArma||\"\").split(\",\")\n    for (let z of nozone) {\n      if (Math.floor(Number(this.TSRoom)/100)==Math.floor(Number(z)/100)) {\n        return;\n      }\n    }\n    if (this.ultimaArma != this.armaBlunt && this.armaPrimaria==\"blunt\") {\n      send(\"blunt\")\n    }\n    else if (this.ultimaArma != this.armaSlash && this.armaPrimaria==\"slash\") {\n      send(\"slash\")\n    }\n    else if (this.ultimaArma != this.armaSlash && this.armaPrimaria==\"pierce\") {\n      send(\"pierce\")\n    }\n  });\n}",
      "regex": true,
      "is_script": true,
      "class": "kill",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^.+\\: Impugni (.+)\\.",
      "id": "",
      "value": "this.impugnatoArma = true;",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": ""
    },
    {
      "pattern": "^(Un'ENORME creatura esce fuori dal pozzo e spalanca le sue|Vhal il maledetto e' qui, in piedi)",
      "id": "",
      "value": "this.preventAntispalm=true;\nif (this.antispalm) {\n  if (!this.roomNoAntispalm)this.roomNoAntispalm=[];\n  if (this.roomNoAntispalm.indexOf(this.TSRoom)==-1) {\n    this.roomNoAntispalm.push(this.TSRoom);\n  }\n  send(\"ia\");\n}",
      "regex": true,
      "is_script": true,
      "class": "draghi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(L'enorme Leviathan e' qui, custode di antichi segreti|Un enorme drago bianco anziano si sta riposando qui|Un gigantesco wyrm bianco si sta riposando qui|L'Immensa Armeria)",
      "id": "",
      "value": "this.preventAntispalm=true;\nif (this.antispalm) {\n  if (!this.roomNoAntispalm)this.roomNoAntispalm=[];\n  if (this.roomNoAntispalm.indexOf(this.TSRoom)==-1) {\n    this.roomNoAntispalm.push(this.TSRoom);\n  }\n  send(\"ic\");\n}",
      "regex": true,
      "is_script": true,
      "class": "draghi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) improvvisamente se ne va, correndo piu' veloce che puo'!",
      "id": "",
      "value": "if (this.isCapogruppo(match[1])) {\n\tthis.preventCheckRimastoIndietro=true;\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^\\[( 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22)\\] .+\\((ottimo|molto buono|buono|a pezzi|discreto)\\)$",
      "id": "",
      "value": "if (!this.oggettiRovinati || !this.oggettiRovinati.push) {\n  this.oggettiRovinati = [];\n}\nthis.oggettiRovinati.push(match[1].trim())",
      "regex": true,
      "is_script": true,
      "class": "fixxa",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) evita con agilita' l'attacco.$",
      "id": "",
      "value": "this.missARound--;",
      "regex": true,
      "is_script": true,
      "class": "autoarmi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^In questo tick stai memorizzando (\\d+) incantesimi, di un totale di (\\d+)",
      "id": "",
      "value": "this.memorizeATick = Number(match[2])",
      "regex": true,
      "is_script": true,
      "class": "memorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Puoi memorizzare un incantesimo (\\d+) volte, per un totale di (\\d+) incantesimi",
      "id": "",
      "value": "this.memorizeMaxPerSpell=Number(match[1])\nthis.memorizeMaxLibro=Number(match[2])\ndelay(\"memo\",500,()=>{\n    toggleClass(\"memorize\",false)\n  });",
      "regex": true,
      "is_script": true,
      "class": "memorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Pronunci le parole, '([^']+)'\\.$",
      "id": "",
      "value": "if (!this.spellMemmati) return;\nlet spell=match[1].toLowerCase()\nspell = Object.keys(this.spellMemmati).find(k=>k==spell||spell.startsWith(k))\nif (!spell) {\n   return;\n}\nthis.spellMemmati[spell]--;\n\nif (this.spellMemmati[spell]==0) {\n  print(color(`Hai finito: '${spell}'`, \"black\", \"gray\", true, false, true))\n} else {\n  print(color(`Ti rimangono: ${this.spellMemmati[spell]} ${spell}`, \"yellow\", null, true, false, false))\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^\\[(.+)\\] (.+)  \\(Imparato\\) x(\\d+)",
      "id": "",
      "value": "if (!this.spellMemmati || this.spellMemmati.length) {\n  this.spellMemmati = {};\n}\n\nthis.spellMemmati[match[2]] = Number(match[3])\n",
      "regex": true,
      "is_script": true,
      "class": "memorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) e' stato ucciso da (.+) a (.+)\\.$",
      "id": "",
      "value": "cap(\"Social\");",
      "regex": true,
      "is_script": true,
      "class": "social",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.*) ti cade dalle mani$",
      "id": "",
      "value": "if (this.ultimoHold) {\n  send(\"~hold \" + this.ultimoHold);\n} else {\n  if (this.holdItem) {\n    send(`hold ${this.holdItem}`)\n  } else {\n    print(\"ARMA HOLD NON REIMPUGNATA\");\n    print(\"Definire l'oggetto hold nel setup\");\n  }\n}\n",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^E ti casca anche (.*)!$",
      "id": "",
      "value": "if (this.ultimaArma) {\n  send(\"~wield \" + this.ultimaArma);\n} else {\n  if (this.armaPrimaria) {\n    const armi = [this.armaBlunt,this.armaSlash,this.armaPierce]\n    for (let arma of armi) {\n      if (arma) send(\"wield \" + arma)\n    }\n  } else {\n    print(\"ARMA NON REIMPUGNATA\");\n    print(\"Definire l'arma primaria nel setup\");\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Apri il tuo libro e inizi a leggere e meditare",
      "id": "iniziomemorize",
      "value": "toggleTrigger(\"iniziomemorize\", false)\ndelay(\"iniziomemorize\",4000,()=>{\n  toggleTrigger(\"iniziomemorize\", classEnabled(\"automemorize\"))\n});\nlet now = new Date();\nvar dif = Math.round((now.getTime() - this.lastTickTime.getTime())/1000);\nif (dif < 10 && this.automemo) {\n  print(\"Sembra che automemorize sia andato a brutto fine. Synco il libro.\")\n  send(\"stand;mem\")\n}",
      "regex": false,
      "is_script": true,
      "class": "automemorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Devi usare 'recall' per questo incantesimo",
      "id": "",
      "value": "if (this.ultimoSpellCastato) {\n  if (!this.spellDaRecallare) this.spellDaRecallare=[];\n  this.spellDaRecallare.push(this.ultimoSpellCastato);\n  print(\"Segnato \" + this.ultimoSpellCastato + \" come spell da Sorcerer, lo recallo.\")\n  if (this.ultimoSpellCastato) {\n    send(`cast '${this.ultimoSpellCastato}' ${this.ultimoTargetSpell}`)\n  \tdelete this.ultimoSpellCastato;\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Doni parte della tua energia magica|(.+) esegue un complesso rituale ed invoca l'aiuto del dio)",
      "id": "",
      "value": "send(\"autosanc off\")",
      "regex": true,
      "is_script": true,
      "class": "autosanc",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) esegue un complesso rituale ed invoca l'aiuto del dio Nalith\\. La stanza si riempie di luce",
      "id": "",
      "value": "selfsanc off\nautosanc off",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ti allontani dalla tastiera",
      "id": "",
      "value": "~afk",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ahi ahi, non puoi andare da quella parte|^.+ non si apre\\.|^Hai fallito a forzare la serratura\\.",
      "id": "",
      "value": "mapper.virtualCurrent = null;\nmapper.acknowledgingWalkStep = false;\nif (mapper.manualSteps&&mapper.manualSteps.length) {\n\tmapper.manualSteps = []\n}\nif (mapper.currentWalk) mapper.failWalk(\"Percorso fallito.\")",
      "regex": true,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Fuggi a tutta velocita'\\.|^Con abilita' ti ritiri dalla battaglia\\.",
      "id": "",
      "value": "if (!this.stabTarget) send(\"autoassist false\");",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[Dhethor il questor\\] dice 'Cerca nei paraggi di (.*?)\\.",
      "id": "",
      "value": "if (this.questorPg && this.TSPersonaggio &&\n   this.questorPg.toLowerCase() == this.TSPersonaggio.toLowerCase()) {\n  print(\"Room quest: \" + $1)\n  let res = mapper.searchRoomsByNameAndDesc($1)\n  res = res.filter(r => r.name === $1)\n  this.searchRooms = () => res\n  send(\"ricercaPrecedente\")\n} else {\n  toggleClass(\"questor\", false)\n}",
      "regex": true,
      "is_script": true,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Una (verga) carica di potere levita ad un palmo da terra\\.|^Una (spada) dalla lama formata da fiamme bianche giace qui\\.|^Una (mappa) arrotolata giace qui nella polvere\\.|^Una (bilancia) in equilibrio precario e' posata qui\\.|^Un'(ascia) con incisioni di draghi sulla lama e' piantata in terra\\.|^Un (ramo) d'alloro e' piantato a terra qui\\.|^un (medaglione) sacro ai cinque Dei creatori del mondo giace qui\\.|^Un (elmo) fatto di puro cristallo e' posato qui\\.|^Un (corno) da caccia in argento e' posato qui\\.|^Questa (pietra) e' tutto cio' che rimane della citta' di Lamwothor\\.|^Due (fedi) in oro sono qui posate su un cuscino\\.|^Un'antica moneta d'oro ti attira, ma hai un cattivo presentimento\\.",
      "id": "",
      "value": "let obj = null;\nfor (let i = 1; i<12; i++) {\n\tif (match[i]) {\n    \tobj = match[i]\n      \tbreak\n    }\n}\n\nobj = obj || \"doblone\"\nsend(\"get \"+obj)\nthis.questComplete=true\nsend(\"vai dhethor\")",
      "regex": true,
      "is_script": true,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Dhethor, il questor, e' qui in attesa di volontari|Dichiari a Dhethor il questor di aver completato la tua missione)",
      "id": "",
      "value": "if (this.questComplete) {\n\tthis.questComplete = false\n  \tthis.searchRooms = null;\n\tsend(\"quest complete\")\n}\ntoggleClass(\"questor\", false);",
      "regex": true,
      "is_script": true,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[Dhethor il questor\\] dice 'e chiedono a te, (.+?), di recuperare",
      "id": "",
      "value": "this.questorPg = $1\nif (this.questorPg.toLowerCase() == $1.toLowerCase()) {\n\ttoggleClass(\"questor\",true)\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[Dhethor il questor\\] dice 'Vai a riposarti un po'",
      "id": "",
      "value": "quest time",
      "regex": true,
      "is_script": false,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Senti una leggera vibrazione e il mondo intorno a te cambia",
      "id": "",
      "value": "look",
      "regex": false,
      "is_script": false,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) ha perso il senso della realta'\\.",
      "id": "",
      "value": "if (!this.Immortal) send(\"emote dice: $c5115\" + $1.split(\" \")[0] + \"$c0015 ha perso la connessione!$c0007\")",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Vedi chiaramente (.+)!",
      "id": "",
      "value": "delay(\"aklook\", 500, () => send(\"look\"));",
      "regex": true,
      "is_script": true,
      "class": "autokill",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Premi \\<Invio\\>\\:",
      "id": "",
      "value": "send(\" \", true)",
      "regex": true,
      "is_script": true,
      "class": "login",
      "enabled": true,
      "is_prompt": true,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^    Fai la tua scelta\\:",
      "id": "",
      "value": "send(\"i\")\nsend(\"initialize\")\ntoggleClass(\"login\", false)",
      "regex": true,
      "is_script": true,
      "class": "login",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Sogni di perdere l'abilita' '(.+)'",
      "id": "",
      "value": "send(\"gos Feeblato da Sauron! Addio a: '\" + $1 + \"'.\")",
      "regex": true,
      "is_script": true,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) usa il suo potere ipnotico su di te e tu ti addormenti",
      "id": "",
      "value": "wake\nstand",
      "regex": true,
      "is_script": false,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) evoca (.+) in suo aiuto",
      "id": "",
      "value": "gt $c0015Poppata OMBRA di Melkor$c0007!!",
      "regex": true,
      "is_script": false,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Vedi qualcosa luccicare tra le ceneri di Sauron",
      "id": "",
      "value": "gt Poppato PEZZONE DI MORDOR!!!",
      "regex": true,
      "is_script": false,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Cerchi di ispirarti, ma fallisci!|Ispirazione a ..%)",
      "id": "",
      "value": "const doInspire = () => {\n  delay(\"autoinspire\", 6000, () => {\n      if (this.TSLag==\"+\") {\n      \tdoInspire();\n      } else {\n      \tif (!this.renting) send(\"inspire\")\n      }\n  });\n};\ndoInspire();",
      "regex": true,
      "is_script": true,
      "class": "autoinspire",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Ti senti stanco e continui a suonare|Stai suonando troppo lentamente|Cominci a intonare alcune note di '(.+)'\\.|Continui a intonare la melodia portando l'armonia a ...?%)",
      "id": "",
      "value": "let playDelay = 5000\nif (line.indexOf(\"100%\")>-1) {\n    playDelay = 6000\n}\nif (line.indexOf(\"lentamente\")>-1) {\n    playDelay = 1000\n}\nif (line.indexOf(\"Cominci a intonare\")>-1) {\n  this.ultimaSong = $2\n  if (!this.autosong) return;\n  delay(\"playstart\", 2000, () => {if (this.autosong && !this.renting) send(\"play '\" + this.ultimaSong + \"'\")})\n  playDelay = 7000\n}\nif (!this.autosong) return;\ndelay(\"play\", playDelay, () => {if (this.autosong && !this.renting) send(\"play '\" + this.ultimaSong + \"'\")})",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Non riesci piu' a suonare, devi prendere fiato",
      "id": "",
      "value": "send(\"cast seco \" + this.TSPersonaggio)",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "E' finito il tuo collegamento con il mistico",
      "id": "",
      "value": "send(\"cast myst\")",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "La pratica musicale ti viene meno.",
      "id": "",
      "value": "send(\"cast music\")",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "La tua fiamma spirituale si spegne",
      "id": "",
      "value": "send(\"focus\")",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^.*mette da parte i tuoi oggetti",
      "id": "",
      "value": "this.renting = true",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Non hai abbastanza energia magica|Sei in una zona silenziosa, non puoi emettere suoni|La zona assorbe la tua magia|Questo incantesimo non ha effetto qui)",
      "id": "",
      "value": "if (classEnabled(\"autocleric\")) {\n  this.pauseAutocleric = true\n  print(\"Sei senza mana o in silence... pauso autocleric per 20 secondi.\")\n  delay(\"reset_acl\", 20000, () => {\n    this.pauseAutocleric = false\n    const lag = this.TSLag;\n    this.TSLag = \"\";\n    delay(\"reset_acl2\", 100, ()=>{ this.TSLag = lag; });\n  })\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) (con destrezza si ritira dalla battaglia|e' preso dal panico, e cerca di fuggire)",
      "id": "",
      "value": "if (this.isCapogruppo(match[1])) {\nthis.preventCheckRimastoIndietro=true;\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Prendi un sacco",
      "id": "",
      "value": "send(\"get palanchino sacco;drop sacco\");",
      "regex": true,
      "is_script": true,
      "class": "zone:108",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "C'e' troppa gente! Non riesci ad avvicinarti!",
      "id": "",
      "value": "this.preventAutoassist = true;\nsetTimeout(() => {\n this.preventAutoassist = false;\n  send(\"checkAssist\")\n}, 3000)",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\*\\*\\* (.+)$",
      "id": "",
      "value": "/*19.08.24 bug fix presenza di < e >*/\nlet testo = match[1];\ntesto = testo.replace(/</gi,\"&lt;\").replace(/>/gi,\"&gt;\");\nprint(testo, \"Logs\")\ngag()",
      "regex": true,
      "is_script": true,
      "class": "immortal",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Un globo di energia appare dal nulla, inizia a mutare forma e si anima magicamente",
      "id": "",
      "value": "gt POPPATO NEGOZIANTE",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Smetti di memorizzare e chiudi il tuo libro degli incantesimi",
      "id": "",
      "value": "this.finito_memmare = true;",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[.\\d{1,2}\\] ([^([]+)( \\(|\\[\\d+\\]|)",
      "id": "ident_inv",
      "value": "var util = window.dbIdentUtil;\nlet descshort = match[1].trim();\nlet r = util.withshort(descshort);\nif (util.debug() && r.length>0) {console.log(\"Item trovato: nel trigget ident_inv:\" + match[1])}\nif (r.length>0) {\n  let firstword = $1;\n  const spaceIndex = firstword.indexOf(\" \");\n  if (spaceIndex>-1) {\n    firstword = firstword.substring(0, spaceIndex);\n  }\n\n  let testoident = ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]==\"\")) ?\n      color(\"[?]\",\"maroon\") : color(\"[?]\",\"green\");\n\n  //sub(firstword, link(testoident,()=>{print(out)},\"vedi identify\") + \" \" + firstword);\n  sub(firstword, link(testoident,()=>{\n    let out = util.getStringIdents(r);\n    print(out)\n  },\"vedi identify\") + \" \" + firstword);\n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.*)$",
      "id": "roomContent",
      "value": "//Normalmente NON abilitato.\n//Viene abilitato da altri trigger/alias\n\nif (match[0] == \"\" || \n    match[0] == \"-----------------\" || \n    match[0].search(/^H:\\[\\d+\\/\\d+\\] M:\\[\\d+\\/\\d+\\] V:\\[\\d+\\/\\d+\\]/)>-1) {\n\ttoggleTrigger(\"roomContent\",false);\n  toggleTrigger(\"infoquestContent\",false);\n} else {\n    var util = window.dbIdentUtil;\n    let desclong = match[1];\n  \t//se presente alla fine (condizioni) lo tolgo\n    let m = desclong.match(/([^(]+)(?=\\()/);\n\t  if (m != null) {desclong = m[1]};\n    //se pezzi multipli con [] a inizio e fine le tolgo\n\t  m = desclong.match(/^(?:\\[..\\] |)(.+?)(?:\\[\\d+\\]|)$/);\n    if (m != null) {desclong = m[1]}; \n    desclong = desclong.trim()\n    if (util.debug()) {console.log(\"Item trovato nel trigger roomContent:\" + desclong)}\n    if (desclong == \"\") return; //Mikko 231119 Bugfix per gli oggetti che hanno desclong vuota\n    let r = util.withlong(desclong);\n    if (r.length>0) {\n      //const start = performance.now(); //PROFILAZIONE      \n      let firstword = $1;\n      const spaceIndex = firstword.indexOf(\" \");\n      if (spaceIndex>-1) {\n      \tfirstword = firstword.substring(0, spaceIndex);\n      }\n      let testoident = ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]==\"\") ) ?\n          color(\"[?]\",\"maroon\") : color(\"[?]\",\"green\");\n      \n      sub(firstword, link(testoident,()=>{\n        let out = util.getStringIdents(r);\n        print(out)\n      },\"vedi identify\") + \" \" + firstword);\n      //const duration = performance.now() - start; //PROFILAZIONE\n      //print(\"Profilazione: \" + duration, \"Social\"); \n    }  \n}\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+)$",
      "id": "identContent",
      "value": "//Normalmente NON abilitato.\n//Viene abilitato da altri trigger/alias\n\nwindow.identText +=  match[0] + \"\\n\";\n//print(window.identText + \"\\n\\n\", \"Social\");",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Percepisci le informazioni:",
      "id": "",
      "value": "toggleTrigger(\"identContent\", true);\nwindow.identText = \"\";\nif (typeof window.dbIdentUtil === \"undefined\") {send(\"ident_init\");}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Non percepisci altre informazioni sull'oggetto.",
      "id": "",
      "value": "toggleTrigger(\"identContent\", false);\nlet identText = window.identText;\n\nvar util = window.dbIdentUtil;\nvar ultimoMobUcciso = window.ultimoMobUcciso;\n\n//tolgo l'ultima riga perchè contiene la scritta Non percepisci... che devo escludere dall'ident.\nidentText = identText.substr(0,identText.search(\"Non percepisci altre informazioni sull'oggetto\")-1);\nlet obj = util.parseident(identText);             \n           \n    \n                  \n//cerco se esiste già nel db\nlet found = util.find({\"Oggetto\":obj.Oggetto,\n           \"DescrizioneShort\":obj.DescrizioneShort,\n           \"DescrizioneLong\": obj.DescrizioneLong});\n\nlet hasprovenienza=false;\nutil.autoprovenienzaclear();\nutil.autoprovenienza.area = mapper.current?.zone_id ?? \"\";\n\nif (found != null) { //l'oggetto esiste\n  hasprovenienza = (found[10].length > 0);\n  obj.ID = found[util.db.fieldsPos.ID];\n  util.db.lastID = obj.ID;\n  \n  if (obj.Identify !== found[util.db.fieldsPos.Identify]) {\n    print(\"L'oggetto è già nel database. ID:\" + found[util.db.fieldsPos.ID] + \n          \" con un identify Diverso.  \" + link(\"Click per aggiungerlo\", ()=>{\n      util.add(obj);\n      //util.buildautoprovenienza();\n  \t})); \n  } else {\n    print(\"L'oggetto è già nel database. ID:\" + found[util.db.fieldsPos.ID]);  \n  }\n  \n  \n  if (hasprovenienza) {\n    print(\"L'oggetto nel database ha provenienza: \" + found[util.db.fieldsPos.Provenienza] + \"\\n\");\n  } else {\n    print(\"L'oggetto nel database non ha provenienza indicata.\\n\");  \t\n  }\n  //util.buildautoprovenienza();\n} else {\n  //L'oggetto non è nel DB\n  print(\"L'oggetto non esiste nel database. \" + link(\"Click per aggiungerlo\", ()=>{\n      util.add(obj);\n      //util.buildautoprovenienza();\n  }));\n\n}\n\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Uscite visibili: .*",
      "id": "usciteVisibili",
      "value": "//Normalmente NON abilitato.\n//Viene abilitato da altri trigger/alias\n\ntoggleTrigger(\"roomContent\", true);\ntoggleTrigger(\"usciteVisibili\",false);\n//delay(\"disable_roomContent\",300,()=>{toggleTrigger(\"roomContent\", false);})\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Il tuo sangue si raggela non appena senti il grido di morte di (.+)!$",
      "id": "",
      "value": "window.ultimoMobUcciso = match[1];\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^I tuoi livelli: (\\w\\w):\\d{1,2}(?: (\\w\\w):\\d{1,2})?(?: (\\w\\w):\\d{1,2})?",
      "id": "leggiclassi",
      "value": "let classi=[];\nfor (let i=1; i<=3; i++) {\n\tif (match[i]!=undefined) classi.push(match[i]);\n}\nthis.classi = classi;\ntoggleTrigger(\"leggiclassi\",false)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(OK\\.|Scocchi il proiettile\\.)$",
      "id": "",
      "value": "this.scoccato = true;",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Incocchi ([^.]+)\\.$",
      "id": "",
      "value": "this.scoccato = false",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Guardando all|Stai trasportando)",
      "id": "",
      "value": "toggleTrigger(\"ident_inv\", true)\ndelay(\"ident_inv\", 500, () => {\n\ttoggleTrigger(\"ident_inv\", false)\n})",
      "regex": true,
      "is_script": true,
      "class": "IdentInit",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Il tuo sangue si raggela non appena senti il grido di morte di (.n paladino|.n arciere|.n'inquisitore|.no scudiero|.n mago|.'Arcangelo Remiel|.'Arcangelo Gabriel|.'Arcangelo Uriel|.'Arcangelo Raphael|.'Arcangelo Michael|.'Arcangelo Selaphiel|.'Arcangelo Remiel|.'Arcangelo Samuel)!",
      "id": "",
      "value": "let lab = window.lab;\nif (lab == undefined) {return;}\n\nlet incrementa = (mob,coeff) => {\n\tlab[mob] += 1;\n    if ((lab[mob]>coeff*2) && (lab.lab_multi<3)) {\n      send(\"setlab 3\");\n    } else if ((lab[mob]>coeff) && (lab.lab_multi<2)) {\n      send(\"setlab 2\");\n    }    \n    print(\"Lab kill: \" + match[1] + \" (\" + lab[mob] + \")\");\n}\n\nif (match[1].toLowerCase().search(\"arciere\")>-1) {incrementa(\"arcieri\", 30);}\nelse if (match[1].toLowerCase().search(\"scudiero\")>-1) {incrementa(\"scudieri\", 10);}\nelse if (match[1].toLowerCase().search(\"paladino\")>-1) {incrementa(\"paladini\", 5);}\nelse if (match[1].toLowerCase().search(\"inquisitore\")>-1) {incrementa(\"inquisitori\", 8);}\nelse if (match[1].toLowerCase().search(\"mago\")>-1) {incrementa(\"maghi\", 6);}\nelse if (match[1].toLowerCase().search(\"arcangelo\")>-1) {\n  incrementa(\"arcangeli\", 7);\n  if (this.isCapogruppo())\n    send(\"get chiave arcangelo\")\n}\n\n//console.log(lab);\n\n",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[il guardiano del labirinto\\] dice 'Bene, ecco la chiave. Buona fortuna!'",
      "id": "",
      "value": "send(\"initlab\");",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Davanti a te c'e' una maestosa statua di pietra che raffigura (.+)\\. \\(luminoso\\)|^una (pietra) magica di grande potenza destinata a contenere lo spirito e' stata abbandonata alla sua sorte\\.",
      "id": "labroomcolor",
      "value": "const m = (match[1] || match[2])\ndelay(\"labtrigger\", 0, () => { // client riceve vnum\n  delay(\"labtrigger\", 0, () => { // mapper riceve vnum\n    let rm = mapper.getRoomByVnum(this.TSRoom)\n    if (!rm) return;\n    switch (m) {\n      case \"pietra\":\n      rm.color = \"rgb(0,255,255)\";\n        break;\n      case \"Dryden\":\n      rm.color = \"rgb(0,128,0)\";\n        break;\n      case \"Kiruna\":\n        rm.color = \"rgb(128,64,0)\";\n        break;\n      case \"Martinus\":\n        rm.color = \"rgb(0,0,0)\";\n        break;\n      case \"Dimitri\":\n        rm.color = \"rgb(255,0,0)\";\n        break;\n      case \"Phoenix\":\n        rm.color = \"rgb(255,255,128)\";\n        break;\n      case \"Tyrant\":\n        rm.color = \"rgb(0,0,255)\";\n        break;\n      case \"Nalith\":\n        rm.color = \"rgb(255,255,255)\";\n        break;\n    }\n  })\n})",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Guardi verso ",
      "id": "",
      "value": "toggleTrigger(\"labroomcolor\", false)\ndelay(\"labroomcolor\", 15, () => {\n  toggleTrigger(\"labroomcolor\", true)\n}) ",
      "regex": false,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(\\S+).* tira un dado a 100 facce\\.\\.\\.$",
      "id": "dice",
      "value": "if (!this.temp_dice) {\n  this.temp_dice = {\n  launcher: \"\",\n  results: {}\n  }\n};\nif (match[1] in this.temp_dice.results) {\n  //send(\"gt ATTENZIONE: \" + match[1] + \" ha gia' tirato\");\n  sub(\"dado a 100 facce...\",\"dado a 100 facce...\" + color(\" ( lancio multiplo scartato )\", \"darkgray\"))\n} else {\n  this.temp_dice.launcher = match[1];\n  toggleTrigger(\"dice-risultato\", true);\n}",
      "regex": true,
      "is_script": true,
      "class": "dice",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Il risultato e' (\\d+)\\.$",
      "id": "dice-risultato",
      "value": "this.temp_dice.results[this.temp_dice.launcher] = Number(match[1]);\n\nlet maxresult = 0;\nlet winner = \"\";\nfor (const [name, result] of Object.entries(temp_dice.results)) {\n  //print(name + \"=\" + result);\n  if (result > maxresult) {\n    maxresult = result;\n    winner = name;\n  } else if (result == maxresult) {\n    winner = winner + \",\" + name;\n  }\n}\n\nlet answ = \"\";\nif (winner.search(\",\")>-1) {\n  answ = color(\"Pareggio tra \", \"lightgray\")\n} else {\n  answ = color(\"Sta vincendo \", \"lightgray\")\n}\nansw +=  color(winner,\"lightblue\") + color(\" con \",\"lightgray\") + color(maxresult, \"yellow\");\n\nconst s = \"Il risultato e' \" + match[1] + \".\";\nsub(s, s + \"   < \" + color(answ,\"red\") + \" > \");\nNotification.Show(\"Vince: \" + color(winner,\"lightgreen\") + \": \" + color(maxresult, \"yellow\"), false, true, 3000, true)\ntoggleTrigger(\"dice-risultato\", false);\n",
      "regex": true,
      "is_script": true,
      "class": "dice",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "\\[(\\S+).*\\] dice al gruppo \\'dad(?:a|ate|are|o|iamo)|(Tu) dici al gruppo \\'dad(?:a|ate|are|o|iamo)",
      "id": "",
      "value": "if ( (match[1] && this.isCapogruppo(match[1])) ||\n     (match[2]==\"Tu\" && this.isCapogruppo(this.TSPersonaggio)) ) {\n  this.temp_dice = {\n    launcher: \"\",\n    results: {}\n  }\n  toggleTrigger(\"dice\", true);\n  Notification.Show(color(\"Il capogruppo ha chiesto di tirare il dado!\",\"lightgreen\"), true, false, 3000, true, 1.0, true)\n}",
      "regex": true,
      "is_script": true,
      "class": "dice-init",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Un enorme Monolito che irradia potenza con dei segni",
      "id": "",
      "value": "push monolito",
      "regex": false,
      "is_script": false,
      "class": "zone:204",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Non riesci a reggere %1 che ti cade in terra.",
      "id": "",
      "value": "Notification.Show(\"Ti e' caduto \" + $1, false, false, 5000, false, 1.0, true)\nsend(\"get ed\" + TSPersonaggio)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Fine identify EQ",
      "id": "fineidentifyeq",
      "value": "function downloadString(jsonstr, filename) {\n    let blob = new Blob([jsonstr], { type: \"octet/stream\" });\n    let url = window.URL.createObjectURL(blob);\n\n    let link = document.createElement(\"a\");\n    link.setAttribute(\"href\", url);\n    link.setAttribute(\"download\", filename);\n    link.style.visibility = \"hidden\";\n\n    document.body.appendChild(link);\n    link.click();\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(link);\n}\n\ntoggleTrigger(\"fineidentifyeq\", false)\noutputManager.outputWin.log=false\ndownloadString(localStorage.getItem(\"log\"),\"EQ \" + TSPersonaggio + \".log\")\n",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Non puoi usare il comando 'cast' con '%1'",
      "id": "",
      "value": "this.ultimoSpellCastato=$1",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Devi trovare:$",
      "id": "infoquest_start",
      "value": "toggleTrigger(\"infoquestContent\", true);",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^ - (.+)$",
      "id": "infoquestContent",
      "value": "var util = window.dbIdentUtil;\nlet descshort = match[1].trim();\nlet r = util.withshort(descshort);\nif (util.debug() && r.length>0) {console.log(\"Item trovato: nel trigget ident_inv:\" + match[1])}\nif (r.length>0) {\n  let firstword = $1;\n  const spaceIndex = firstword.indexOf(\" \");\n  if (spaceIndex>-1) {\n    firstword = firstword.substring(0, spaceIndex);\n  }\n\n  const testoident = ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]==\"\")) ?\n      color(\"[?]\",\"maroon\") : color(\"[?]\",\"green\");\n  const lnkident = link(testoident,()=>{\n    let out = util.getStringIdents(r);\n    print(out)\n  },\"vedi identify\")\n  \n  let newText = \" - \" + lnkident + \" \" + match[1].trim();\n  if ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]!=\"\")) {\n    newText += \" - \" + color(r[0][util.db.fieldsPos.Provenienza],\"orange\");\n  } else if (r.length>1) {\n    newText += \" - \" + color(r.length + \" oggetti con la stessa descrizione\",\"red\");\n  }\n  \n  sub(match[0],newText)\n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "class": "disarm",
      "enabled": false,
      "id": "disarm-ko",
      "is_prompt": false,
      "is_script": true,
      "pattern": "\\(uh oh\\)",
      "regex": true,
      "value": "//disarm fallito. Riprovo\ntoggleTrigger(\"disarm-click\", false);\ntoggleTrigger(\"disarm-ko\", false);\ntoggleTrigger(\"disarm-rigavuota\", false);\n\nif (this.autodisarm) send(\"detrap\");\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "disarm",
      "enabled": false,
      "id": "disarm-click",
      "is_prompt": false,
      "is_script": true,
      "pattern": "<Click>",
      "regex": true,
      "value": "//Click. se poi rigavuota allora successo se (uh oh) allora fallito\ntoggleTrigger(\"disarm-rigavuota\", true);\ntoggleTrigger(\"disarm-ko\", true);\ntoggleTrigger(\"disarm-click\", false);\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "disarm",
      "enabled": false,
      "id": "disarm-rigavuota",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^$",
      "regex": true,
      "value": "//disrm riuscito, tolgo il primo elemento dalla lista.\ntoggleTrigger(\"disarm-rigavuota\", false);\ntoggleTrigger(\"disarm-ko\", false);\ntoggleTrigger(\"disarm-click\", false);\n\nthis.roomTraps.shift()\nif (this.autodisarm && (this.roomTraps.length > 0)) {\n  send(\"detrap\");\n}\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "track",
      "enabled": false,
      "id": "track-cerca",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^Vedi orme della tua preda che vanno verso ([^\\.]*)|^### Vedi delle tracce che vanno verso ([^\\.]*)",
      "regex": true,
      "value": "//Normalmente non abilitato. Viene abilitato dall'alias track\n\nif (this.isCapogruppo(this.TSPersonaggio)) return;\n\ndelay(\"delay_track\",200, () => {\n\nlet gruppo = JSON.parse(this.Gruppo);\nlet k = Object.keys(gruppo).slice(2);\nlet capogruppo=k[0]\nif (gruppo[capogruppo]?.inroom!=1) return;\n\nlet dir = (match[1] || match[2]).toUpperCase();\nif (dir == \"IL BASSO\") dir = \"BASSO\";\nif (dir == \"L'ALTO\") dir = \"ALTO\";\nconst mob = getvar(\"trackmob\") || \"\";\nsend(\"gtTrigger Tracce di \" + mob + \" verso: \" + dir);\n\n});",
      "shortcut": "",
      "script": null
    },
    {
      "class": "track",
      "enabled": false,
      "id": "track-fine",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^Non riesci a vedere nessuna traccia di quella creatura.$|^### Hai trovato la tua preda!",
      "regex": true,
      "value": "//Normalmente non abilitato. Viene abilitato dall'alias track\n\nif (this.isCapogruppo(this.TSPersonaggio)) return;\n\ndelay(\"delay_track\",200, () => {\n\nlet gruppo = JSON.parse(this.Gruppo);\nlet k = Object.keys(gruppo).slice(2);\nlet capogruppo=k[0]\nif (gruppo[capogruppo]?.inroom!=1) return;\n  \nconst mob = getvar(\"trackmob\") || \"\";\n  \nif (match[0].includes(\"trovato\")) {\n  send(\"gtTrigger Ecco \" + mob + \" !!!\");  \n} else {\n  send(\"gtTrigger Non vedo tracce di \" + mob);  \n}\n  \n});\n\ntoggleTrigger(\"track-cerca\",false);\ntoggleTrigger(\"track-fine\",false);       \n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "where",
      "enabled": false,
      "id": "wheretrg",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^\\[ 1\\] .+- (.+)$|^.+ e' in (.+)$",
      "regex": true,
      "value": "//Normalmente disabilitato. Viene abilitato da where o da cast commune\nconst roomname = (match[1] || match[2]).trim();\nif (roomname != \"Qui intorno...\") {\n  var zona_attuale = mapper?.current?.zone_id ||-1\n\n  //const res = mapper.searchRooms(match[1].trim())\n  let res = mapper.searchRoomsByNameAndDesc(roomname)\n  res = res.filter(r => r.name === roomname)\n  res = res.filter(r => mapper.getRoomZone(r.id).id === zona_attuale)\n\n  const getLinkVai = (roomid)=>{\n    return link(color(\"[\" + roomid +\"]\",\"yellow\"),()=>{send(\"vai \"+roomid )},\"VAI \"+roomid);\n  }\n  const arrayrooms = res.map( room=>getLinkVai(room.id) )\n  this.searchRooms = () => res\n  //send(\"ricercaPrecedente\")\n  if (res.length>0) {\n    const lvai = getLinkVai(res[0].id)\n    sub(match[0], match[0] + \"   \" + lvai + ((res.length>1)?color(\" [...e altre]\",\"yellow\"):\"\"));\n  }\n}\nif (!match[2]) {\n  //Nel caso di where ho una riga sola quindi disabilito il trigger\n  //Nel caso di commune tengo attivo per intercettare tutte le righe fino alla fine\n  toggleTrigger(\"wheretrg\",false)\n  toggleTrigger(\"whereend\", false)\n}\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "where",
      "enabled": false,
      "id": "whereend",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^$|^Non trovi nulla del genere\\.$",
      "regex": true,
      "value": "//Normalmente disabilitato. Viene abilitato da where o da cast commune\n//$^|^Non trovi nulla del genere\\.$|^!?H:.*\\>\n\ntoggleTrigger(\"wheretrg\",false)\ntoggleTrigger(\"whereend\", false)\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "where",
      "enabled": true,
      "id": "commune",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^Pronunci le parole, 'commune'\\.$",
      "regex": true,
      "value": "toggleTrigger(\"wheretrg\", true);\ntoggleTrigger(\"whereend\", true);",
      "shortcut": "",
      "script": null
    },
    {
      "class": "util",
      "enabled": true,
      "id": "ricevi_monete",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^(.+) ti da' (\\d+) monete d'oro\\.$",
      "regex": true,
      "value": "const log = txt=>{\n  let time=new Date().getHours()+\":\"+new Date().getMinutes();\n  print(color(\"LOG(\"+ time + \") \" + txt,\"yellow\",\"blue\",false,false,false),\"Social\");\n}\n\n\nif (!match[1].toLowerCase().includes(\"di \" + this.TSPersonaggio.toLowerCase())) {\n  log(match[0]);\n}",
      "shortcut": "",
      "script": null
    }
  ],
  "aliases": [
    {
      "pattern": "initialize",
      "id": "",
      "value": "if (this.initDone) {\n\treturn;\n}\nconst wasImmortal = this.Immortal;\nthis.scriptVersion = 11\nthis.initDone = true;\nthis.disableCheckAssist = false;\nthis.preventAutoStop = false;\nthis.preventAutoRescue = false;\nthis.listaDivini = null;\nthis.listaTerra = null;\nthis.listaAcqua = null;\nthis.listaAria = null;\nthis.listaFuoco = null;\nthis.listaXP = null;\nthis._stat_pqsess = 0;\nthis._stat_pqh = 0;\nthis._stat_pq5m = 0;\nthis._stat_pq15m = 0;\nthis._stat_pq1h = 0;\nthis._stat_xpsess = 0;\nthis._stat_xph = 0;\nthis._stat_xp5m = 0;\nthis._stat_xp15m = 0;\nthis._stat_xp1h = 0;\nthis.usiBlunt = false;\nthis.usiSlash = false;\nthis.usiPierce = false;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = false;\nthis.usiImmuEle = false;\nthis.usiImmuFire = false;\nthis.usiExtra = false;\nthis.ultimoScudo = null;\nthis.ultimaArma = null;\nthis.ultimoHold = null;\ntoggleClass(\"thief\", this.canStab);\n\nif (this.mustMemorize) {\n  send(\"mem\");\n}\n\nvar room = this.TSRoom\n  \nthis.postInit = () => {\n  toggleClass(\"autoinspire\", this.autoinspire);\n  this.TSRoom = null;\n  setTimeout(() => {\n    if (mapper && this.TSRoom) \n      mapper.setRoomByVnum(this.TSRoom);\n    \n  \tsetTimeout(() => {\n      const current = (mapper?mapper.current:null);\n      this.TSRoom = ((current && current != room) ? current?.vnum : room) || null;\n    });\n  });\n  \n  if (this.ImmortalTrigger) {\n  \tthis.Immortal = true; \n  } else {\n  \tthis.Immortal = false;\n  }\n  setTimeout(() => {\n    toggleClass(\"immortal\",this.Immortal)\n    if (this.Immortal) {\n      send(\"prompt %gr%N!HP:%h/%H %m!%M!%v!%V!Room:%R Inv:<%iI> Stealth:<%iS> Snoop:<%iN>%l!%x!%X!%b!%g!%G!%a!%c!%C!%A!%S!%tk!%Tk!>\",true)\n    } else {\n      send(\"prompt %gr%p!%N!H:[$c4009%h$c0007/%H] M:[$c4014%m$c0007/%M] V:[$c0002%v$c0007/%V] G:$c0011%g$c0007 [%F%b] T:$c0015%tk$c0007(%c)/M:$c0009%Tk$c0007(%C) %l%x!%X!%b!%g!%G!%a!%c!%C!%A!%S!%tk!%Tk!>\",true)\n    }\n    if (this.enableident && this.publicident) {\n      \ttoggleClass(\"Ident\", true)\n     \tsend(\"identimport online\")\n    } else if (this.enableident) {\n      \ttoggleClass(\"Ident\", true)\n    \tsend(\"ident_init\")\n    }    \n    send(\"initTrapOnline\");     \n  }, 1000);\n  if (wasImmortal != this.Immortal) {\n    (this.Immortal ? print(\"Modalita' per Immortali del Client: ATTIVATA\") : print(\"Modalita' per Immortali del Client: DISABILITATA\"));\n  }\n  if (this.setupdone!=this.scriptVersion) {\n    setTimeout(()=>{\n      print(color(\"Serve fare il SETUP, scrivi setup e premi Invio!\", \"red\", \"white\", true, true, true));\n    }, 2000);\n  }\n  send(\"autoloot \" + ((!this.autoloot || this.Immortal) ? \"off\" : \"on\"))\n  if (this.is_touch_device() && this.usesTouch) {\n    print(color(\"Sembra che tu abbia il touchscreen. Per abilitare i controlli scrivi 'touch'.\", \"white\"))\n  }\n};\n\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "class": "util",
      "enabled": true,
      "id": "autotraps",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^autotraps? ?(.*)?",
      "regex": true,
      "value": "const oldVal = this.autotraps;\n\nthis.autotraps = !this.autotraps;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autotraps = (match[1] == \"true\" || match[1] == \"on\");\n}\n\nif (oldVal != this.autotraps) {\n  let str = (\"AutoTraps: \"+ (this.autotraps ? \"ABILITATO\" : \"DISABILITATO\"));\n  this.diciStatus(str);\n  this.initTraps();\n}\nif (!this.autotraps) send(\"autodisarm off\");\n",
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "stop",
      "id": "",
      "value": "if (this.autoassist) send(\"autoassist false\");\nsend(\"~stop\");",
      "regex": false,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "script": null
    },
    {
      "pattern": "^autoassist ?(.*)?",
      "id": "autoassist",
      "value": "this.autoassist = !this.autoassist;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autoassist = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoassist\", this.autoassist);\nlet str = \"Autoassist: \"+ (this.autoassist ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);\n  this.TSTankCond=\"*\";\n  this.TSTank=\"*\";\n  send(\"checkAssist\");",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autobash ?(.*)?",
      "id": "autobash",
      "value": "this.autobash = !this.autobash;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autobash false)\n\tthis.autobash = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autobash\", this.autobash);\nconst autoWhat = this.canKick && !this.canBash ? \"AutoKick\" : \"AutoBash\";\nlet str = (autoWhat + \": \"+ (this.autobash ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "bash",
      "id": "",
      "value": "tales gigante $1",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "aa",
      "id": "",
      "value": "autoassist",
      "regex": false,
      "is_script": false,
      "class": "fight",
      "enabled": true,
      "script": null
    },
    {
      "pattern": "ab",
      "id": "",
      "value": "autobash",
      "regex": false,
      "is_script": false,
      "class": "fight",
      "enabled": true,
      "script": null
    },
    {
      "pattern": "^autocleric ?(?:(\\d+))?",
      "id": "autocleric",
      "value": "this.noncurare = [];\nlet acl = classEnabled(\"autocleric\");\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tacl = Number(match[1])>0;\n} else if (!match || !match[1]) {\n  acl = !acl;\n}\nthis.autocleric = acl;\nif (!acl) {\n  this.diciStatus(\"AutoCleric OFF\");\n  toggleClass(\"autocleric\", false);\n}\nelse {\n  this.aclMinimum = (match[1] ? Number(match[1]) : 70); // se non passato uso default\n  let str = (\"AutoCleric ON (\" + this.aclMinimum + \")\");\n  this.diciStatus(str);\n  toggleClass(\"autocleric\", true);\n  this.TSLag == \"+\";\n  this.Gruppo = \"{}\";\n  setTimeout(()=>send(\"\"),500);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "heal ?(?:(\\w+))?",
      "id": "heal",
      "value": "if (!this.canPlay && !this.healtype) {\n  send(\"sit;seco\");\n  return;\n}\nlet target = match[1] || this.TSPersonaggio\nif (this.canPlay) {\n\tsend(\"cast 'minor h' \" + target)\n  return;\n}\nif (this.healtype == \"D\") {\n  if (this.TSSettore == \"Chiuso\") {\n    send(\"cast 'minor h' \" + target)\n  } else {\n    send(\"cast 'natures c' \" + target)\n  }\n  this.TSLag = \"+\";\n} else if (this.healtype == \"C\") {\n  send(\"cast 'healing' \" + target)\n  this.TSLag = \"+\";\n}\nelse {\n  send(\"say Curare: \" + target)\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "h",
      "id": "",
      "value": "heal $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "acl",
      "id": "",
      "value": "autocleric $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "debug",
      "id": "",
      "value": "this.debug = !this.debug;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. debug false)\n\tthis.debug = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"debug\", this.debug);\nprint(\"Debug: \"+ (this.debug ? \"ABILITATO\" : \"DISABILITATO\"));",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "variables",
      "id": "",
      "value": "print(\"\\nVariabili acessibili alle script:\\n\");\nlet filtro = input.split(\" \")[1]\nfor (let x in this) {\n  if (filtro && x.toLowerCase().indexOf(filtro.toLowerCase())==-1) continue;\n  if (typeof this[x] == \"function\" || x == \"oldValues\") continue;\n if (this[x] && typeof this[x] == \"object\" && this[x].has) {\n   print(x + \": \" + JSON.stringify([...this[x]]));\n } else if (typeof this[x] == \"object\") {\n   print(x + \": \" + JSON.stringify(this[x]));\n } else {\n \tprint(x + \": \" + this[x]) ;\n }\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "preinit",
      "id": "",
      "value": "this.is_touch_device = () => {\n    if (\"ontouchstart\" in window || window.TouchEvent)\n        return true;\n\n    if (window.DocumentTouch && document instanceof DocumentTouch)\n        return true;\n\n    const prefixes = [\"\", \"-webkit-\", \"-moz-\", \"-o-\", \"-ms-\"];\n    const queries = prefixes.map(prefix => `(${prefix}touch-enabled)`);\n\n    return window.matchMedia(queries.join(\",\")).matches;\n};\n\nthis.autofuryEnabled = () => {\n\tif (this.canPlay) {\n      return this.autosong;\n    } else {\n      return this.autofury;\n    }\n};\n\nthis.autofuryToggle = () => {\n\tif (this.canPlay) {\n      send(\"autosong\");\n    } else {\n      send(\"autofury\");\n    }\n};\n\nif (this.canPlay) {\n  this.autofuryButton = \"AutoSong\"\n  scriptManager.linkEvent(\"autosong\", \"autofuryEnabled()\")\n} else {\n  this.autofuryButton = \"AutoFury\"\n  scriptManager.unlinkEvent(\"autosong\", \"autofuryEnabled()\")\n}\n\nthis.renting = false\nthis.ImmortalTrigger = false;\nthis.roundtime = 4000;\nthis.initDone = false;\ndelete this.postInit;\ntoggleClass(\"autologin\", true);\ntoggleClass(\"login\", true);\ntoggleClass(\"Ident\", false);\nthis.autokill = false;\nthis.stabTarget = null;\n\ndelay(\"preinit\", 1, () => {\n  toggleClass(\"fixxa\", false);\n  toggleClass(\"questor\", false);\n  toggleClass(\"cleric\", (this.healtype||\"\").indexOf(\"C\")!=-1);\n  toggleClass(\"druid\", (this.healtype||\"\").indexOf(\"D\")!=-1);\n  toggleClass(\"mage\", (this.casttype||\"\").indexOf(\"M\")!=-1);\n  toggleClass(\"psionic\", (this.casttype||\"\").indexOf(\"P\")!=-1);\n  toggleClass(\"sorcerer\", !!this.mustMemorize);\n  toggleClass(\"bard\", !!this.canPlay);\n  toggleClass(\"monk\", !!this.canKick && !!!this.canBash);\n  toggleClass(\"autosong\", false);\n  toggleClass(\"autoinspire\", false);\n  toggleClass(\"fight\", !!!this.Immortal);\n  toggleClass(\"util\", true);\n  toggleClass(\"autocleric\", !!this.autocleric>0 && !!!this.Immortal);\n  toggleClass(\"autoassist\", !!this.autoassist && !!!this.Immortal);\n  toggleClass(\"autobash\", !!this.autobash && !!!this.Immortal);\n  toggleClass(\"autorescue\", !!this.autorescue && !!!this.Immortal);\n  toggleClass(\"autoarmi\", !!this.autoarmi && !!!this.Immortal);\n  toggleClass(\"antispalm\", !!this.antispalm && !!!this.Immortal);\n  toggleClass(\"debug\", false);\n  toggleClass(\"autogroup\", !!this.autogroup && !!!this.Immortal);\n  toggleClass(\"autoloot\", !!this.autoloot && !!!this.Immortal);\n  toggleClass(\"autologin\", false);\n  toggleClass(\"login\", true);\n  toggleClass(\"memorize\", false);\n  toggleClass(\"automemorize\", this.automemo && !!!this.Immortal);\n  toggleClass(\"selfsanc\", !!this.selfsanc && !!!this.Immortal);\n  toggleClass(\"selfshield\", !!this.selfshield && !!!this.Immortal);\n  toggleClass(\"gtalign\", false);\n  toggleClass(\"thief\", false);\n  toggleClass(\"autokill\", false);\n  toggleClass(\"afk\", !!this.afk);\n\n});\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "cura",
      "id": "",
      "value": "if (!this.healtype && !this.canPlay) return;\nif (!this.pauseAutocleric && this.TSLag == \"-\") {\n  const grp = JSON.parse(this.Gruppo);\n  let mincura = this.aclMinimum || 70;\n  var minhp = 100;\n  var minpg = \"\";\n  var minMov = 100;\n  var minMovPg = \"\";\n  for (let nome in grp) {\n    if (nome == \"tank\" || nome == \"mob\") continue;\n    // non in room o non curabile\n    if (grp[nome].hide || !grp[nome].inroom || grp[nome].pkill) {\n      continue;\n    }\n    if (grp[nome].hp < mincura && grp[nome].hp<minhp) {\n      minhp = grp[nome].hp;\n      minpg = nome;\n    }\n    if (grp[nome].mv < 25 && grp[nome].mv<minMov) {\n      minMov = grp[nome].mv;\n      minMovPg = nome;\n    }\n  }\n\n  if (minpg) {\n    this.pgdacurare = minpg;\n    print(\"Curo: \" + minpg + \" (\" + minhp + \"% < \" + mincura + \"%)\");\n    send(\"heal \" + minpg);\n    this.pauseAutocleric = true;\n    delay(\"reset_acl\", 2000, ()=>{\n      this.pauseAutocleric = false;\n      const lag = this.TSLag;\n      if (lag == \"-\") {\n      \tthis.TSLag = \"\";\n      \tdelay(\"reset_acl2\", 100, ()=>{ this.TSLag = lag; });\n      }\n    });\n  }\n  if (minMovPg) {\n    print(\"Refresh: \" + minMovPg + \" (\" + minMov + \"% < \" + 25 + \"%)\");\n    send(\"refresh \" + minMovPg);\n    this.pauseAutocleric = true;\n    delay(\"reset_acl\", 2000, ()=>{\n      this.pauseAutocleric = false;\n      const lag = this.TSLag;\n      if (lag == \"-\") {\n      \tthis.TSLag = \"\";\n      \tdelay(\"reset_acl2\", 100, ()=>{ this.TSLag = lag; });\n      }\n    });\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "stand",
      "id": "",
      "value": "if (!this.alzando) {\n\tthis.alzando = true;\n\tsend(\"~stand\");\n}\nthis.alzando=false",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "flee",
      "id": "",
      "value": "if (this.seduto) {\n  send(\"stand\");\n}\nsend(\"~flee\");",
      "regex": false,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "checkAssist",
      "id": "",
      "value": "if (this.disableCheckAssist == true || this.preventAutoassist == true) \n{\n  //this.preventAutoassist = false\n  if (this.autobash) {\n    delay(\"checkAssist\", (this.autocleric ? 2000 : 0 + 2000), () => {send(\"checkAssist\")})\n  }\n  return;\n}\nthis.disableCheckAssist = true;\nsetTimeout(()=>{this.disableCheckAssist=false}, 200);\n\nconst newTank = this.TSTank;\nconst tankState = this.TSTankCond;\n\nlet cleanCastingTimeout = () => {\n  if (this.castTimeout) clearTimeout(this.castTimeout);\n  this.castTimeout = 0;\n}\nif (this.autostop && tankState && tankState != \"*\" && !this.preventAutoStop && !this.isTank()) {\n  this.preventAutoStop = true;\n  this.preventAutoassist = true;\n  if (this.TSPosizione!=\"In piedi\") {\n    send(\"stand\");\n  }\n  send(\"~stop\");\n  delay(\"autostop1\", 4000, () => {\n    this.preventAutoassist = false\n    send(\"checkAssist\")\n  })\n  delay(\"autostop2\", 8250, () => {\n    this.preventAutoStop = false\n    send(\"checkAssist\")\n  })\n}\nlet rescuato = false;\nif (this.autorescue && newTank != \"*\" && newTank!=this.TSPersonaggio && !this.preventAutoRescue) {\n  this.preventAutoRescue = true;\n  if (this.TSPosizione!=\"In piedi\") {\n    send(\"stand\");\n  }\n  send(\"rescue \" + newTank);\n  rescuato = true;\n  setTimeout(() => {this.preventAutoRescue = false}, 4000)\n}\nif (newTank != \"*\" && tankState == \"*\") {\n  if ((classEnabled(\"autoassist\")||(this.autostab))) {\n    this.preventAutoassist = true\n    setTimeout(() => {\n      this.TSTankCond=\"\"\n      this.preventAutoassist = false\n    }, 3000)\n    if (this.autostab) {\n      if (this.usiPierce != this.canPlay) {\n        send(`${this.canPlay?\"slam\":\"backstab\"} ${this.TSMob.split(\" \")[0]}`)\n        if (!this.canPlay && this.afk && !this.autobash) {\n          send(\"~stop\")\n        }\n        return;\n      }\n    }\n    if (!classEnabled(\"autoassist\")) {\n    \treturn;\n    }\n    if (this.autofury) {\n      send(`fury ${this.TSMob.split(\" \")[0]}`)\n    } else {\n      if (!rescuato && this.cleanupName(newTank).toLowerCase() != this.TSPersonaggio.toLowerCase()) send(\"assist \" + this.cleanupName(newTank));\n    }\n    if ((this.canBash||this.canKick) && this.autobash) {\n      setTimeout(()=>{if (this.inCombat()) send(\"bash\")},200);\n    }\n    if (newTank==this.TSPersonaggio) return;\n  }\n  if (this.autocast && this.TSMob!=\"*\" && this.spellOffensivo) {\n    cleanCastingTimeout();\n    const comando = this.mustMemorize ? \"recall\" : \"cast\";\n    let casta = () => {\n      if (this.TSMob==\"*\" || !this.autocast) {\n        cleanCastingTimeout();\n        return;\n      }\n      if (this.TSLag==\"-\") {\n      \tsend(`${comando} '${this.spellOffensivo}' ${this.TSMob.split(\" \")[0]}`)\n      }\n      let lag = Math.floor(this.roundtime*1.5);\n      if (this.autocleric) lag += 3000;\n      this.castTimeout = setTimeout(() => {casta()}, lag)\n    }\n    this.castTimeout = setTimeout(() => {casta()}, 0)\n  }\n} else if (newTank != \"*\" && tankState != \"*\") {\n  if (this.autobash && this.TSLag != \"+\" && this.inCombat()) {\n    delay(\"checkAssist\", (this.autocleric ? 2000 : 0 + 2000),() => {send(\"checkAssist\")})\n    if (this.TSPosizione != \"In piedi\" && (!this.canBash && this.canKick)) {\n      send(\"springleap\");\n      return;\n    }\n    else if (this.TSPosizione != \"In piedi\" && (this.canBash)) {\n      send(\"stand\");\n    }\n    send(\"bash\");    \n  } else if (this.autobash && this.inCombat()) {\n    delay(\"checkAssist\", (this.autocleric ? 2000 : 0 + 2000),() => {send(\"checkAssist\")})\n  }\n} else if (newTank == \"*\") {\n  cleanCastingTimeout();\n}\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "ass",
      "id": "",
      "value": "send(\"assist \" + (input.split(\" \")[1] || this.TSTank.split(\" \")[0]))",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autogroup ?(.*)?",
      "id": "autogroup",
      "value": "this.autogroup = !this.autogroup;\n\nif (match && match[1] != undefined) {\n\tthis.autogroup = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autogroup\", this.autogroup);\nlet str = (\"Autogroup: \"+ (this.autogroup ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
	  "pattern": "setup",
	  "id": "",
	  "value": "const setClasses = async (v) => {\n  toggleClass(\"mage\",v && this.casttype.indexOf(\"M\")!=-1)\n  toggleClass(\"cleric\",v && this.casttype.indexOf(\"C\")!=-1)\n  toggleClass(\"druid\",v && this.casttype.indexOf(\"D\")!=-1)\n  toggleClass(\"psionic\",v && this.casttype.indexOf(\"P\")!=-1)\n  toggleClass(\"sorcerer\",v && this.mustMemorize)\n  toggleClass(\"bard\",v && this.canPlay)\n  toggleClass(\"monk\",v && this.canKick && !this.canBash)\n  this.mustMind = this.casttype.indexOf(\"P\")!=-1;\n  this.healtype = this.casttype.indexOf(\"C\")!=-1 ? \"C\" : this.casttype.indexOf(\"D\")!=-1 ? \"D\" : \"\";\n};\n\nconst resetSettings = () => {\n  setClasses(false);\n  delete this.staffe;\n  delete this.staffa;\n  delete this.listastaffe;\n  delete this.strumentoPercussione;\n  delete this.strumentoCorde;\n  delete this.strumentoFiato;\n  delete this.strumentoSlam;\n  delete this.autocleric;\n  delete this.mustMind\n  delete this.canPlay\n  delete this.healtype\n  delete this.mustMind\n  delete this.mustMemorize;\n  delete this.spellOffensivo;\n  delete this.armaBlunt\n  delete this.armaSlash\n  delete this.armaPierce\n  delete this.numeroAttacchi\n  delete this.ordineArmi\n  delete this.armaPrimaria\n  delete this.armaExtra\n  delete this.zoneDaNonRimettereArma\n  delete this.scudoCold\n  delete this.scudoAcid\n  delete this.scudoEle\n  delete this.scudoFire\n  delete this.usaLuce\n  delete this.borsa\n  delete this.borsaArmi\n  delete this.throwObject\n  delete this.holdItem\n  delete this.oggettoTrueSight\n  delete this.armaDigCut\n  delete this.pgTitle\n  delete this.colori\n  delete this.setupdone;\n  delete this.ImmortalTrigger\n  delete this.Immortal\n  delete this.canBash\n  delete this.canKick\n  delete this.enableident\n  delete this.publicident\n  delete this.arco\n  delete this.freccia\n}; \n\nif ($1==\"reset\") {\n  print(\"Cancello la configurazione pg / setup.\")\n  resetSettings()\n  this.initDone = false;\n  send(\"initialize\");\n  delay(\"postinitialize\", 100, () => this.postInit ? this.postInit() : false)\n  return\n}\n\nconst askColori = async () => {\n  let colori = (this.colori instanceof Array) ? this.colori.join(\",\") : (this.colori || \"$c0009\");\n\n  const results = (await Messagebox.ShowMultiInput(\"Personale\",\n                   [\"Il tuo title\",\"Colori con i quali parli separati da virgola\", \"Vuoi giocare in modalita' compatta (no prompt)\"],\n                   [this.pgTitle ? this.pgTitle : \".\",\n                    colori || \"$c0009\",\n                   triggerEnabled(\"gagprompt\")])).results;\n\n  this.pgTitle = results[0]\n  this.colori = results[1].split(\",\")\n  const wantsCompact = toggleTrigger(\"gagprompt\",!!results[2])||triggerEnabled(\"gagprompt\")\n  \n  send(`compact ${ wantsCompact ? \"enable\" : \"disable\"}`)\n  return results\n};\n\nconst askIdentify = async () => {\n  const results = (await Messagebox.ShowMultiInput(\"Funzionalita' aggiuntive\",\n                   [\"Vuoi usare le funzonalita' del DB identify?\",\"Vuoi usare il db oggetti pubblico?\", \"Vuoi usare la funzionalita' per le staffe?\"],\n                   [!!this.enableident,!!this.publicident,!!classEnabled(\"util|staffe\")])).results;\n\n  return results\n};\n\nconst answer = (await Messagebox.Question(\n  \"Presuppongo che sei un personaggio Mortale?\\nRispondi No solamente se stai creando il profilo per un Immortale o Dio.\\n\\nPremi 'Si' per proseguire con il setup.\"\n)).result;\n\nconst correct = (condition) => {\n  return (true === (this.Immortal = this.ImmortalTrigger = !!condition));\n};\n\nif ((this.Immortal = correct(answer != \"Si\"))) {\n  const col = this.colori\n  const title = this.pgTitle\n  resetSettings()\n  this.colori = col\n  this.pgTitle = title\n  this.casttype = \"CDMP\"\n  this.healtype=\"C\"\n  this.spellOffensivo = 'disint';\n  this.zoneDaNonRimettereArma = 0\n  this.usaLuce = false\n  this.borsa = (await Messagebox.ShowInput(\"La tua borsa\",\"Che keyword usi per la tua borsa?\", this.borsa || \"borsa-ed\"+this.TSPersonaggio)).result\n  await setClasses(true);\n  this.mustMind = this.mustMemorize = false;\n  await askColori();\n  this.setupdone = this.scriptVersion;\n  this.Immortal = true;\n  this.autocleric = false;\n  this.ImmortalTrigger = true;\n  this.initDone = false;\n  send(\"initialize\");\n  delay(\"postinitialize\", 100, () => this.postInit ? this.postInit() : false)\n  \n  return;\n}\n\nthis.ImmortalTrigger = false;\nthis.Immortal = false;\n\nconst resClassi = (await Messagebox.ShowMultiInput(\"Configurazione Classi\",\n                 [\"Puoi Bashare?\",\"Puoi Stabbare?\",\"Puoi Suonare?\",\"Puoi Calciare?\", \"[C]l, [D]r, [M]u, [P]s (o comb)\",\"Spell offensivo\",\"Devi memmare?\"],\n                 [!!this.canBash,\n                  !!this.canStab,\n                  !!this.canPlay,\n                  !!this.canKick,\n                 this.casttype,\n                 this.spellOffensivo||\"meteor swarm\",\n                 !!this.mustMemorize])).results\n             \nthis.canBash = resClassi[0];\nthis.canStab = resClassi[1]\nthis.canPlay = resClassi[2]\nthis.canKick = resClassi[3]\nthis.casttype = resClassi[4].toUpperCase()\nthis.spellOffensivo = resClassi[5]\nthis.mustMemorize = resClassi[6]\n\nawait setClasses(true);\n\nconst resArmi = (await Messagebox.ShowMultiInput(\"Configurazione armi\",\n                 [\"Key dell'arma blunt\",\"Key dell'arma slash\", \"Key dell'arma pierce\",\"Key arma extra\",\"Key dell'arco\",\"Num. attacchi primario\",\"Ordine cambio: 1=BPS, 2=BSP\",\"Arma Primaria (blunt/pierce/slash/pugni)\", \"Key freccia preferita\",\"ID zone dove non rimetti arma prim. (0=tutte)\"],\n                 [this.armaBlunt != undefined ? this.armaBlunt : \"blunt-ed\"+this.TSPersonaggio,\n                  this.armaSlash != undefined  ? this.armaSlash : \"slash-ed\"+this.TSPersonaggio,\n                 this.armaPierce != undefined  ? this.armaPierce : \"pierce-ed\"+this.TSPersonaggio,\n                 this.armaExtra != undefined  ? this.armaExtra : \"scintilla-ed\"+this.TSPersonaggio,\n                 this.arco != undefined  ? this.arco : \"arco-ed\"+this.TSPersonaggio,\n                 this.numeroAttacchi!=undefined ? this.numeroAttacchi : \"4\",\n                 this.ordineArmi!=undefined ? this.ordineArmi : \"2\",\n                 this.armaPrimaria!=undefined ? this.armaPrimaria : \"blunt\",\n                 this.freccia != undefined  ? this.freccia : \"\",\n                 this.zoneDaNonRimettereArma!=undefined ? this.zoneDaNonRimettereArma : \"\"])).results\n                 \nthis.armaBlunt = resArmi[0];\nthis.armaSlash = resArmi[1];\nthis.armaPierce = resArmi[2];\nthis.numeroAttacchi = resArmi[5];\nthis.ordineArmi = resArmi[6];\nthis.armaPrimaria = resArmi[7];\nthis.armaExtra = resArmi[3];\nthis.arco = resArmi[4];\nthis.freccia = resArmi[8];\nthis.zoneDaNonRimettereArma = resArmi[9];\n\nif (this.canPlay) {\n  const domandaStrumenti = (await Messagebox.ShowMultiInput(\"Configurazione Strumenti\",\n                   [\"Strumento a percussione\",\"Strumento a corde\", \"Strumento a fiato\",\"Slammi con sturmento percussione?\"],\n                   [this.strumentoPercussione!=undefined ? this.strumentoPercussione : \"tamburo-ed\"+this.TSPersonaggio,\n                   this.strumentoCorde!=undefined ? this.strumentoCorde : \"arpa-ed\"+this.TSPersonaggio,\n                   this.strumentoFiato!=undefined ? this.strumentoFiato : \"flauto-ed\"+this.TSPersonaggio,\n                   this.strumentoSlam!=undefined ? this.strumentoSlam == this.strumentoPercussione : true])).results\n\n  this.strumentoPercussione = domandaStrumenti[0]\n  this.strumentoCorde =  domandaStrumenti[1]\n  this.strumentoFiato =  domandaStrumenti[2]\n  this.strumentoSlam =  domandaStrumenti[3] ? this.strumentoPercussione : this.strumentoCorde\n}\n\nconst resScudi = (await Messagebox.ShowMultiInput(\"Configurazione Scudi\",\n                 [\"Keyword Scudo Ghiaccio\",\"Keyword Scudo Acido\", \"Keyword Scudo Elettrico\",\"Keyword Scudo Fuoco\"],\n                 [this.scudoCold!=undefined ? this.scudoCold : \"scudo-cold-ed\"+this.TSPersonaggio,\n                  this.scudoAcid!=undefined ? this.scudoAcid : \"scudo-acid-ed\"+this.TSPersonaggio,\n                 this.scudoEle!=undefined ? this.scudoEle : \"scudo-ele-ed\"+this.TSPersonaggio,\n                 this.scudoFire!=undefined ? this.scudoFire : \"scudo-fire-ed\"+this.TSPersonaggio])).results\n\nthis.scudoCold = resScudi[0]\nthis.scudoAcid =  resScudi[1]\nthis.scudoEle =  resScudi[2]\nthis.scudoFire =  resScudi[3]\n\nconst resUtil = (await Messagebox.ShowMultiInput(\"Utilitarie\",\n                 [\"Usi una luce come hold?\",\"Keyword della borsa\",\"Keyword della borsa per armi/scudi\",\"Keyword dell'oggetto shuriken\", \"Keyword dell'oggetto che tieni in mano\",\"Keyword dell'oggetto ti da' True Sight\",\"Key dell'dell'arma che usi per Dig e Cut\"],\n                 [this.usaLuce!=undefined ? this.usaLuce : false,\n  \t\t\t\t\t      this.borsa!=undefined ? this.borsa : \"borsa-ed\"+this.TSPersonaggio,\n                  this.borsaArmi!=undefined ? this.borsaArmi : \"\",\n                  this.throwObject!=undefined ? this.throwObject : \"shuriken\",\n                 this.holdItem!=undefined ? this.holdItem : \"sigillo-ed\"+this.TSPersonaggio,\n                 this.oggettoTrueSight!=undefined ? this.oggettoTrueSight : \"maschera-ed\"+this.TSPersonaggio,\n                 this.armaDigCut!=undefined ? this.armaDigCut : \"pugnale-ed\"+this.TSPersonaggio])).results\n\nthis.usaLuce = resUtil[0]\nthis.borsa = resUtil[1]\nthis.borsaArmi = resUtil[2]\nthis.throwObject = resUtil[3]\nthis.holdItem = resUtil[4]\nthis.oggettoTrueSight = resUtil[5]\nthis.armaDigCut = resUtil[6]\n\nawait askColori();\n  \nconst responseIdent = await askIdentify()\nthis.enableident = responseIdent[0]\nthis.publicident = responseIdent[1]\ntoggleClass(\"util|staffe\", responseIdent[2])\n//if (this.enableident) send(`ident_init`)\n//if (this.publicident) send(`identimport online`)\n  \nthis.setupdone = this.scriptVersion;\nif (this.mustMemorize) {\n  print(\"Per impostare l'Automemorize usa l'alias 'libro'.\")\n}\nthis.initDone = false;\nsend(\"initialize\");\ndelay(\"postinitialize\", 100, () => this.postInit ? this.postInit() : false)\ntoggleTrigger(\"leggiclassi\",true)\nsend(\"score\")\n",
	  "regex": false,
	  "is_script": true,
	  "class": "setup",
	  "enabled": true,
	  "is_prompt": false,
	  "shortcut": ""
	},
    {
      "pattern": "tickProc",
      "id": "",
      "value": "this.feastFatto = false;\nsend(\"calcoloPerHour\");\nif (this.memorizing) {\n  send(\"finememorize\")\n}\nlet tickInScadenza = () => {\n  print(color(\"[Tick in 10 secondi!]\",\"yellow\",null,true,false,false));\n  if (this.mustMemorize) delay(\"automemo\", 2000, () => { send(\"automemma\"); });\n};\nif (this.debug) {\n\tprint(color(\"[Tick \" + this.TickRemaining + \"]\",null,null,false,false,true));\n} else {\n\tprint(color(\"[Tick]\",\"black\",\"gray\",true,false,false));\n}\nif (this.autoinspire) {\n\tdelay(\"autoinspire\", 2000, () => send(\"inspire\"))\n}\n\nif (this.afkProcTimout) clearTimeout(this.afkProcTimout);\n\nthis.afkProcTimout = setTimeout(() => {\n  if (classEnabled(\"afk\")) {\n    send(\"afkProc\")\n  } else {\n    send(\"nonAfkProc\")\n  }\n}, 20000);\n\nif (!this.lastTickTime || typeof this.lastTickTime == \"string\") {\n  this.lastTickTime = new Date();\n}\nlet now = new Date();\nvar dif = Math.round((now.getTime() - this.lastTickTime.getTime())/1000);\nthis.TickDuration = dif;\nthis.lastTickTime = new Date();\nif (this.TickDuration > 75) {\n  this.ticksToLongTick = 8\n} else {\n  if (this.ticksToLongTick) this.ticksToLongTick--;\n}\nif (this.ticksToLongTick == 0) {\n  this.currentTickLenght = 80;\n} else {\n  this.currentTickLenght = 65;\n}\nvar tickLen = this.currentTickLenght;\nthis.TickRemaining = tickLen;\nif (this.tickInterval) {\n  clearTimeout(this.tickInterval);\n}\nlet tickFunc = (tickLen, id) => {\n  if (id != this.tickInterval) return;\n  tickLen--;\n  if (tickLen==10) {\n    tickInScadenza();\n  }\n  this.TickRemaining = tickLen;\n  if (tickLen>0) {\n    setTimeout(() => {\n      tickFunc(tickLen,id);\n    }, 1000);\n  }\n}\nthis.tickInterval = setTimeout(() => {\n  if (this.tickInterval) tickFunc(tickLen,this.tickInterval);\n}, 1000);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autoloot ?(.*)?",
      "id": "autoloot",
      "value": "const oldVal = this.autoloot;\n\nthis.autoloot = !this.autoloot;\n\nif (match && match[1] != undefined) {\n\tthis.autoloot = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoloot\", this.autoloot);\nlet str = (\"Autoloot: \"+ (this.autoloot ? \"ABILITATO\" : \"DISABILITATO\"));\nif (oldVal != this.autoloot) {\n  this.diciStatus(str);\n  if (!this.Immortal) {\n    if (this.autoloot) {\n        send(\"fischia\")\n    } else {\n      send(\"addio famiglio\"+this.TSPersonaggio)\n    }\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "es",
      "id": "",
      "value": "enter stagno",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ep",
      "id": "",
      "value": "enter portale",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "astral",
      "id": "",
      "value": "let comando = \"cast\"\nlet spell = \"astral\"\nif (this.mustMemorize && this.casttype.length==1 && this.casttype==\"M\") comando = \"recall\"\nif (this.casttype==\"M\") {\n  spell=\"teleport-w-e\"\n}\nif (this.mustMind) {\n  comando = \"mind\"\n  spell=\"probability\"\n}\nsend(`${comando} ${spell}`);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^fs( forced)?$",
      "id": "",
      "value": "let comando = \"cast\"\nlet spell = \"fires\"\nif (this.mustMemorize && this.casttype.length==1 && this.casttype==\"M\") comando = \"recall\"\nif (this.mustMind) {\n  comando = \"flames\"\n  spell=\"\"\n}\nif (!this.inCombat()||(match && match[1]==\" forced\")) send(`${comando} ${spell}`);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^dispe?l?(.+)?",
      "id": "",
      "value": "cast 'dispel m' $1",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ia",
      "id": "",
      "value": "if (!this.scudoAcid || this.ultimoScudo==this.scudoAcid) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoAcid) send(`get ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n      send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoCold) send(`rem ${this.scudoCold}`);\n  if (this.scudoEle) send(`rem ${this.scudoEle}`);\n  if (this.scudoFire) send(`rem ${this.scudoFire}`);\n}\nsend(`wear ${this.scudoAcid}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoCold) send(`put ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoEle) send(`put ${this.scudoEle} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = false;\nthis.usiImmuAcid = true;\nthis.usiImmuCold = false;\nthis.usiImmuFire = false;\nthis.Immu = \"ACID\";\nthis.ultimoScudo = this.scudoAcid;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ic",
      "id": "",
      "value": "if (!this.scudoCold || this.ultimoScudo==this.scudoCold) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoCold) send(`get ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n      send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoAcid) send(`rem ${this.scudoAcid}`);\n  if (this.scudoEle) send(`rem ${this.scudoEle}`);\n  if (this.scudoFire) send(`rem ${this.scudoFire}`);\n}\nsend(`wear ${this.scudoCold}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoAcid) send(`put ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoEle) send(`put ${this.scudoEle} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = false;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = true;\nthis.usiImmuFire = false;\nthis.Immu = \"COLD\";\nthis.ultimoScudo = this.scudoCold;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ie",
      "id": "",
      "value": "if (!this.scudoEle || this.ultimoScudo==this.scudoEle) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoEle) send(`get ${this.scudoEle} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n        send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoCold) send(`rem ${this.scudoCold}`);\n  if (this.scudoAcid) send(`rem ${this.scudoAcid}`);\n  if (this.scudoFire) send(`rem ${this.scudoFire}`);\n}\nsend(`wear ${this.scudoEle}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoCold) send(`put ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoAcid) send(`put ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = true;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = false;\nthis.usiImmuFire = false;\nthis.Immu = \"ELE\";\nthis.ultimoScudo = this.scudoEle;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "k",
      "id": "",
      "value": "kill $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autofollow ?(.*)?",
      "id": "autofollow",
      "value": "const oldVal = this.autofollow;\n\nthis.autofollow = !this.autofollow;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autofollow = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autofollow\", this.autofollow);\nif (oldVal != this.autofollow) {\n  let str = (\"Autofollow: \"+ (this.autofollow ? \"ABILITATO\" : \"DISABILITATO\"));\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autoorder ?(.*)?",
      "id": "autoorder",
      "value": "const oldVal = this.autoorder;\n\nthis.autoorder = !this.autoorder;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autoorder = (match[1] == \"true\" || match[1] == \"on\");\n}\n\nif (this.Immortal) this.autoorder = false;\n\ntoggleClass(\"autoorder\", this.autoorder);\nif (oldVal != this.autoorder) {\n  let str = (\"Autoorder: \"+ (this.autoorder ? \"ABILITATO\" : \"DISABILITATO\"));\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "tick",
      "id": "",
      "value": "send(\"emote dice: $c0010Tick in $c0009\" + this.TickRemaining + \"$c0015 sec.\");",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^afk( [^ ]+)?$",
      "id": "",
      "value": "const oldVal = this.afk;\nthis.afk = !this.afk;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.afk = (match[1].trim() == \"true\" || match[1].trim() == \"on\");\n}\nif (this.afkProcTimout) clearTimeout(this.afkProcTimout);\ntoggleClass(\"afk\", this.afk);\n\nif (oldVal != this.afk) {\n  if (this.afk) {\n    if (this.pgTitle) send(\"title \" + this.pgTitle + \" $c0008[AFK]$c0007\")\n  } else {\n    if (this.pgTitle) send(\"title \" + this.pgTitle)\n  }\n  let str = \"AFK: \"+ (this.afk ? \"ABILITATO\" : \"DISABILITATO\");\n  this.parlaStato = true\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "soloSettings",
      "id": "",
      "value": "if (this.Immortal) {\n  send(\"alloff\");\n  return;\n} else \ndelay(\"grouping\",2000,()=>{\n  send(\"autosanc off\");\n  send(\"autoassist off\");\n  send(\"autobash off\");\n  send(\"autorescue off\");\n  send(\"autostab off\");\n  if (this.canPlay) send(\"autosong off\");\n  send(\"autoloot on\");\n  send(\"autocast off\");\n  send(\"autostop off\");\n  if (this.healtype || this.canPlay) {\n    if (this.afk) {\n      send(\"autocleric 70\");\n    }\n  } else {\n    send(\"autocleric 0\");\n  }\n  toggleClass(\"indietro\", false)\n});",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "groupSettings",
      "id": "",
      "value": "if (this.Immortal) {\n  send(\"alloff\")\n  return;\n} else \ndelay(\"grouping\",2000,()=>{\n  send(\"autoassist \" + ((this.afk && (this.canBash || this.canStab))?\"on\":\"off\"));\n  if (this.canBash) send(\"autobash \" + ((this.afk && (this.canBash))?\"on\":\"off\"));\n  if (this.canStab || ( this.canPlay && \n                       (this.ultimoHold != this.strumentoFiato) &&\n                       (this.ultimoHold != \"-no-\")\n                      ) ) {\n    send(\"autostab \" + ((this.afk)?\"on\":\"off\"));\n    send(\"autoarmi off\");\n  \tif (this.afk) send(\"autostop on\");\n  }\n  if (this.canPlay) {\n  \tif (this.afk) {\n      send(\"autosong on\");\n      send(\"war\");\n    }\n  }\n  if (this.canBash) send(\"autorescue \" + ((this.afk && (!this.casttype))?\"on\":\"off\"));\n  send(\"autoloot off\");\n  if (this.afk && (this.healtype || this.canPlay)) send(\"autocleric 70\");\n  toggleClass(\"indietro\", true)\n  if (this.afk && !this.canStab && !this.canBash && (this.autocastSpell||this.spellOffensivo)) {\n    if (!this.canPlay)\n      send(\"autocast \" + (this.autocastSpell||this.spellOffensivo));\n  \telse send(\"autocast off\");\n  } else {\n  \tsend(\"autocast off\");\n  }\n});",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "printGruppo",
      "id": "",
      "value": "if (!this.Gruppo || this.Gruppo[0] != \"{\") { return; }\ncreateWindow(\"Gruppo\")\ncls(\"Gruppo\")\nconst grp = JSON.parse(this.Gruppo);\nlet grStr = \"\";\nlet cnt = 1;\nprint(color(` #          PG  ${color(\"HP\",\"red\")}  ${color(\"MN\",\"lightblue\")}  ${color(\"MV\",\"green\")}   SANC DO QUI`,\"gray\"), \"Gruppo\")\nif (!this.colorizeHp) return;\nthis.grandezzaGruppo = 0;\nlet capogruppoInRoom = false;\nfor (let nome in grp) {\n  if (typeof grp[nome] == \"string\") {\n    continue;\n  }\n  this.grandezzaGruppo++;\n  if (this.grandezzaGruppo == 1) {\n    capogruppoInRoom = grp[nome].inroom;\n  }\n  const numero = cnt.toString().padStart(2)+\".\";\n  const pg = this.colorizeHp(grp[nome].hp, nome.substr(0, 10).padStart(10));\n  const hp = this.colorizeHp(grp[nome].hp, grp[nome].hp.toString().padStart(3));\n  const mana = this.colorizeMana(grp[nome].mn, grp[nome].mn.toString().padStart(3));\n  const mov = this.colorizeMov(grp[nome].mv,grp[nome].mv.toString().padStart(3));\n  const sanc = this.colorizeBool(grp[nome].sanc||(this.TSSettore!=\"Chiuso\" && grp[nome].verde), ((grp[nome].sanc>1||(this.TSSettore!=\"Chiuso\" && grp[nome].verde>1)) ? \"+\" : ((grp[nome].sanc==1||(this.TSSettore!=\"Chiuso\" && grp[nome].verde==1))?\"!\":\"-\")).padStart(3));\n  const detect = this.colorizeBool(grp[nome].do, (grp[nome].do ? \"+\" : (grp[nome].do==1?\"!\":\"-\")).padStart(3));\n  const qui = this.colorizeBool(grp[nome].inroom, (grp[nome].inroom ? \"+\" : \"-\").padStart(3));\n  const hide = (grp[nome].hide ? \"+\" : \"-\").padStart(3);\n  const linea = color(`${numero} ${pg}: ${hp} ${mana} ${mov}  ${sanc} ${detect} ${qui}\\n`, \"lightgray\") + \"<br>\";\n  cnt++;\n  grStr += linea;\n}\nprint(grStr, \"Gruppo\")\nif(this.checkRimastoIndietro) {\n  this.checkRimastoIndietro = false;\n  if (!capogruppoInRoom && this.grandezzaGruppo > 1) {\n    send(\"gtTrigger $c5009Sono $c5009rimasto $c5009indietro!\");\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^bark (.*)|^bark$",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nsend(\"cast 'bark' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^anim (.*)|^anim",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nsend(\"cast 'animal a' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^do (.+)$|^do$",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nsend(\"cast 'detect o' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^sanc( .+)$|^sanc$",
      "id": "",
      "value": "if (!this.healtype) {\n  send(\"~sanc\");\n  return;\n}\nlet target = match[1] || this.TSPersonaggio\nlet spell = (this.healtype == \"C\" ? \"sanc\" : \"natures pro\");\nif (this.isTank()) {\n  print(\"Sanc mentre stai tankando!??\")\n  return;\n}\nif (this.TSPosizione!=\"In piedi\") {\n  send(\"stand\")\n}\nif (this.inCombat()) {\n  send(\"~stop\")\n}\nsend(\"~cast '\" + spell + \"' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^chain( .+)$|^chain$",
      "id": "",
      "value": "let comando = \"cast\"\nif (this.mustMemorize) comando = \"recall\"\nlet target = match[1] || this.TSPersonaggio\nsend(`${comando} 'chain l' `+target);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(storm|sblinka)",
      "id": "",
      "value": "send(\"cast 'firesto'\");",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(slash|blunt|pierce|arco|extra)$",
      "id": "",
      "value": "const isUltimaArmaStandard = () => (\n  (this.ultimaArma==this.armaSlash) || \n  (this.ultimaArma==this.armaBlunt) || \n  (this.ultimaArma==this.armaPierce) || \n  (this.ultimaArma==this.armaExtra) || \n  (this.ultimaArma==this.arco))\n\nlet armaVoluta;\nif (match[1]==\"slash\") armaVoluta = this.armaSlash;\nif (match[1]==\"blunt\") armaVoluta = this.armaBlunt;\nif (match[1]==\"pierce\") armaVoluta = this.armaPierce;\nif (match[1]==\"extra\") armaVoluta = this.armaExtra;\nif (match[1]==\"arco\") armaVoluta = this.arco;\n\n//Se l'arma voluta non è definita oppure è già l'arma in uso esci.\n//Nel caso dell'arco carica la freccia\nif (!armaVoluta || (this.ultimaArma == armaVoluta)) {\n  if (this.freccia && this.ultimaArma == this.arco) {\n    send(`load ${this.freccia}`);\n  }\n  return;\n}\n\n\n//FASE 1: Prendo l'arma dalla borsa\nsend(`get ${armaVoluta} ${this.borsaArmi||this.borsa}`);\nif (armaVoluta == this.arco) send(`get faretra ${this.borsaArmi||this.borsa}`);\n\n//FASE 2: libero lo spazio in eq\nif (this.ultimaArma!=\"-no-\") {\n  //Nelle configurazioni con Arma la tolgo.\n  if (this.ultimaArma) {\n    send(`rem ${this.ultimaArma}`);\n  } else {\n    //Se ultimaArma non è definita tolgo tutte le armi standard\n    for (let a of [this.armaSlash, this.armaBlunt, this.armaPierce, this.armaExtra, this.arco]) {\n      if (a && a!=armaVoluta) send(`rem ${a}`);\n    }\n  }\n}\nlet newhold = this.ultimoHold;\nif (this.ultimoHold!=\"-no-\" && this.isMonk()) {\n  //Nella configurazione con Hold tolgo la hold\n  if (this.ultimoHold) {\n    send(`rem ${this.ultimoHold}`);\n  } else {\n    //Se ultimoHold non è definito tolgo l'hold standard\n    if (this.holdItem) send(`rem ${this.holdItem}`);\n  }\n  newhold=\"-no-\";\n} \n  \n//FASE 3: Impugno l'arma\nsend(`~wear ${armaVoluta}`);\n\nif (this.freccia && (armaVoluta == this.arco)) {\n  send(`get ${this.freccia} ${this.borsaArmi||this.borsa}`)\n  send(`load ${this.freccia}\n        load faretra`)\n}\n\n\n//FASE 4: Metto l'oggetto tolto in borsa\nif (this.ultimaArma!=\"-no-\") {\n  //Nelle configurazioni con Arma che ho tolto la metto in borsa\n  if (this.ultimaArma) {\n    //se ultimaArma è definita ed è tra quelle standard la mette in borsa altrimenti\n    //la lascia in inventario\n    if (isUltimaArmaStandard()) send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n    } else {\n      for (let a of [this.armaSlash, this.armaBlunt, this.armaPierce, this.armaExtra, this.arco]) {\n        if (a && a!=armaVoluta) send(`put ${a} ${this.borsaArmi||this.borsa}`);\n      }       \n    }\n  if (this.usiArco) {\n    if (this.freccia) send(`put ${this.freccia} ${this.borsaArmi||this.borsa}`)\n    send(`put freccia faretra\n          put faretra ${this.borsaArmi||this.borsa}`);\n  }\n}\nif ((this.ultimoHold!=\"-no-\") && this.isMonk()) {\n  //Nella configurazione con Hold metto la hold in borsa\n  if (this.ultimoHold) {\n    //Se oggetto standard lo metto in borsa altrimenti lo lascio in inventario\n    if (this.ultimoHold==this.holdItem) send(`put ${this.ultimoHold} ${this.borsaArmi||this.borsa}`);\n  } else {\n    if (this.holdItem) send(`put ${this.holdItem} ${this.borsaArmi||this.borsa}`);\n  }\n} \n\n\nthis.usiSlash = (match[1]==\"slash\");\nthis.usiBlunt = (match[1]==\"blunt\");\nthis.usiPierce = (match[1]==\"pierce\");\nthis.usiExtra = (match[1]==\"extra\");\nthis.usiArco = (match[1]==\"arco\");;\nthis.ultimaArma = armaVoluta;\nthis.ultimoHold = newhold;",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "pb (.*)",
      "id": "",
      "value": "//send(`rem ${this.borsa}`);\nsend(`put ${match[1]} ${this.borsa}`);\n//send(`wear ${this.borsa}`);",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "gb (.*)",
      "id": "",
      "value": "//send(`rem ${this.borsa}`);\nsend(`get ${match[1]} ${this.borsa}`);\n//send(`wear ${this.borsa}`);",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^hum (.+)|^hum",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nif (this.TSSettore == \"Chiuso\") {\n\tsend(\"cast 'bloom'\");\n}\nsend(\"cast 'humanoid g' \" + target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^bloom",
      "id": "",
      "value": "cast 'bloom'",
      "regex": true,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "generaFunzioni",
      "id": "",
      "value": "this.autoKillMobs = this.autoKillMobs || \"\"\nthis.dangerMobs = this.dangerMobs || \"karoz barbaro errante\"\n\nthis.getAutokillMobs = () => {\nreturn (this.autoKillMobs||\"\").split(\"|\").filter(v => v)\n}\n\nthis.isDangerousMob = m => {\n  return (this.dangerMobs||\"\").split(\"|\").filter(v => v).indexOf(m)>-1\n}\n\nconst evList = {}\nthis.roomEnterEvents = () => evList; \n\nthis.onRoomEnter = (r,f) => {\n  this.roomEnterEvents()[r] = f\n}\n\nthis.isMonk = () => {\n  return this.canKick && !this.canBash;\n}\n\nthis.getMobs = () => {\n  const mobsInRoom = (this.Mobs||\"\").split(\"|\").filter(v => v.indexOf(\"famiglio\")==-1 && v.indexOf(\"mercenario\")==-1 && v.trim().length>0)\n  return mobsInRoom;\n}\n\nthis.getAutoKillTarget = () => {\n  const mobsInRoom = this.getMobs()\n  let target = null;\n  for (let m of mobsInRoom) {\n    if (this.isDangerousMob(m)) {\n      print(\"Ci sono mob pericolosi!\");\n      return null;\n    } else if (this.getAutokillMobs().indexOf(m)>-1) {\n      target = m;\n    }\n  }\n  //if (target) print(\"Target: \" + target)\n  return target;\n}\n\nthis.setupAutoKillList = () => {\n  let toKill = this.getAutokillMobs();\n  const mobsInRoom = this.getMobs()\n  for (let m of mobsInRoom) {\n    const toKillindex = toKill.indexOf(m);\n    if (toKillindex>-1) {\n    \tprint(link(\"Rimuovi \" + m + \" da AutoKill\", () => {\n          toKill.splice(toKillindex, 1)\n          toKill = [...new Set(toKill)]; // unique\n          print(\"Rimosso \" + m+ \" da AutoKill\");\n          this.autoKillMobs = toKill.join(\"|\")\n        }))\n    } else {\n        print(link(\"Aggiungi \" + m + \" a AutoKill\", () => {\n          toKill.push(m)\n          toKill = [...new Set(toKill)]; // unique\n          print(\"Aggiungo \" + m + \" a AutoKill\");\n          this.autoKillMobs = toKill.join(\"|\")\n        }))\n    }\n  }\n}\nthis.pgInGruppo = function(x) {\n  if (!this.Gruppo) return [this.TSPersonaggio];\n  let gruppo = JSON.parse(this.Gruppo);\n  let k = Object.keys(gruppo).slice(2);\n  if (x) {\n    let found = (k.find((v) => v.toLowerCase().startsWith(x.toLowerCase())));\n    if (found) return [...found]; else return [];\n  }\n  else \n  {\n    return k;\n  }\n}\nthis.digCut = function(command, key) {\n  if (!this.ultimaArma) {\n    if (!this.armaPrimaria) {\n      print(\"Definire l'arma primaria nel setup\");\n      return;\n    }\n    send(this.armaPrimaria);\n  }\n  this.ultimoHold = this.ultimoHold || this.holdItem || \"-no-\";\n  const cambiaArma = (this.ultimaArma!=this.armaDigCut)\n  if (cambiaArma) {\n    if (this.ultimaArma!=\"-no-\") send(`rem ${this.ultimaArma}`)\n    if (this.isMonk() && this.ultimoHold) send(`rem ${this.ultimoHold}`)\n    send(`gb ${this.armaDigCut}`)\n    send(`~wear ${this.armaDigCut}`)\n  }\n  send(`~${command} ${key}`)\n  if (cambiaArma) {\n    send(`rem ${this.armaDigCut}`)\n    if (this.ultimaArma!=\"-no-\") send(`~wear ${this.ultimaArma}`)\n    if (this.isMonk() && this.ultimoHold) send(`wear ${this.ultimoHold}`)\n    send(`pb ${this.armaDigCut}`)\n  }\n}\nthis.isCapogruppo = function(x) {\n  if (!this.Gruppo) return false;\n  let gruppo = JSON.parse(this.Gruppo);\n  let k = Object.keys(gruppo).slice(2);\n  if (!x) {\n    x = this.TSPersonaggio;\n  } else {\n    x = x.split(\" \")[0];\n  }\n  if (k && k[0]) {\n    return k[0].toLowerCase().startsWith(x.toLowerCase())\n  }\n  return false;\n}\n\nthis.diciStatus = function (str) {\n  print(str);\n  if (this.pgInGruppo().length > 1 && (this.afk || this.parlaStato)) {\n    send(\"gtTrigger \" + str);\n  }\n  this.parlaStato = false;\n}\nthis.colorizeHp = function(num, str) {\n  if (num > 95) {\n    return color(str, \"lightgray\");\n  } else if (num > 90) {\n    return color(str, \"green\");\n  } else if (num > 70) {\n    return color(str, \"lightgreen\");\n  } else if (num > 40) {\n    return color(str, \"yellow\", null, true, false, false);\n  } else if (num > 20) {\n    return color(str, \"orange\", null, true, true, false);\n  } else {\n    return color(str, \"red\", null, true, true, true);\n  }\n}\n\nthis.colorizeMana = function(num, str) {\n  if (num > 90) {\n    return color(str, \"lightgray\");\n  } else if (num > 70) {\n    return color(str, \"blue\");\n  } else if (num > 40) {\n    return color(str, \"lightblue\", null, true, false, false);\n  } else if (num > 20) {\n    return color(str, \"lightblue\", null, true, true, false);\n  } else {\n    return color(str, \"lightblue\", null, true, true, true);\n  }\n}\n\nthis.colorizeMov = function(num, str) {\n  if (num > 90) {\n    return color(str, \"lightgray\");\n  } else if (num > 70) {\n    return color(str, \"gray\");\n  } else if (num > 40) {\n    return color(str, \"gray\", null, false, false, false);\n  } else if (num > 20) {\n    return color(str, \"lightgray\", null, true, false, false);\n  } else {\n    return color(str, \"lightgray\", null, true, false, true);\n  }\n}\nthis.colorizeBool = function(v, str) {\n  if (!v) {\n    return color(str, \"yellow\", null, true, false, true);\n  } else {\n    return color(str, \"white\", null, true, false, false);\n  }\n}\nthis.isTank = (pg) => {\n  if (!pg) pg = this.TSPersonaggio;\n  return this.TSTank.toLowerCase()==pg.split()[0].toLowerCase();\n}\n\nthis.inCombat = () => {\n  return this.TSMobCond!=\"*\";\n}\nthis.coloraComunicazione = (str) => {\n  let words = str.split(\" \");\n  let colori = this.colori ? (typeof this.colori == 'string' ? [this.colori] : this.colori) : [\"$c0009\"];\n  for (let i = 0; i < Math.min(words.length,colori.length); i++) {\n    words[i] = colori[i]+words[i];\n  }\n  return words.join(\" \");  \n}\nthis.titleCase = function(txt) {\n  if (!txt) return \"\";\n  return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n}\nthis.cleanupName = (tank) => {\n  // per i monsum / charm\n  return tank.replace(/^(un'|l'|il |lo |un |una |uno |la |the )/gi, \"\")\n    .trim()\n    .split(' ')[0];\n}\nthis.limitaLista = (lista) => {\n  if (!lista) return;\n  if (lista.size) {\n    const surplus = lista.size - 600;\n    for (let i = 0; i < surplus; i++) {\n      lista.delete(lista.keys().next)\n    }\n  } else if (lista.length) {\n    const surplus = lista.length - 600;\n    for (let i = 0; i < surplus; i++) {\n      lista.splice(0, 1)\n    }\n  }\n}\nthis.stat = (tipo, quantita) => {\n  if (!this[\"lista\"+tipo] || !this[\"lista\"+tipo].set) {\n    this[\"lista\"+tipo] = new Map();\n  }\n  const lista = this[\"lista\"+tipo];\n  lista.set(new Date(), quantita);\n  this.limitaLista(lista);\n}\n\nconst tfunc = () => {\n  window.removeEventListener(\"touchstart\", tfunc);\n  const prev = this.usesTouch;\n  this.usesTouch = true;\n  if (this.usesTouch && !prev && !this.ClickControls) {\n    print(\"Touchscreen rilevato: Se vuoi puoi usare il pannello \" + link(\"touch\", () => send(\"touch\")));\n  }\n};\nwindow.addEventListener('touchstart', tfunc);\n\nthis.rotazioneArmi = () => {\n  if (this.usiBlunt) {\n    if (this.ordineArmi == \"1\") {\n      send(\"pierce\")\n    } else if (this.ordineArmi == \"2\") {\n      send(\"slash\")\n    }\n  }\n  else if (this.usiSlash) {\n    if (this.ordineArmi == \"1\") {\n      send(\"blunt\")\n    } else if (this.ordineArmi == \"2\") {\n      send(\"pierce\")\n    }\n  }\n  else if (this.usiPierce) {\n    if (this.ordineArmi == \"1\") {\n      send(\"slash\")\n    } else if (this.ordineArmi == \"2\") {\n      send(\"blunt\")\n    }\n  }\n  else {\n    if (this.armaPrimaria) send(this.armaPrimaria)\n  }\n}\n\nconst printPageWrap = (pageFunc, window, title, pageIndex, pageSize) => {\n  cls(window)\n  if (this.debug) print(`Mostro pagina ${pageIndex} di ` + window)\n  print(color(title,\"lighgreen\")+ \"\\n\",window)\n  \n  const numPages = Math.ceil(pageFunc(pageIndex, pageSize) / pageSize)\n  const prevPage = Math.max(pageIndex - 1, 0)\n  const nextPage = Math.min(pageIndex + 1, numPages - 1)\n  \n  const footer = (pageIndex > 0 ? link(\"<== \", () => printPageWrap(pageFunc, window, title, prevPage, pageSize)) : \"<== \") +\n        \" Pag.\" + (pageIndex+1)  + \"/\" + numPages + \" \" +\n        (pageIndex < numPages - 1 ? link(\" ==>\", () => printPageWrap(pageFunc, window, title, nextPage, pageSize)) : \" ==>\")\n  \n  print(\"\\n\" + footer,window);\n}\n\nthis.pageContent = async (window, pageFunc, title = \"\", pageIndex = 0, pageSize = 20, w, h, x, y) => {\n\n  let wnd = getWindow(window)\n  if (wnd?.data?.collapsed) {\n    // se c'e' ed era colassata serve tweakare e ricreare con i wnd.data\n    deleteWindow(window,true)\n    wnd.data.collapsed = false;\n    wnd.initialized = true; // prevent docking\n    wnd = createWindow(window, wnd.data)\n  }\n  \n  if (!wnd) {\n    // se non esiste questi sono i default\n    const data = {\n      w: w || 400,\n      h: h || 450,\n      x: x || 300,\n      y: y || 300,\n      visible: false,\n      collapsed: false,\n      docked:false\n    }\n  \twnd = createWindow(window, data)\n    wnd.initialized = true; // prevent docking\n  }\n  \n  let tmpdata = null;\n  \n  if (wnd) {\n    // se esiste ed era chiusa serve tweakarla\n    wnd.initialized = true;    // no docking\n    tmpdata = wnd.data;\n    \n    if (tmpdata) { // togli la roba fatta dall user\n      if (w) tmpdata.w = w;\n      if (h) tmpdata.h = h;\n      if (x) tmpdata.x = x;\n      if (y) tmpdata.y = y;\n    \ttmpdata.visible = true;\n      \ttmpdata.collapsed = false;\n      \ttmpdata.docked = false;\n    }\n    // la cancello cosi la ricrea con i tmpdata\n    await outputManager.getWindowManager().destroyWindow(window,true)\n  }\n  wnd = createWindow(window, tmpdata)\n  if (wnd) wnd.initialized = true; // non si sa mai, prevent docking\n\n  printPageWrap(pageFunc, window, title, pageIndex, pageSize)\n  \n}\n\nthis.initTraps = () => {\n  if (this.autodisarm || this.autotraps) {\n    //print(\"DEBUG: generaFunzioni->inizializzazione trigger trappole\");\n    deleteTempTrigger({id: \"trg_autotraps\"});\n    const listatrappole = getvar(\"elencoTraps\");\n\n    //let pattern = \"^(?:\\\\[ *\\\\d+\\\\] )?(?:\" + listatrappole.map(v => \"(\" + escapeRegex(v.long) + \")\").join(\"|\") + \")(?:\\\\[(\\\\d+)\\\\])?$\";\n    let pattern = \"^(?:\\\\[ *\\\\d+\\\\] )?(?:\" + listatrappole.map(v => \"(\" + escapeRegex(v.long) + \")\").join(\"|\") + \") *(?: *\\\\([^\\\\)]+\\\\))*(?:\\\\[(\\\\d+)\\\\])?$\";\n    let script = `\nlet keys = [\"${listatrappole.map(el=>el.key).join(\"\\\",\\\"\")}\"]\nlet index = 0;\nfor (let i = 1; i < match.length; i++) {\n  if (match[i]) {\n    index = i;\n    break;\n  }\n}\nconst qta = match[match.length-1] || 1;\nif (index) {\n  delay(\"trg_autotraps_delay_\"+index,100,()=>{\n    for (let numtrap=0;numtrap<qta;numtrap++) {\n      try {\n        this.roomTraps.push(keys[index-1]);\n      } catch(error) {\n        this.roomTraps = [];\n        this.roomTraps.push(keys[index-1]);\n      }\n    }\n    if (this.autotraps) print(link(color(\"Trappola: \" + keys[index-1],\"red\",\"blue\",true,false,true),()=>{send(\"disarm \" + keys[index-1])},\"disarm \" + keys[index-1]))\n  });\n  \n  if (this.autodisarm) {\n  //metto un delay così se ci sono piu' trappole e il trigger scatta piu' volte lancio comunque un solo disarm\n    delay(\"trg_autotraps_delay_disarm\", 150, ()=>{\n      send(\"detrap\");\n    });\n  }\n}\n`;\n\n    createTempTrigger({\n      id: \"trg_autotraps\",\n      is_script: true,\n      pattern: pattern,\n      regex: true,\n      value: script\n    })\n  } else {\n    //print(\"DEBUG: generaFunzioni->rimozione trigger trappole\");\n    deleteTempTrigger({id: \"trg_autotraps\"})    \n  }  \n}",
      "regex": false,
      "is_script": true,
      "class": "config",
      "enabled": true,
      "is_prompt": false,
      "shortcut": ""
    },
    {
      "pattern": "^selfshield(.*)",
      "id": "",
      "value": "this.selfshield = !this.selfshield;\n\nif (match && match[1] != undefined && match[1].trim().length) {\n\tthis.selfshield = (match[1].trim() == \"true\" || match[1].trim() == \"on\");\n}\n\ntoggleClass(\"selfshield\", this.selfshield);\nlet str = \"Selfshield: \"+ (this.selfshield ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^selfsanc(.*)",
      "id": "",
      "value": "const orig = this.selfsanc;\nthis.selfsanc = !this.selfsanc;\n\nif (match && match[1] != undefined && match[1].trim().length) {\n\tthis.selfsanc = (match[1].trim() == \"true\" || match[1].trim() == \"on\");\n}\n\ntoggleClass(\"selfsanc\", this.selfsanc);\nlet tipoSanc = \"Selfsanc\"\nif (this.healtype==\"C\" && (!this.casttype||this.casttype==\"C\") && !this.canBash && !this.canStab && this.pgInGruppo()?.length>1) {\n  tipoSanc = \"AutoGard\";\n}\nlet str = tipoSanc + \": \"+ (this.selfsanc ? \"ABILITATO\" : \"DISABILITATO\");\nif (orig != this.selfsanc) this.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "immuacid",
      "id": "",
      "value": "ia",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immucold",
      "id": "",
      "value": "ic",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immuele",
      "id": "",
      "value": "ie",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(gui|guild|gt|ot|sh|t \\w+|tell \\w+|hg|herog|shout|suss \\w+|gos|goss|gossip|grida|say|send \\w+|telep \\w+|mess \\w+) (.*)$",
      "id": "",
      "value": "const comunicazioni = {\n  gui: \"guildt\",\n  guild: \"guildt\",\n  gt: \"gte\",\n  ot: \"ot\",\n  sh: \"shout\",\n  t: \"tell\",\n  tell: \"tell\",\n  hg: \"herog\",\n  herog: \"herog\",\n  shout: \"shout\",\n  suss: \"suss\",\n  gos: \"gossip\",\n  goss: \"gossip\",\n  gossip: \"gossip\",\n  grida: \"shout\",\n  say: \"say\",\n  send: \"send\",\n  telep: \"telep\",\n  mess: \"mess\"\n}\nconst comm = match[1].split(\" \")[0];\nconst destinatario = match[1].split(\" \")[1] || \"\";\nsend(\"~\" + comunicazioni[comm] + \" \" + destinatario + \" \"+ this.coloraComunicazione(match[2]) + \"$c0007\");",
      "regex": true,
      "is_script": true,
      "class": "comunicazione",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "gtTrigger",
      "id": "",
      "value": "gt (trigger) $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "status",
      "id": "",
      "value": "let status = \"\";\nstatus+=`AASS:${this.autoassist?\"ON\":\"OFF\"} `;\nif (this.canBash) status+=`ABASH:${this.autobash?\"ON\":\"OFF\"} `;\nif (this.canStab) status+=`ASTAB:${this.autostab?\"ON\":\"OFF\"} `;\nif (this.spellOffensivo) status+=`ACAST:${this.autocast?\"ON\":\"OFF\"} `;\nstatus+=`ACL:${classEnabled(\"autocleric\")?this.aclMinimum+\"%\":\"OFF\"} `;\nstatus+=`ASANC:${classEnabled(\"autosanc\")?\"(\" + this.listaAutosanc.join(\",\") + \")\":\"OFF\"} `;\nif (this.healtype) status+=`SELFSANC:${this.selfsanc?\"ON\":\"OFF\"} `;\nif (this.spellOffensivo||this.healtype) status+=`SELFSHIELD:${this.selfshield?\"ON\":\"OFF\"} `;\nif (this.autokill) status+=`AKILL:(Krall,Stabh,Daemion,Grigie,Toewin,Geldor) `;\nthis.parlaStato = true;\nthis.diciStatus(status);\nthis.parlaStato = false;",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "autosanc",
      "id": "",
      "value": "asanc $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^asanc ?(.+)?$",
      "id": "",
      "value": "let orig = this.autosanc;\nthis.autosanc = !(this.autosanc||false);\nlet pg = (match[1]||\"\").trim();\nif (pg == \"off\" || pg == \"false\") {\n  this.autosanc = false;\n  this.listaAutosanc = [];\n  toggleClass(\"autosanc\", this.autosanc);\n  if (orig != this.autosanc) this.diciStatus(\"Autosanc: \" + (this.autosanc ? (this.listaAutosanc.length ? this.listaAutosanc : [\"[Nessuno]\"]).join(\",\") : \"DISABILITATO\"))\n  return;\n}\nif (pg) {\n  pg = this.titleCase(pg);\n  this.autosanc = true;\n  orig = null;\n}\nthis.listaAutosanc = this.listaAutosanc || [];\nif (pg) {\n  let index = this.listaAutosanc.indexOf(pg);\n  if (index>-1) {\n    this.listaAutosanc.splice(index,1);\n  } else {\n    this.listaAutosanc.push(pg);\n  }\n}\ntoggleClass(\"autosanc\", this.autosanc);\nlet str = \"Autosanc: \" + (this.autosanc ? (this.listaAutosanc.length ? this.listaAutosanc : [\"[Nessuno]\"]).join(\",\") : \"DISABILITATO\");\nif (orig != this.autosanc) this.diciStatus(str)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "afkProc",
      "id": "",
      "value": "if (this.Immortal) return;\nif (!this.inCombat()) {\n  if (this.TSSpells.toLowerCase().indexOf(\"o\")==-1 && this.healtype==\"D\") {\n    if (classEnabled(\"druid\")) send(\"do\");\n  }\n  if (this.TSSpells.toLowerCase().indexOf(\"f\")==-1 && this.selfshield) {\n    send(\"fs\");\n  }\n  if (this.TSSpells.toLowerCase().indexOf(\"s\")==-1 && this.healtype==\"C\" && this.selfsanc) {\n    send(\"sanc\");\n  } else if (this.TSSpells.toLowerCase().indexOf(\"n\")==-1 && this.healtype==\"D\" && this.selfsanc) {\n    if (this.TSSettore != \"Chiuso\" && this.TSSpells.toLowerCase().indexOf(\"s\")==-1) send(\"sanc\");\n  }\n  \n  if (this.afk && this.TSSpells.toLowerCase().indexOf(\"g\")==-1 && this.healtype==\"D\") {\n    if (this.TSSettore != \"Chiuso\" && classEnabled(\"druid\")) send(\"hum\");\n  }\n}\nsend(\"sancaAutosanc\")",
      "regex": false,
      "is_script": true,
      "class": "afk",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "align",
      "id": "",
      "value": "toggleClass(\"gtalign\",true);\nsend(\"score\");",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^sayStatus (.+)$",
      "id": "",
      "value": "this.diciStatus(match[1].trim())",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "manca",
      "id": "",
      "value": "var grp = JSON.parse(this.Gruppo)\nconst mancanti = [];\nfor (let nome in grp) {\n  \tif (typeof grp[nome] == 'string') continue;\n    if (!grp[nome].inroom) {\n      mancanti.push(nome);\n    }\n}\nif (mancanti.length) {\n  send(\"gtTrigger Manca\" + (mancanti.length>1 ? \"no\" : \"\") + \": \" + mancanti.join(\",\"));\n} else {\n  send(\"gtTrigger Ci siamo tutti!\");\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "grow",
      "id": "",
      "value": "hum",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "fog",
      "id": "",
      "value": "cast 'reveal'",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^rescue( .*)?$",
      "id": "",
      "value": "let target = input.split(\" \")[1] || this.TSTank;\nsend(\"~rescue \" + target);",
      "regex": true,
      "is_script": true,
      "class": "combat",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "r",
      "id": "",
      "value": "rescue $1",
      "regex": false,
      "is_script": false,
      "class": "combat",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "pola (.+)",
      "id": "",
      "value": "if (!match[1].trim()) {\n  print(\"Polare senza creatura specificata non va...\");\n}\nlet spell = \"poly\";\nlet comando = \"cast\"\nif (this.healtype == \"D\") {\n  spell = \"change f\"\n}\nif (this.mustMemorize) {\n  comando = \"recall\"\n}\n\nsend(`${comando} '${spell}' ${match[1].trim()}`);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immuice",
      "id": "",
      "value": "immucold $1",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "portal ?(.+)",
      "id": "",
      "value": "if (!match[1]) {\n  print(\"Si ma su di chi??\");\n}\nlet spell = \"portal\"\nsend(`cast '${spell}' ${match[1]}`)",
      "regex": true,
      "is_script": true,
      "class": "mage",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^gfly$",
      "id": "",
      "value": "let comando = \"cast\";\nif (this.mustMemorize) {\n  comando = \"recall\";\n}\nsend(`${comando} 'group f'`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^fly( .+)$|^fly$",
      "id": "",
      "value": "let comando = \"cast\"\nif (this.mustMemorize && !this.healtype) comando = \"recall\"\nlet target = match[1] || this.TSPersonaggio\nsend(`${comando} 'fly' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^ts( .+)$|^ts$",
      "id": "",
      "value": "let comando = \"cast\"\nlet target = match[1] || this.TSPersonaggio\nsend(`${comando} 'true s' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^flo( .+)$|^flo$",
      "id": "",
      "value": "let comando = \"cast\"\nlet target = match[1] || this.TSMob\nsend(`${comando} 'floating l' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^heat( .+)$|^heat$",
      "id": "",
      "value": "let comando = \"cast\"\nlet target = match[1] || this.TSMob\nsend(`${comando} 'heat st' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^shuri( .+)$|^shuri$",
      "id": "",
      "value": "send(`gb ${this.throwObject}`)\nif (match[1])\n  send(`throw ${this.throwObject} ${match[1]}`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(rece|casa)$",
      "id": "",
      "value": "if (this.healtype == \"D\") {\n  if (this.TSSettore==\"Chiuso\") {\n    send(\"bloom\")\n  }\n  send(\"tran vertus\");\n  send(\".13eneu\")\n} else if (this.healtype==\"C\" || this.canPlay) {\n  send(\"cast 'word'\")\n} else {\n  send(\"gb scrigno-ritorno\")\n  send(\"get ritorno scrigno-ritorno\")\n  send(\"pb scrigno-ritorno\")\n  send(\"rec rito\")\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "updateCombatStatus",
      "id": "",
      "value": "function getPercent(str) {\n  switch (str) {\n  case \"eccellente\":\n\treturn 100;\n  case \"graffiato\":\n\treturn 95;\n  case \"tagliato\":\n\treturn 85;\n  case \"ferito\":\n\treturn 65;\n  case \"sanguinante\":\n\treturn 40;\n  case \"squarciato\":\n\treturn 25;\n  case \"devastato\":\n\treturn 10;\n  case \"morente\":\n\treturn 1;\n\t}\n  return 100;\n}\nthis.tankMax = 100;\nthis.tankPercent = getPercent(this.TSTankCond)\nthis.tankKey = (this.TSTank||\"*\").split(\" \")[0]\nthis.tankKey = [this.tankKey[0].toUpperCase(),...this.tankKey.slice(1)].join(\"\")\nthis.mobMax = 100;\nthis.mobPercent = getPercent(this.TSMobCond)\nthis.mobKey = (this.TSMob||\"*\").split(\" \")[0]\nthis.mobKey = [this.mobKey[0].toUpperCase(),...this.mobKey.slice(1)].join(\"\")\nlet spells = this.TSSpells;\nthis.spells=\"\";\nfor (let i=0;i<spells.length;i++) {\n  switch (spells[i]) {\n    case 'F':\n    case 'f':\n      {\n        switch (spells[i+1]) {\n          case '2':\n            this.spells += color(spells[i],\"lightblue\", null, true)\n            i++;\n            break;\n          case '3':\n            this.spells += color(spells[i],\"blue\", null, true)\n            i++;\n            break;\n          case '4':\n            this.spells += color(spells[i],\"yellowgreen\", null, true)\n            i++;\n            break;\n          case '3':\n            this.spells += color(spells[i],\"yellow\", null, true)\n            i++;\n            break;\n          default:\n            this.spells += color(spells[i],\"red\", null, true)\n        }\n      }\n      break;\n    case 'S':\n    case 's':\n      this.spells += color(spells[i],\"white\", null, true)\n      break;\n    case 'N':\n    case 'n':\n      this.spells += color(spells[i],\"green\", null, true)\n      break;\n    case 'A':\n    case 'a':\n      this.spells += color(spells[i],\"blue\", null, true)\n      break;\n    case 'I':\n    case 'i':\n      this.spells += color(spells[i],\"cyan\", null, true)\n      break;\n    case 'D':\n    case 'd':\n      this.spells += color(spells[i],\"gray\", null, true)\n      break;\n    case 'G':\n    case 'g':\n      this.spells += color(spells[i],\"maroon\", null, true)\n      break;\n    default:\n      this.spells += spells[i]\n  }\n}\nif (this.TSSpells.toLowerCase().indexOf(\"s\")==-1) {\n  this.sancato = false;\n  this.scadenzaSanc = false;\n  if (window.sancTimeout) {\n      clearTimeout(window.sancTimeout);\n      window.sancTimeout = null;\n    }\n} else {\n  this.sancato = true;\n}\nif (this.TSSpells.toLowerCase().indexOf(\"f\")==-1) {\n  this.scudato = false;\n  this.scadenzaScudo = false;\n  if (window.scudoTimeout) {\n      clearTimeout(window.scudoTimeout);\n      window.scudoTimeout = null;\n    }\n} else {\n  this.scudato = true;\n}\nthis.spells+=color(\"B:\"+this.TSBlink,\"magenta\",null,true)",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "sr",
      "id": "",
      "value": "if (this.healtype==\"C\") {\n  send(\"cast 'shield r'\")\n} else {\n\tsend(\"gb scrigno-libro\")\n\tsend(\"get libro scrigno\")\n\tsend(\"pb scrigno-libro\")\n\tsend(\"rec libro\")\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "attack ?(.+)?",
      "id": "",
      "value": "let victim;\n\nif (!match[1]) {\n  //Se non c'è definito un target prendo come target il mob in combat se c'è oppure il primo della lista  \n  if (this.TSTank!=\"*\") {\n    victim = this.TSMob;\n    if (this.debug) print(\"attacking TSMob\");\n  } else if (this.Mobs && this.Mobs.length) {\n    let mob = this.Mobs ? this.Mobs.split(\"|\").\n      filter(m => (m.indexOf(\"famiglio\")<0)).\n      filter(m => (m.indexOf(\"mercenario\")!=0)) : [];\n    victim = match[1] || (mob[0] ? mob[0] : \"\");\n    if (this.debug) print(\"attacking first mob in list\");\n  }\n} else {\n  victim = match[1];\n}\n\nif (!victim) return;\n\nvictim = victim.replace(/ /g, \"-\")\nif (this.canStab && (this.ultimaArma == this.armaPierce)) {\n  //Per il ladro, se fuori combat parte di backstab, \n  //se in combat va di restab\n  if (!this.inCombat()) {\n    send(\"backstab \" + victim);\n  } else {\n    send(\"rs\");\n  }\n}\nelse if (this.canPlay) {\n  send(\"slam \" + victim);\n}\nelse if (this.canBash) {\n  send(\"bash \" + victim);\n}\nelse if (this.canKick) {\n  send(\"kick \" + victim);\n}else {\n  if (this.spellOffensivo) {\n    send(\"casta \" + victim);\n  } else {\n\tsend(\"hit \" + victim);\n  }\n}\nthis.onetimeLook = true;",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^rp (.+)",
      "id": "",
      "value": "cast 'remove pa' $1",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autocast ?(?:(.+))?",
      "id": "autocast",
      "value": "let oldVal = this.autocast;\n\nlet aca = classEnabled(\"autocast\");\nif (match && match[1] != undefined && match[1]==\"off\") {\n  aca = false;\n} else if (match && match[1] != undefined && match[1]==\"on\") {\n  aca = this.spellOffensivo || \"meteor swarm\"\n}\nelse if (match && match[1] != undefined) {\n  \toldVal = null;\n\taca = match[1];\n} else if (!match || !match[1]) {\n  aca = !aca;\n}\nthis.autocast = aca != false;\nif (!aca) {\n  if (oldVal != this.autocast) this.diciStatus(\"AutoCast OFF\");\n  toggleClass(\"autocast\", false);\n}\nelse {\n  if (aca == true) {\n    aca = this.spellOffensivo || \"meteor swarm\";\n  }\n  this.spellOffensivo = aca;\n  let str = (\"AutoCast ON (\" + this.spellOffensivo + \")\");\n  toggleClass(\"autocast\", true);\n  if (oldVal != this.autocast) {\n    this.diciStatus(str);\n  \tthis.TSTankCond=\"*\";\n    this.TSTank=\"*\";\n    send(\"checkAssist\");\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autorescue ?(.*)?",
      "id": "autorescue",
      "value": "const oldVal = this.autorescue;\nthis.autorescue = !this.autorescue;\n\nif (match && match[1] != undefined) {\n\tthis.autorescue = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autorescue\", this.autorescue);\nif (oldVal != this.autorescue) {\n\tlet str = \"AutoRescue: \"+ (this.autorescue ? \"ABILITATO\" : \"DISABILITATO\");\n\tthis.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autostop ?(.*)?",
      "id": "autostop",
      "value": "const oldVal = this.autostop;\n\nthis.autostop = !this.autostop;\n\nif (match && match[1] != undefined) {\n\tthis.autostop = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autostop\", this.autostop);\nlet str = \"AutoStop: \"+ (this.autostop ? \"ABILITATO\" : \"DISABILITATO\");\nif (oldVal != this.autostab) {\n  this.diciStatus(str);\n}\nif (!this.autostop) {\n  this.TSTankCond=\"*\";\n  this.TSTank=\"*\";\n  send(\"checkAssist\");\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autoarmi ?(.*)?",
      "id": "autoarmi",
      "value": "const oldVal = this.autoarmi;\n\nthis.autoarmi = !this.autoarmi;\n\nif (match && match[1] != undefined) {\n\tthis.autoarmi = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoarmi\", this.autoarmi);\nlet str = \"AutoArmi: \"+ (this.autoarmi ? \"ABILITATO\" : \"DISABILITATO\");\nthis.cambiArma = 0;\nthis.missARound = 0;\nthis.impugnatoArma=true;\nif (oldVal != this.autoarmi) {\n\tthis.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^antispalm ?(.*)?",
      "id": "antispalm",
      "value": "this.antispalm = !this.antispalm;\n\nif (match && match[1] != undefined) {\n\tthis.antispalm = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"antispalm\", this.antispalm);\nlet str = \"AntiSpalm: \"+ (this.antispalm ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^casta ?(.+)?$",
      "id": "",
      "value": "if (this.healtype) send(\"cura\");\nlet comando = this.mustMemorize ? \"recall\" : this.mustMind ? \"mind\" : \"cast\";\nlet spell = this.spellOffensivo;\nif (!spell) return;\n\nlet victim;\n\nif (!match[1]) {\n  //Se non c'è definito un target prendo come target il mob in combat se c'è oppure il primo della lista  \n  if (this.TSTank!=\"*\") {\n    victim = this.TSMob;\n    if (this.debug) print(\"attacking TSMob\");\n  } else if (this.Mobs && this.Mobs.length) {\n    let mob = this.Mobs ? this.Mobs.split(\"|\").\n      filter(m => (m.indexOf(\"famiglio\")<0)).\n      filter(m => (m.indexOf(\"mercenario\")!=0)) : [];\n    victim = match[1] || (mob[0] ? mob[0] : \"\");\n    if (this.debug) print(\"attacking first mob in list\");\n  }\n} else {\n  victim = match[1];\n}\n\nif (!victim) return;\n\nvictim = victim.replace(/ /g, \"-\")\nsend(`${comando} '${spell}' ${victim}`);\nthis.onetimeLook=true;\n",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "stoporfleeorlook",
      "id": "",
      "value": "if (this.inCombat()) {\n  if (this.TSTank.toLowerCase() == this.TSPersonaggio.toLowerCase()) {\n    send(\"stand;flee\")\n  } else {\n    send(\"stand;stop\")\n  }\n} else {\n  send(\"look\")\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "terra",
      "id": "",
      "value": "cast 'earth se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "aria",
      "id": "",
      "value": "cast 'wind se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "acqua",
      "id": "",
      "value": "cast 'water se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "fuoco",
      "id": "",
      "value": "cast 'fire se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "calcoloPerHour",
      "id": "",
      "value": "function addMinutes(date, minutes) {\n    return new Date(date.getTime() + minutes*60000);\n}\nlet sumLista = (lista) => {\n  let ret = {\n    \"ph\":0,\n    \"p5m\":0,\n    \"p15m\":0,\n    \"p1h\":0\n  }\n  const _1h = addMinutes(new Date(), -60);\n  const _15m = addMinutes(new Date(), -15);\n  const _5m = addMinutes(new Date(), -5);\n  lista.forEach((value,key) => {\n    value = Number(value)\n    if (key > _1h) {\n      ret.p1h += value\n    }\n    if (key > _15m) {\n      ret.p15m += value\n    }\n    if (key > _5m) {\n      ret.p5m += value\n    }\n  });\n  ret.ph = (0.42*ret.p5m*12 + 0.33*ret.p15m*4 + 0.25*ret.p1h);\n  return ret;\n}\n\nif (this.listaDivini && this.listaDivini.has) {\n  const ret = sumLista(this.listaDivini)\n  this._stat_pqh = Math.ceil(ret.ph);\n  this._stat_pq5m = ret.p5m;\n  this._stat_pq15m = ret.p15m;\n  this._stat_pq1h = ret.p1h;\n}\n\nif (this.listaXP && this.listaXP.has) {\n  const ret = sumLista(this.listaXP)\n  this._stat_xph = Math.ceil(ret.ph);\n  this._stat_xp5m = ret.p5m;\n  this._stat_xp15m = ret.p15m;\n  this._stat_xp1h = ret.p1h;\n}\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "if",
      "id": "",
      "value": "if (!this.scudoFire || this.ultimoScudo==this.scudoFire) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoFire) send(`get ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n    send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoCold) send(`rem ${this.scudoCold}`);\n  if (this.scudoAcid) send(`rem ${this.scudoAcid}`);\n  if (this.scudoEle) send(`rem ${this.scudoEle}`);\n}\nsend(`wear ${this.scudoFire}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoCold) send(`put ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoAcid) send(`put ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = false;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = false;\nthis.usiImmuFire = true;\nthis.Immu = \"FIRE\";\nthis.ultimoScudo = this.scudoFire;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immufire",
      "id": "",
      "value": "if $1",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^wi(?:e|el|eld)?(?: (.+))?$|^imp(?:u|ug|ugn|ugna)?(?: (.+))?$",
      "id": "",
      "value": "const arma = match[1] || match[2] || this.ultimaArma;\nsend(\"~wield \" + arma);\nthis.ultimaArma = arma",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^auto(stab|slam) ?(.*)?",
      "id": "autostab",
      "value": "const oldVal = this.autostab;\n\nthis.autostab = !this.autostab;\n\nif (match && match[2] != undefined) {\n\tthis.autostab = (match[2] == \"true\" || match[2] == \"on\");\n}\n\ntoggleClass(\"autostab\", this.autostab);\nif (oldVal != this.autostab) {\n    const tipoStab = this.canPlay ? \"Slam\" : \"Stab\";\n\tlet str = \"Auto\" + tipoStab + \": \"+ (this.autostab ? \"ABILITATO\" : \"DISABILITATO\");\n\tthis.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autofury ?(.*)?",
      "id": "autofury",
      "value": "const oldVal = this.autofury;\n\nthis.autofury = !this.autofury;\n\nif (match && match[1] != undefined) {\n\tthis.autofury = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autofury\", this.autofury);\nif (oldVal != this.autofury) {\n  let str = \"AutoFury: \"+ (this.autofury ? \"ABILITATO\" : \"DISABILITATO\");\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ac",
      "id": "",
      "value": "autocast",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "af",
      "id": "",
      "value": "autofury",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "as",
      "id": "",
      "value": "autostab",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "of",
      "id": "",
      "value": "order followers $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^sil[ea] (.+)",
      "id": "",
      "value": "cast 'silence' $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(storm|sblinka)",
      "id": "",
      "value": "cast 'ince'",
      "regex": true,
      "is_script": false,
      "class": "mage",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^enta (.+)$|^enta$",
      "id": "",
      "value": "let target = match[1] || this.TSMob.split(\" \")[0]\nsend(\"cast 'entangle' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^snare (.+)$|^snare$",
      "id": "",
      "value": "let target = match[1] || this.TSMob.split(\" \")[0]\nsend(\"cast 'snare' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "generaGold",
      "id": "",
      "value": "let g = Number(this.TSGold);\nlet b = Number(this.TSBank);\nlet divg = \"\";\nlet divb = \"\";\nif (g > 1000) {\n  divg = \"K\";\n  g /= 1000;\n}\nif (g > 1000) {\n  divg = \"M\";\n  g /= 1000;\n}\nif (b > 1000) {\n  divb = \"K\";\n  b /= 1000;\n}\nif (b > 1000) {\n  divb = \"M\";\n  b /= 1000;\n}\nb = b.toString().substr(0,5);\ng = g.toString().substr(0,5);\nif (g[g.length-1]==\".\") {\n  g = g.substr(0,g.length-1);\n}\nif (b[b.length-1]==\".\") {\n  b = b.substr(0,b.length-1);\n}\nthis.TSGoldK = g+divg;\nthis.TSBankK = b+divb;",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ar",
      "id": "",
      "value": "autorescue",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "touch",
      "id": "",
      "value": "this.ClickControls = !this.ClickControls",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ordinaborsa",
      "id": "",
      "value": "let func = (instash) => {\n  // gemme\n  send(\"gb all.gemma\")\n  send(\"pb all.gemma-scrigno\")\n  send(`${instash?\"unstash\":\"gb\"} sacca-alchimisti`)\n  for(let i = 0; i < 10; i++) {\n    send(\"put gemma sacca-alchimisti\");\n  }\n  send(`${instash?\"stash\":\"pb\"} sacca-alchimisti`)\n\n  // gocce\n  send(\"pb all.goccia\")\n  send(`${instash?\"unstash\":\"gb\"} scrigno-goccia`)\n  send(\"gb all.goccia\")\n  for(let i = 0; i < 6; i++) {\n    send(\"put goccia scrigno-goccia\");\n  }\n  send(`${instash?\"stash\":\"pb\"} scrigno-goccia`)\n  \n  // rami\n  send(\"gb all.ramo\")\n  send(`${instash?\"unstash\":\"gb\"} cesto-foglie`)\n  send(\"put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto\")\n  send(`${instash?\"stash\":\"pb\"} cesto-foglie`)\n\n  // cristalli\n  delay(\"ordina\",14000,()=>{\n    send(\"pb all.cristallo\")\n    let cristalli = \"forza|vita|difesa|concentrazione|spirito|salvezza|rigenerazione|precisione|potere|salute|ispirazione\".split(\"|\")\n\n    let ordina = (array) => {\n      if (!array) return;\n      let cris = array[0];\n      if (!cris) {\n        send(\"echo $c4011Ordinamento borsa completato.$c0007\")\n        return;\n      }\n      send(`${instash?\"unstash\":\"gb\"} scrigno-cristallo-`+cris);\n      send(\"gb all.cristallo-\"+cris);\n      for(let i = 0; i < 10; i++) {\n        send(\"put cristallo-\"+cris+\" scrigno-cristallo-\"+cris);\n      }\n      send(`${instash?\"stash\":\"pb\"} scrigno-cristallo-`+cris);\n      array.splice(0,1)\n      delay(\"ordina\",5000,()=>ordina(array));\n    }\n\n    ordina(cristalli);\n  });\n}\nconst res = await Messagebox.ShowWithButtons(\"Ordina gemme, rami e cristalli\", \"Devi avere Scrigni per ogni cristallo, Cesto per rami e Sacca alchimisti.\\nTieni i contenitori in stash? (SI)\\nO in borsa? (NO)\", \"SI\", \"NO\")\nfunc(res.button == 1)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^fixxa ?(.+)?$",
      "id": "",
      "value": "if (match && match[1]) {\n  send(\"tell \"+match[1]+\" (trigger) Ti uso per aggiustarmi l'equipaggiamento :-)\")\n}\nlet watchLag = 0.5 //7\nsend(\"wear all\");\n\nif (false) { // non serve piu\nif (this.healtype) {\n  if (this.oggettoTrueSight) {send(\"rem \"+this.oggettoTrueSight)}\n  send(\"ts\");\n  if (this.oggettoTrueSight) {send(\"wear \"+this.oggettoTrueSight)}\n} else {\n  if (this.oggettoTrueSight) {send(\"rem \"+this.oggettoTrueSight)}\n  watchLag = 17\n  send(\"watch\");\n  if (this.oggettoTrueSight) {send(\"wear \"+this.oggettoTrueSight)}\n}\n}\n\ndelay(\"remeq\", watchLag*1000, ()=>{\n  toggleClass(\"fixxa\",true)\n  this.oggettiRovinati = [];\n  send(\"eq\");\n  delay(\"remeq\", 2000, ()=>{\n    toggleClass(\"fixxa\",false)\n  \tsend(\"oggettiRovinati \"+(match&&match[1]?match[1]:\"\"));\n  });\n});",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^oggettiRovinati ?(.+)?$",
      "id": "",
      "value": "let repairer = (match && match[1] ? match[1] : \"\").trim();\nthis.oggettiRovinati = this.oggettiRovinati.reverse();\n\nfor (let ogg of this.oggettiRovinati) {\n  if (!ogg) continue;\n  //send(\"rem \"+ogg);\n  if (!repairer) {\n    send(\"fix \"+ogg+ \".ed\" + this.TSPersonaggio);\n  }\n}\n\nif (repairer) {\n  send(\"tell \"+repairer+\" (trigger) Inizio a riparare, ti avverto quando ho finito...\");\n  for (let ogg of this.oggettiRovinati) {\n    if (!ogg) continue;\n    send(\"fix \"+ogg+ \".ed\"+this.TSPersonaggio + \" \" + repairer);\n    //send(\"wear ed\"+this.TSPersonaggio);\n  }\n}\nif (repairer) {\n  send(\"tell \"+repairer+\" (trigger) Finito. Grazie!\");\n}\n\n",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^memo? ?(\\d+)? ?( '?([^']+)'?)?$",
      "id": "",
      "value": "const numero = (match[1]||1)\nconst spell = (match[3]||'')\nlet getSpell = (sp) => {\n  if (!this.spellVoluti) return sp;\n  return Object.keys(this.spellVoluti).find(v=>v.startsWith(sp.toLowerCase()))||sp;\n}\nlet segnaMemorize=(sp)=> {\n  const spell = getSpell(sp);\n  if (!spell) return;\n  if (!this.memorizing) this.memorizing = {};\n  if (!this.memorizing[spell]) this.memorizing[spell]=0\n  this.memorizing[spell]++;\n}\nif (spell) {\n  if (this.TSPosizione != \"A terra\") send(\"sit\")\n  for (let i = 0;i<numero;i++) {\n    send(`~memo '${spell}'`)\n    segnaMemorize(spell)\n  }\n} else {\n  toggleClass(\"memorize\",true)\n  this.spellMemmati = {};\n  send(\"~mem\");\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^libro ?(assegna|aggiorna|cancella)?$",
      "id": "",
      "value": "let parametro = match[1]\nif (!parametro) {\n  print(\"USO: libro assegna/aggiorna/cancella\")\n  print(\" - assegna: legge il contenuto del tuo libro e lo usa come template per memmare\")\n  print(\" - aggiorna: simile ma se fai cambiamenti aggiorni il libro voluto\")\n  print(\" - cancella: cancella il libro voluto, e quindi automemorize non funziona piu'\")\n  return\n}\n\nif (parametro == \"aggiorna\" || parametro == \"assegna\") {\n  send(\"memo\")\n  delay(\"libro\",2000,()=>{\n  \tthis.spellVoluti = {};\n    this.spellVoluti = Object.assign(this.spellVoluti, this.spellMemmati);\n    print(\"Letto \" + Object.keys(this.spellVoluti).length + \" spell.\");\n    print(\"Automemorize pronto!\");\n  });\n} else if (parametro == \"cancella\") {\n  this.spellVoluti = null;\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "mining",
      "id": "",
      "value": "//se non c'è impostata l'ultimaArma mette quella standard\nif (!this.ultimaArma) {\n  if (this.armaPrimaria) {\n    send(this.armaPrimaria)\n  } else {\n    print(\"Imposta l'arma primaria nel setup\");\n    return;\n  }\n}\nif (this.ultimaArma!=\"-no-\") send(`rem ${this.ultimaArma}`);\nif (!this.ultimoHold) {\n  if (this.holdItem) {\n    this.ultimoHold = this.holdItem;\n  } else {\n    this.ultimoHold = \"-no-\";\n  }\n}\nif (this.ultimoHold!=\"-no-\") send(`~rem ${this.ultimoHold}`);\nsend(`gb piccone\n~hold piccone\n~wield piccone\nmine\nrem piccone\npb piccone`);\nif (this.ultimaArma!=\"-no-\") send(`~wield ${this.ultimaArma}`);\nif (this.ultimoHold!=\"-no-\") send(`~hold ${this.ultimoHold}`);",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fishing",
      "id": "",
      "value": "if (!this.holdItem) {\n  print(\"Non hai configurato l'oggetto che hai tenuto. Rifai il setup.\");\n  return;\n}\nif (!this.esca) {\n  print(\"Non so che esca usi. Metti l'esca una volta manualmente con 'esca xyz' e sarai a posto.\");\n  return;\n}\nif (!this.ultimoHold) {\n  if (this.holdItem) {\n    this.ultimoHold = this.holdItem;\n  } else {\n    this.ultimoHold = \"-no-\";\n  }\n}\nif (this.ultimoHold!=\"-no-\") send(`~rem ${this.ultimoHold}`);\n\n\nsend(`gb canna-pesca\ngb ${this.esca}\n~hold canna-pesca\nbait ${this.esca}\nbait ${this.esca}\nbait ${this.esca}\nfish\nfish\nrem canna-pesca\npb canna-pesca`);\nif (this.ultimoHold!=\"-no-\") send(`~hold ${this.ultimoHold}`);\n",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^esca (.+)$",
      "id": "",
      "value": "this.esca = match[1]\nsend(\"~\"+input)",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "memma",
      "id": "",
      "value": "if (this.inCombat() || this.TSLag!=\"-\") {\n  print(\"Impossibile memmare in combat o da laggati\")\n  return;\n}\nif (!this.spellVoluti) {\n  print(\"Devi prima configurare il libro con alias libro\")\n  return;\n}\n\nlet spells = Object.keys(this.spellVoluti)\nlet daMemmare = {}\nlet countDaMemmare = 0;\nconst countMemmati = Object.keys(this.spellMemmati)\n\t\t.map(v => this.spellMemmati[v])\n\t\t\t.reduce((acc, cV) => acc + cV)\nfor\t(let s of spells) {\n  let voluto = this.spellVoluti[s]\n  let diff = voluto - (this.spellMemmati[s] || 0)\n  if (this.debug) print(`Sp ${s} vol ${voluto} dif ${diff}`)\n  if (diff>0) {\n  \tdaMemmare[s] = diff;\n    countDaMemmare += diff;\n  }\n}\nprint(`${countDaMemmare} spell da memmare.`)\nif (countDaMemmare) {\n  this.memorizing = {};\n  send(\"sit\");\n  let cnt = this.memorizeATick\n  let memmato = true;\n  while (memmato && cnt>0) {\n    memmato=false;\n    for (let s of Object.keys(daMemmare)) {\n      if (daMemmare[s]>0) {\n        memmato = true;\n        send(`~memo '${s}'`)\n        if (!this.memorizing[s]) this.memorizing[s]=0;\n        this.memorizing[s]++;\n        daMemmare[s]--;\n        cnt--;\n        if (cnt <= 0) break;\n      }\n    }\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "automemma",
      "id": "",
      "value": "if (!this.automemo || this.inCombat() || this.TSLag!=\"-\") return;\nif (!this.spellVoluti || this.memorizing) return;\n\nlet spells = Object.keys(this.spellVoluti)\nlet daMemmare = {}\nlet countDaMemmare = 0;\nconst countMemmati = Object.keys(this.spellMemmati)\n\t\t.map(v => this.spellMemmati[v])\n\t\t\t.reduce((acc, cV) => acc + cV)\nlet spellAZero = false;\nfor\t(let s of spells) {\n  let voluti = this.spellVoluti[s]\n  let avuti = (this.spellMemmati[s] || 0)\n  if (avuti == 0) spellAZero = true;\n  let diff = voluti - avuti\n  if (this.debug) print(`Sp ${s} vol ${voluti} dif ${diff}`)\n  if (diff>0) {\n  \tdaMemmare[s] = diff;\n    countDaMemmare += diff;\n  }\n}\nlet room = this.TSRoom;\nthis.spellDaMemmare = null;\nif ((countDaMemmare >= this.memorizeATick || spellAZero) &&\n   countDaMemmare + countMemmati < this.memorizeMaxLibro) {\n  let tempoMem = 6500 - (Math.min(this.memorizeATick, countDaMemmare)*250 + 250);\n  this.spellDaMemmare = daMemmare\n  send(\"emote $c4115MEMMA$c0015 tra \" + Math.floor(tempoMem/1000) + \" secondi.\");\n  delay(\"automem\", tempoMem, () => {\n    if (this.TSRoom == room) send(\"memma\")\n  })\n}",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "finememorize",
      "id": "",
      "value": "if (this.TSPosizione!=\"In piedi\" && this.finito_memmare == true) \n{\n  send(\"stand\")\n}\nthis.finito_memmare = false;\nif (!this.memorizing) return;\nif (this.spellMemmati) {\n  for\t(let s of Object.keys(this.memorizing)) {\n    if (!this.spellMemmati[s]) this.spellMemmati[s]=0;\n    this.spellMemmati[s] += this.memorizing[s];\n  }\n}\nthis.memorizing=null;",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^automemo? ?(true|on|off|false)?",
      "id": "",
      "value": "this.automemo = !this.automemo;\n\nif (match && match[1] != undefined) {\n\tthis.automemo = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"automemorize\", this.automemo);\nlet str = \"AutoMem: \"+ (this.automemo ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^cast '(.+)' ?(.+)?$",
      "id": "",
      "value": "const spell = match[1].toLocaleLowerCase();\nconst target = match[2]||'';\n\nlet spellDaNonRecallare = {\n  \"portal\":this.casttype==\"M\" && !this.canBash && !this.canStab && !this.healtype,\n  \"sanctuary\":true,\n  \"blink\": this.casttype==\"M\" && !this.canBash && !this.canStab && !this.healtype,\n  \"fly\": !this.healtype,\n  \"mana shield\": this.casttype==\"M\" && !this.canBash && !this.canStab && !this.healtype,\n}\n\nlet comando = \"cast\"\nif (this.mustMemorize && this.spellDaRecallare && \n   this.spellDaRecallare.indexOf(spell)>-1) {\n  comando=\"recall\"\n}\nif (comando==\"recall\" && Object.keys(spellDaNonRecallare).find(k=>k.startsWith(spell))) {\n  comando=spellDaNonRecallare[spell]?\"cast\":\"recall\";\n}\nif (comando!=\"recall\" && this.casttype && this.casttype == \"P\") {\n  comando=\"mind\"\n}\nthis.ultimoSpellCastato=spell\nthis.ultimoTargetSpell=target\nsend(`~${comando} '${spell}' ${target}`);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^forge?t? '?([^']+)'?$",
      "id": "",
      "value": "if (!this.seduto) send(\"sit\");\nsend(`~forget '${match[1]}'`);\nconst sp = Object.keys(this.spellMemmati||{}).find(v=>v.startsWith(match[1].toLowerCase()))\nif (sp) {\n  this.spellMemmati[sp]--;\n}\nsend(\"stand\")",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^wat(c|ch)?$",
      "id": "",
      "value": "for (let key of (this.oggettoTrueSight||\"\").split(\",\")) {\n  if (key) send(\"rem \" + key.trim())\n}\nsend(\"~watch\");\nfor (let key of (this.oggettoTrueSight||\"\").split(\",\")) {\n  if (key) send(\"wear \" + key.trim())\n}",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "po",
      "id": "",
      "value": "portal $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "nonAfkProc",
      "id": "",
      "value": "if (this.Immortal||!this.TSSpells) return;\nsend(\"sancaAutosanc\")\nif (this.TSSpells.toLowerCase().indexOf(\"f\")==-1 && this.selfshield) {\n    send(\"fs\");\n}\nif (this.TSSpells.toLowerCase().indexOf(\"s\")==-1 && this.healtype==\"C\" && this.selfsanc) {\n  send(\"sanc\");\n} else if (this.TSSpells.toLowerCase().indexOf(\"n\")==-1 && this.healtype==\"D\" && this.selfsanc) {\n  if (this.TSSettore != \"Chiuso\" && this.TSSpells.toLowerCase().indexOf(\"s\")==-1) send(\"sanc\");\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "sancaAutosanc",
      "id": "",
      "value": "if (this.Immortal) return;\nlet daSancare = [];\nlet nonSancati = [];\nlet sancati = 0;\nconst grp=JSON.parse(this.Gruppo||\"{}\")\nfor (let nome in grp) {\n    if (nome == \"tank\" || nome == \"mob\") continue;\n    // non in room o non curabile\n    if (grp[nome].hide || !grp[nome].inroom || grp[nome].pkill) {\n      continue;\n    }\n    if (!grp[nome].sanc && (this.listaAutosanc||[]).indexOf(nome)>-1) {\n      daSancare.push(nome)\n    } else if (!grp[nome].sanc) {\n     nonSancati.push(nome)\n    } else if (grp[nome].sanc) {\n      sancati++;\n    }\n  }\nif (daSancare.length) for (let nome of daSancare) {\n  send(\"sanc \" + nome)\n}\n\nif (this.afk && this.grandezzaGruppo>4 && sancati && nonSancati.length && sancati > 3) {\n  send(\"gt Alcuni in gruppo non sono sancati: \" + nonSancati.join(\",\"))\n}\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "vai",
      "id": "",
      "value": "console.log(\"vai \" + $1)\ndeleteWindow(\"Ricerca locazioni\");\nif (!$1 && !this.searchRooms) {\n  const showVai = () => {\n    for (const v of [...mapper.shortNameToRoom].sort((a,b)=>{\n      const nameA = a[0].toUpperCase(); // ignore upper and lowercase\n      const nameB = b[0].toUpperCase(); // ignore upper and lowercase\n      if (nameA < nameB) {\n        return -1;\n      }\n      if (nameA > nameB) {\n        return 1;\n      }\n\n      // names must be equal\n      return 0;\n    })) {\n      let key = v[0]\n    \tprint(link(color(key,\"yellow\", null, true, true), () => { send(\"vai \"+key) }) + \" -> (\" + v[1].id + \") \" + color(v[1].name,\"lightgray\"))\n    }\n  };\n  print(\"Non hai ricerche precedenti. Il comando vai senza parametri scorre tra le room dell'ultima ricerca.\")\n  print(\"Se vuoi vedere tutte le key disponibili al comando VAI premi \"+link(\"QUI\",showVai)+\".\")\n  print(\"Puoi usare anche VAI numero.\")\n  return\n}\n  if ($1 && !isNaN($1)) {\n    //Mikko 2300902 - Aggiunta controllo se la room di destinazione è una DT\n    //--start--\n    const destroom = mapper.idToRoom.get(Number($1));\n    if (destroom===undefined) {\n      print(\"Non esiste una stanza con questo id\");\n      return;\n    }\n    if (destroom?.type==8) {\n      print(\"La stanza \" + $1 + \" e' una DT\");\n      return;\n    }\n    //--stop--\n    mapper.walkToId($1);\n    this.walkingToId = $1\n  }\n  else if (!$1 && this.searchRooms) {\n    if (typeof this.searchRooms !=\"function\" || !this.searchRooms().length) {\n      print(\"Non c'e' nessuna altra room del 'cerca' da visitare.\")\n      this.searchRooms = null;\n      return;\n    }\n    let rNext = this.searchRooms()[0]\n    if (rNext.id == mapper.current?.id) {\n        this.searchRooms().splice(0,1)\n        rNext = this.searchRooms()[0]\n    }\n    if (rNext) {\n      print(\"Continuo alla prossima room dell'ultimo cerca: '\"+rNext.name+\"'.\")\n      this.searchRooms().splice(0,1)\n      send(\"vai \"+rNext.id)\n    }\n  }\n  else if (!!$1) {\n    mapper.walkToRoomShortName($1);\n  }\n//})",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "teleport",
      "id": "",
      "value": "print(\"Aspetto teleport: \"+$1)",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "dig",
      "id": "",
      "value": "this.digCut(\"dig\", $1)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "cut",
      "id": "",
      "value": "this.digCut(\"cut\", $1)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "room",
      "id": "",
      "value": "var room = null;\nif ($1) {\nroom = mapper.getRoomById($1)  \n} else\nroom = mapper.getSelected()\n\nif (room) {\n  if (this.debug) {\n  \tprint(JSON.stringify(room, null, 2))\n  } else {\n  \tprint(\"Ti trovi in #\" + room.id + \": \" + room.name)\n  }\n} else {\nprint(\"Nessuna room selezionata sul mapper.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "cerca",
      "id": "",
      "value": "if ($1) {\n  \tconst res = mapper.searchRooms($1)\n\tthis.searchRooms = () => res\n  \tsend(\"ricercaPrecedente \"+$1)\n} else if (this.searchRooms) {\n  send(\"ricercaPrecedente\")\n} else {\n  print(\"Si, ok, cerca, ma quale stanza? Non hai ancora eseguito nessuna ricerca precedente da mostrare.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "roomedit",
      "id": "",
      "value": "var room = null;\nif ($1) {\nroom = mapper.getRoomById($1)  \n} else\nroom = mapper.getSelected()\n\nif (room) {\n  const r = await Messagebox.ShowInput(\"Edit Room\",\"Modifica la room\", JSON.stringify(room, null, 2), true);\n  print((r.result))\n  if (r.button == 1 && r.result) {\n    const newRoom = JSON.parse(r.result)\n    mapper.setRoomData(room.id, newRoom)\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "porte",
      "id": "",
      "value": "let room = mapper.getSelected()\nif (room) {\n  const dirs = [\"n\",\"ne\",\"e\",\"se\",\"s\",\"sw\",\"w\",\"nw\",\"u\",\"d\"]\n  let trovatoPorta = false\n  for (let dir of dirs) {\n    const commands = []\n    if (room.exits[dir]) {\n      mapper.handlePossibleDoor({dir: dir, exit: room.exits[dir]}, false, commands)\n      for (let c of commands) {\n          if (c.type!=0) {\n            trovatoPorta = true\n            send(c.command)\n          }\n      }\n    }\n  }\n  if (!trovatoPorta) {\n    print(\"Non trovo porte da aprire qui'.\")\n  }\n} else {\n  print(\"Nessuna room selezionata sul mapper.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "qr",
      "id": "",
      "value": "quest request",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "qc",
      "id": "",
      "value": "quest complete",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "ricercaPrecedente",
      "id": "",
      "value": "pageContent(\"Ricerca locazioni\", (pageIndex, pageSize) => {\n  let total = 0\n  if (this.searchRooms && (total = this.searchRooms().length))\n  {\n    for (let i = pageIndex * pageSize; i < (pageIndex+1) * pageSize && i < total; i++) {\n      const r = this.searchRooms()[i]\n      let rid = r.id;\n      let zname = mapper.getRoomZone(r.id).name\n      zname = zname.replace(/\\ ?\\((by|trad)\\.? [^\\)]+\\)/i,\"\")\n      let rnd = Math.floor(Math.random()*10000)\n      let line = `<span><a id=\"walk${rid+\"-\"+rnd}\" class=\"underline clickable\" title=\"Vai a room ${r.id}\"><span style=\"color:yellow\">${r.id}</span></a> <span style=\"color:white\">${r.name}</span> <span style=\"color:gray\">(${zname})</span></span>`\n      print(line, \"Ricerca locazioni\")\n      setTimeout(() => {\n        const link = $(\"#walk\"+rid+\"-\"+rnd)\n        link.click(()=>{\n            print(\"Vado a room \"+rid + \"( \" + r.name + \" )\")\n            mapper.walkToId(rid)\n        })\n       }, 0)\n  \t}\n  } else {\n  \tprint(color(\" Nessuna :(\",\"red\"), \"Ricerca locazioni\")\n  }\n  delay(\"focuscommand\", 250, () => $(\"#cmdInput\").focus())\n  return total;\n}, \"Room trovate: \"+color(($1||\" \"),\"yellow\"), 0, 20, 750, 405)",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "onroomenter",
      "id": "",
      "value": "const room = mapper.current\n\nif (room && this.prev_room != room) {\n  \n  const prev_zone = (this.prev_room || room).zone_id\n  const current_zone = room.zone_id\n  \n  if (prev_zone != current_zone) {\n    if (prev_zone == 157 && mapper.mapmode) {\n    \tmapper.mapmode = false\n      print(\"Modalita' mappaggio spenta.\")\n    }\n  \ttoggleClass(\"zone:\"+prev_zone, false)\n    toggleClass(\"zone:\"+current_zone, true)\n  }\n  \n  this.prev_room = room\n}\n\nconst id = parseInt($1)\n\nif (!id) return;\n\nif (typeof this.roomEnterEvents != 'function') {\n\tsend(\"generafunzioni\")\n}\n\nconst destinazione = this.destinazione\n\nif (destinazione && destinazione.id == id) {\n  // cancello la variabile in modo che non scatti di nuovo\n  delete this.destinazione\n}\n      \nif (this.roomEnterEvents && this.roomEnterEvents() && this.roomEnterEvents()[id]) {\n  this.roomEnterEvents()[id]();\n  delete this.roomEnterEvents()[id]\n}\n\n//if (room) print(room.id + \"/\" + room.vnum)\nif (room && this.searchRooms && this.walkingToId == room.id) {\n\tvar rooms = this.searchRooms()\n    let removeIndex = rooms.findIndex(r => r.id == room.id)\n    if (removeIndex>-1) {\n      rooms.splice(removeIndex, 1)\n      if (rooms.length) {\n         this.searchRooms = () => rooms;\n      } else {\n      \t this.searchRooms = null;\n      }\n    }\n}\n\n\nif (room && this.returnRoom) {\n  let backId = this.returnRoom;\n  this.returnRoom = null;\n  \n  const exdirs =    ['n','e','s','w','u','d'];\n  //const exdirsRev = ['s','w','n','e','d','u'];\n  \n  for (let i=0; i<exdirs.length;i++) {\n    let dir = exdirs[i]\n  \tif (room.exits[dir] && room.exits[dir].to_room == backId) {\n   \t  send(exdirs[i])\n      if (this.stabTarget) {\n        send(\"backstab \"+ this.stabTarget)\n      \tthis.stabTarget = null;\n      }\n      return;\n    }\n  }\n}\n",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "restab",
      "id": "",
      "value": "if (this.mobKey==\"*\") {\n\tprint(\"Restab solo in combat\")\n  return;\n}\nthis.returnRoom = mapper.roomId\n\nif (this.TSPosizione != \"In piedi\") {\n\tsend(\"stand\")\n}\nthis.stabTarget = this.mobKey\nsend(\"flee\")",
      "regex": false,
      "is_script": true,
      "class": "thief",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "rs",
      "id": "",
      "value": "restab",
      "regex": false,
      "is_script": false,
      "class": "thief",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "autokill",
      "id": "",
      "value": "if (match && match[1] != undefined && match[1]!=\"\") {\n  if (match[1] == \"mobs\") {\n    if (this.setupAutoKillList) {\n      this.setupAutoKillList()\n      return;\n    }\n  } else if ([\"on\",\"off\",\"true\",\"false\"].indexOf(match[1])>-1) {\n\t// se passato parametro esso comanda (e.g. autobash false)\n\tthis.autokill = (match[1] == \"true\" || match[1] == \"on\");\n  }\n } else {\n\tthis.autokill = !this.autokill;\n}\n\ntoggleClass(\"autokill\", this.autokill);\nlet str = (\"AutoKill: \"+ (this.autokill ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ak",
      "id": "",
      "value": "autokill $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "autokillcheck",
      "id": "",
      "value": "delay(\"autokill\", 1000, () => {\n  if (!classEnabled(\"autokill\")) return;\n  let t = null;\n  if (!this.inCombat() && this.getAutoKillTarget && (t = this.getAutoKillTarget())) {\n\tprint(\"Autokill\");\n    this.Mobs = \"\";\n    send(\"attack \"+ t);\n  }\n});",
      "regex": false,
      "is_script": true,
      "class": "autokill",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "salta",
      "id": "",
      "value": "if (this.searchRooms) {\n\tvar rooms = this.searchRooms()\n    if (!rooms || !rooms.length) return;\n  \n    let removeIndex = !($1) ? 0 : rooms.findIndex(r => r.id == Number($1))\n    if (removeIndex>-1) {\n      print(\"Salto: \" + rooms[removeIndex].id + \" - \" + rooms[removeIndex].name)\n      rooms.splice(removeIndex, 1)\n      if (rooms.length) {\n         this.searchRooms = () => rooms;\n      } else {\n      \t this.searchRooms = null;\n      }\n    }\n}\n",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "alloff",
      "id": "",
      "value": "const oldFight = classEnabled(\"fight\")\nconst oldSorc = classEnabled(\"sorcerer\")\n\nsend(\"autosanc off\");\nsend(\"automem off\");\n\ntoggleClass(\"fight\", true)\ntoggleClass(\"sorcerer\", true)\n\nsend(\"autoassist off\");\nsend(\"autobash off\");\nsend(\"autorescue off\");\nsend(\"autostab off\");\nsend(\"autofury off\");\nsend(\"autocast off\");\n\ntoggleClass(\"fight\", oldFight)\ntoggleClass(\"sorcerer\", oldSorc)\n\nsend(\"autoloot off\");\n\nsend(\"autostop off\");\nsend(\"autocleric off\");\ntoggleClass(\"indietro\", false)",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "restring",
      "id": "",
      "value": "if (!$1) {\n  print(\"Dai la key dell'oggetto come parametro\");\n  return;\n}\nconst objKey = $1;\n\nconst results = (await Messagebox.ShowMultiInput(\"Restring\",\n                                                 [\"Nuova key\",\"Short desc\", \"Long desc\"],\n                                                 [\"\",\n                                                  \"\",\n                                                  \"\"])).results;\nif (!results) return;\nif (results.every(v => !!v)) {\n  send(`ostring ${objKey} ${results[0]}|${results[1]}|${results[2]}`, true)\n}\n",
      "regex": false,
      "is_script": true,
      "class": "immortal",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "tesor(o|i)",
      "id": "",
      "value": "const tesori = [\n  { room: 11151, key: \"Corno Tozzo\", comandi: \"get tesoro\" },\n  { room: 8844, key: \"Aryhann\", comandi: \"get scrign\" },\n  { room: 4242, key: \"Dasen Omir\", comandi: \"get monet forziere\" },\n  { room: 5970, key: \"Vena Argento\", comandi: \"get all\" },\n  { room: 268, key: \"Drago Fire\", comandi: \"get all\" },\n  { room: 10192, key: \"Toewin\", comandi: \"get monete\" },\n  { room: 12261, key: \"Midia Sud\", comandi: \"get all.monet\" },\n  { room: 11416, key: \"Tempio Midia\", comandi: \"get all\" },\n];\n\nif (!this.onRoomEnter) {\n\tsend(\"generafunzioni\");\n}\n\nconst getTesoro = (t) => {\n  this.onRoomEnter(t.room, () => { send(t.comandi) })\n  send(\"vai \"+ t.room)\n}\n\nfor (var t of tesori) {\n\tif (t.key.toLowerCase() == $1.toLowerCase()) {\n\t\tgetTesoro(t)\n      return\n    }\n}\n\nprint(\"Che tesoro vuoi prendere?\\n\")\n\nfor (let t of tesori) {\n  print(\"  \" + color(link(t.key, () => getTesoro(t), \"vai \" + t.room), \"yellow\"))\n}\n\nprint(\"\\nCe ne sono molti altri in giro per l'Impero Celeste.\\nForse dovresti cercarli per diventare piu' ricco di Stellos.\\n\");",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(portal|tran|transport) ?(.*)$",
      "id": "",
      "value": "const spell = match[1] == \"portal\" ? \"portal-v-p\" : \"tran-v-p\";\nconst parametro = (match[2] || null)\nconst comandi = {\n    1: () => send(\"cast \" + spell + \" Vertus\"),\n\t2: () => send(\"cast \" + spell + \" Schill\"),\n\t3: () => send(\"cast \" + spell + \" Reddie\"),\n\t4: () => send(\"cast \" + spell + \" Ghimm\"),\n\t5: () => send(\"cast \" + spell + \" Ciuffofoglio\"),\n\t6: () => send(\"cast \" + spell + \" Mythris\"),\n\t7: () => send(\"cast \" + spell + \" Odliw\"),\n\t8: () => send(\"cast \" + spell + \" Arion\"),\t\n\t9: () => send(\"cast \" + spell + \" Lorina\"),\n\t10: () => send(\"cast \" + spell + \" Andrew\"),\n\t11: () => send(\"cast \" + spell + \" Errimir\"),\n\t12: () => send(\"cast \" + spell + \" Hansi\"),\n\t13: () => send(\"cast \" + spell + \" Limoni\"),\n\t14: () => send(\"cast \" + spell + \" Eloise\"),\n\t15: () => send(\"cast \" + spell + \" Bambo\"),\n\t16: () => send(\"cast \" + spell + \" Radix\"),\n\t17: () => send(\"cast \" + spell + \" Melluyn\"),\n\t18: () => send(\"cast \" + spell + \" Sagi\"),\n\t19: () => send(\"cast \" + spell + \" Udiek\"),\n\t20: () => send(\"cast \" + spell + \" Wit\"),\t\n\t21: () => send(\"cast \" + spell + \" Lis\"),\n\t22: () => send(\"cast \" + spell + \" Brian\"),\n\t23: () => send(\"cast \" + spell + \" Verdorato\"),\n\t24: () => send(\"cast \" + spell + \" Kum\"),\n\t25: () => send(\"cast \" + spell + \" Lawandino\"),\n}\n\nif (parametro) { \n  \n  const comando = parseInt(parametro)\n  if (comando > 0 && comandi[comando]) {\n    // abbiamo il numero come parametro, esegui comando associato\n    comandi[comando]()\n  } else if (comando > 0 && !comandi[comando]) {\n    print(\"Non esiste quel numero di albero!\")\n  } else {\n    send(\"cast \" + spell + \" \" + parametro)\n  }\n  return // non ci serve la lista sotto se diamo parametro\n}\n\nprint(color(\"Portal/Transport via alberi druidici\", \"green\"))\nprint(\"Usa portal numero, oppure portal albero o click sul link.\\n\")\n\nprint(color(\"  1. Foresta di Haon D'Or: \", \"yellow\") + color(link(\"Vertus\", () => comandi[1]()),\"green\") )\nprint(color(\"  2. Foresta di Krall: \", \"yellow\") + color(link(\"Schill\", () => comandi[2]()),\"green\") )\nprint(color(\"  3. Foresta di Rhowyn: \", \"yellow\") + color(link(\"Reddie\", () => comandi[3]()),\"green\") )\nprint(color(\"  4. Foresta di Mirkwood: \", \"yellow\") + color(link(\"Ghimm\", () => comandi[4]()),\"green\") )\nprint(color(\"  5. Foresta di Isengard: \", \"yellow\") + color(link(\"Ciuffofoglio\", () => comandi[5]()),\"green\") )\nprint(color(\"  6. Foresta di Avalon: \", \"yellow\") + color(link(\"Mythris\", () => comandi[6]()),\"green\") )\nprint(color(\"  7. Foresta di Uhmea: \", \"yellow\") + color(link(\"Odliw\", () => comandi[7]()),\"green\") )\nprint(color(\"  8. Foresta di Darkenwood: \", \"yellow\") + color(link(\"Arion\", () => comandi[8]()),\"green\") )\nprint(color(\"  9. Bosco dei Druidi: \", \"yellow\") + color(link(\"Lorina\", () => comandi[9]()),\"green\") )\nprint(color(\" 10. Scacchiera: \", \"yellow\") + color(link(\"Andrew\", () => comandi[10]()),\"green\") )\nprint(color(\" 11. Montagne Orientali: \", \"yellow\") + color(link(\"Errimir\", () => comandi[11]()),\"green\") )\nprint(color(\" 12. Ninja: \", \"yellow\") + color(link(\"Hansi\", () => comandi[12]()),\"green\") )\nprint(color(\" 13. Camelot: \", \"yellow\") + color(link(\"Limoni\", () => comandi[13]()),\"green\") )\nprint(color(\" 14. Roo (mondo capovolto): \", \"yellow\") + color(link(\"Eloise\", () => comandi[14]()),\"green\") )\nprint(color(\" 15. Oasi nel Deserto: \", \"yellow\") + color(link(\"Bambo\", () => comandi[15]()),\"green\") )\nprint(color(\" 16. Castello di Tricksty: \", \"yellow\") + color(link(\"Radix\", () => comandi[16]()),\"green\") )\nprint(color(\" 17. Gallarcity: \", \"yellow\") + color(link(\"Melluyn\", () => comandi[17]()),\"green\") )\nprint(color(\" 18. Mordilnia: \", \"yellow\") + color(link(\"Sagi\", () => comandi[18]()),\"green\") )\nprint(color(\" 19. Skexie: \", \"yellow\") + color(link(\"Udiek\", () => comandi[19]()),\"green\") )\nprint(color(\" 20. Comp: \", \"yellow\") + color(link(\"Wit\", () => comandi[20]()),\"green\") )\nprint(color(\" 21. Albero di Lis: \", \"yellow\") + color(link(\"Lis\", () => comandi[21]()),\"green\") )\nprint(color(\" 22. Valle dei Maghi: \", \"yellow\") + color(link(\"Brian\", () => comandi[22]()),\"green\") )\nprint(color(\" 23. Skyrim: \", \"yellow\") + color(link(\"Verdorato\", () => comandi[23]()),\"green\") )\nprint(color(\" 24. Gilda degli Eroi: \", \"yellow\") + color(link(\"Kum\", () => comandi[24]()),\"green\") )\nprint(color(\" 25. Gilda Dark: \", \"yellow\") + color(link(\"Lawandino\", () => comandi[25]()),\"green\") )\n\nprint(\"\\n\")",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "portal ?(.+)",
      "id": "",
      "value": "if (!match[1]) {\n  print(\"Si ma su di chi??\");\n} else {\n\tsend(\"~portal ${match[1]}`);\n}",
      "regex": true,
      "is_script": true,
      "class": "psionic",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autoinspire ?(.*)?",
      "id": "",
      "value": "this.autoinspire = !this.autoinspire;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autoinspire = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoinspire\", this.autoinspire);\nlet str = \"AutoInspire: \"+ (this.autoinspire ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);\nif (this.autoinspire) {\n\tsend(\"inspire\")\n}\n",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(hold?|maneg) ?(.+)?",
      "id": "",
      "value": "let newhold = $2 || this.holdItem;\nsend(\"~hold \" + newhold)\nthis.ultimoHold = newhold; \n",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "play",
      "id": "",
      "value": "let song;\n\nif (!$1 && !this.ultimaSong) {\n  return;\n}\n\nif (!$1 && this.ultimaSong) {\n  song = this.ultimaSong\n  if (song.indexOf(\"'\") == -1 && song.indexOf(\"-\") == -1) {\n      song = \"'\" + song + \"'\"\n  }\n  send(\"~play \" + song);\n  return;\n}\n\nsong = $1.toLowerCase().replace(\"'\",\"\").replace(\"'\",\"\").replace(\"-\",\" \").replace(\"-\",\" \")\nthis.ultimaSong = song\n\nconst playInstruments = {\n  'song of w': this.strumentoPercussione,\n  'song of l': this.strumentoFiato,\n  'song of p': this.strumentoFiato,\n  'song of n': this.strumentoCorde,\n  'song of d': this.strumentoCorde\n}\n\nfor (let k in playInstruments) {\n\tif (song && song.startsWith(k)) {\n    const holdVoluto = playInstruments[k];\n\n    //Se l'hold voluto non è definita oppure è già l'hold in uso salta il cambio strumento\n    if (!holdVoluto || this.ultimoHold == holdVoluto) {\n      break;  \n    }    \n    \n    //FASE 1: Prendo l'oggetto dalla borsa\n    send(`get ${holdVoluto} ${this.borsaArmi||this.borsa}`);\n    \n    //FASE 2: Tolgo lo strumento dall'eq\n    if (this.ultimoHold!=\"-no-\") {\n      //Se sto tenento un oggetto hold\n      if (this.ultimoHold) {\n        send(`rem ${this.ultimoHold}`);\n      } else {\n        //Non so che hold sto tenendo quindi tolgo tutti gli strumenti;\n        for (let a of [this.strumentoPercussione, this.strumentoFiato, this.strumentoCorde]) {\n          if (a && a!=holdVoluto) send(`rem ${a}`);\n        }\n      }\n    }\n    \n    //FASE 3: Impugno lo strumento nuovo\n    send(`~wear ${holdVoluto}`);\n\n    //FASE 4: Metto l'oggetto tolto in borsa\n    if (this.ultimoHold!=\"-no-\") {\n      //Se stavo tenento un oggetto\n      if (this.ultimoHold) {\n        send(`put ${this.ultimoHold} ${this.borsaArmi||this.borsa}`)\n      } else {\n        //Non so che hold sto tenendo quindi metto in borsa tutti gli strumenti;\n        for (let a of [this.strumentoPercussione, this.strumentoFiato, this.strumentoCorde]) {\n          if (a && a!=holdVoluto) send(`put ${a} ${this.borsaArmi||this.borsa}`);\n        }\n      } \n    }\n    this.ultimoHold = holdVoluto;\n    break;\n  }\n}\n\nsong = match[1];\n\nif (match[1].indexOf(\"'\") == -1 && match[1].indexOf(\"-\") == -1) {\n\tsong = \"'\" + song + \"'\"\n}\n\nsend(\"~play \" + song);",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autosong ?(.*)?",
      "id": "",
      "value": "this.autosong = !this.autosong;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autobash false)\n\tthis.autosong = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autosong\", this.autosong);\nlet str = (\"AutoSong: \"+ (this.autosong ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "focus",
      "id": "",
      "value": "delay(\"focus\", 2000, () => {\n  send(\"remove ed\" + this.TSPersonaggio)\n  send(\"cast spirit-focus ed\" + this.TSPersonaggio)\n  send(\"wear ed\" + this.TSPersonaggio)\n});",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(giga?|vend?|spir?|eroe?|drag?|fugg?|idio?) (.+)",
      "id": "",
      "value": "send(\"tale \" + $1 + \" \" + $2)",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "portal ?(.+)",
      "id": "",
      "value": "if (!match[1]) {\n  print(\"Si ma su di chi??\");\n}\nlet spell = \"portal\"\nsend(`cast '${spell}' ${match[1]}`)",
      "regex": true,
      "is_script": true,
      "class": "cleric",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "sessione",
      "id": "",
      "value": "send(`gt Divini in sessione: ${parseInt(this._stat_pqsess)}`)\nsend(`gt XP in sessione: ${parseInt(this._stat_xpsess)}M`)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "refresh",
      "id": "",
      "value": "if (this.healtype || this.canPlay) {\n\tsend(\"cast 'seco' \" + $1);\n} else {\n  send(\"gtTrigger \" + $1 + \" ha Mov basso.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "poison",
      "id": "",
      "value": "if (this.ultimaArma && this.ultimaArma!=\"-no-\") {\n  send(\"rem \" + this.ultimaArma);\n  send(\"cast 'poison' \" + this.ultimaArma);\n  send(\"wear \" + this.ultimaArma);\n}\n\n\nif (!this.ultimoHold) {\n  if (this.holdItem) this.ultimoHold = this.holdItem;\n}\n\nif (this.ultimoHold && this.ultimoHold!=\"-no-\") {\n  send(\"rem \" + this.ultimoHold);\n  send(\"cast 'poison' \" + this.ultimoHold);\n  send(\"wear \" + this.ultimoHold);\n}\n",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "war",
      "id": "",
      "value": "play song of war",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "life",
      "id": "",
      "value": "play song of life",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "nat",
      "id": "",
      "value": "play song of nature",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "dumb",
      "id": "",
      "value": "play song of dumb",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "peace",
      "id": "",
      "value": "play song of peace",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "slam",
      "id": "",
      "value": "if (this.ultimoHold != this.strumentoSlam && this.strumentoSlam) {\n    const holdVoluto = this.strumentoSlam;\n  \n    //FASE 1: Prendo l'oggetto dalla borsa\n    send(`get ${holdVoluto} ${this.borsaArmi||this.borsa}`);\n    \n    //FASE 2: Tolgo lo strumento dall'eq\n    if (this.ultimoHold!=\"-no-\") {\n      //Se sto tenento un oggetto hold\n      if (this.ultimoHold) {\n        send(`rem ${this.ultimoHold}`);\n      } else {\n        //Non so che hold sto tenendo quindi tolgo tutti gli strumenti;\n        for (let a of [this.strumentoPercussione, this.strumentoFiato, this.strumentoCorde]) {\n          if (a && a!=holdVoluto) send(`rem ${a}`);\n        }\n      }\n    }\n    \n    //FASE 3: Impugno lo strumento nuovo\n    send(`~wear ${holdVoluto}`);\n\n    //FASE 4: Metto l'oggetto tolto in borsa\n    if (this.ultimoHold!=\"-no-\") {\n      //Se stavo tenento un oggetto\n      if (this.ultimoHold) {\n        send(`put ${this.ultimoHold} ${this.borsaArmi||this.borsa}`)\n      } else {\n        //Non so che hold sto tenendo quindi metto in borsa tutti gli strumenti;\n        for (let a of [this.strumentoPercussione, this.strumentoFiato, this.strumentoCorde]) {\n          if (a && a!=holdVoluto) send(`put ${a} ${this.borsaArmi||this.borsa}`);\n        }\n      } \n    }\n    \n    this.ultimoHold = holdVoluto;\n  \n  if (this.autosong) {\n    if (this.strumentoSlam == this.strumentoPercussione) {\n    \tthis.ultimaSong = \"song of w\"\n    } else {\n      this.ultimaSong = \"song of d\"\n    }\n  }\n\n}\n  \nsend(\"~slam \" + $1)",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fog",
      "id": "",
      "value": "send(\"+faerie-fog\")",
      "regex": false,
      "is_script": true,
      "class": "mage",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fog",
      "id": "",
      "value": "send(\"+faerie-fog\")",
      "regex": false,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(bash|bas|kick) ?(.+)?",
      "id": "",
      "value": "const param = ($2) ? ($2) : \"\"\nsend(\"~kick \" + param)",
      "regex": true,
      "is_script": true,
      "class": "monk",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "ident_init",
      "id": "",
      "value": "toggleClass(\"Ident\", !!this.enableident)\nif (!this.enableident) {return;}\n\nvar util = (window.dbIdentUtil = {})\nconst indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n\n\n//aggiungere abilitazione this.enableident == true\nutil.autoprovenienzaclear = function() {\n\tutil.autoprovenienza = {area:null, mob:null, room:null};\n}\n\n\nvar debug = () => this.debug;\n\n//Carica da indexedDB to memory (util.db) la lista ident pubblica e privata\nutil.init_load = async function() {\n  util.db = {};\n  util.db.lastID = -1;\n  util.db.dbinfo = {};\n  util.db.ogglistPubl = [];\n  util.db.ogglistPriv = [];\n  util.db.fields = [];\n  util.db.fieldsPos = {};\n  util.debug = debug;\n  util.autoprovenienzaclear();\n  \n  return new Promise(function(resolve, reject) {\n\n    function buildFieldsPos() {\n      for ( let fieldidx in util.db.fields) {\n        util.db.fieldsPos[util.db.fields[fieldidx].nome] = fieldidx;\n      } \n    }\n\n\n    const dbconn = indexedDB.open(\"IdentDb\", 1);\n    dbconn.onerror = (event) => {\n      const err = \"Errore nella connessione al DB degli ident\"\n      reject(err)\n      print(err);\n    };\n\n    dbconn.onupgradeneeded = (event) => {\n      const dbresult = event.target.result;\n\n      // Create an objectStore for this database\n      const objectStore = dbresult.createObjectStore(\"JSONstore\", { keyPath: \"ID\" });\n      objectStore.createIndex(\"JSONstring\", \"JSONstring\", { unique: true });\n    }; \n\n    dbconn.onsuccess = (event) => {\n      const dbresult = event.target.result;\n      const transaction = dbresult.transaction(\"JSONstore\", \"readonly\");\n      const store = transaction.objectStore(\"JSONstore\");\n      //nel record 1 di JSONStore c'è il db pubblico\n      //nel record 2 di JSONStore c'è il db privato\n      const jsonqueryPubl = store.get(1);\n      const jsonqueryPriv = store.get(2);\n\n      jsonqueryPubl.onsuccess = function(event) {\n      if (util.debug()) {print(\"Ident DB Pubblico caricato\");}\n        const r = event.target.result;\n        if (r != undefined) {\n          const objsaved = JSON.parse(r.JSONstring);\n          util.db.fields = objsaved.fields;\n          buildFieldsPos();\n          util.db.ogglistPubl = objsaved.data;\n          util.db.dbinfo = objsaved.dbinfo;\n        }\n      };\n\n      jsonqueryPubl.onerror = (event) => {\n        if (util.debug()) {\n          print(\"jsonqueryPubl error. Vedi console\");\n          console.log(event.target.errorCode);\n        }\n        reject(\"jsonqueryPubl error. Vedi console\")\n      };\n\n      jsonqueryPriv.onsuccess = function(event) {\n      \tif (util.debug()) {print(\"Ident DB Privato caricato\");}\n        const r = event.target.result;\n        if (r != undefined) {\n          const objsaved = JSON.parse(r.JSONstring);\n          if (!util.db.fields || !util.db.fields.length) {\n            util.db.fields = objsaved.fields;\n            buildFieldsPos();\n          }\n          util.db.ogglistPriv = objsaved.data || [];\n          if (!util.db.dbinfo) {\n            util.db.dbinfo = objsaved.dbinfo;\n          }\n        }\n      };\n\n      jsonqueryPriv.onerror = (event) => {\n        if (util.debug()) {\n          print(\"jsonqueryPriv error. Vedi console\");\n          console.log(event.target.errorCode);\n        }\n        reject(\"jsonqueryPriv error. Vedi console\")\n      };    \n\n      transaction.oncomplete = function() {    \n        if (util.debug()) {\n          print(\"Transaction complete\");\n          print(\"LOG Ident Publico DB Size:\" + util.getSize()[0]);\n          print(\"LOG Ident Privato DB Size:\" + util.getSize()[1]);\n        }\n        print(\"Database degli ident caricato. Versione: \" + util.db.dbinfo.ver + \" (\" + util.db.dbinfo.data + \") - \" + util.db.dbinfo.msg);\n        print(\"Elementi caricati nel db pubblico: \" + util.getSize()[0]);\n        print(\"Elementi caricati nel db privato:  \" + util.getSize()[1]);\n\n\n        if (!util.db.fields || !util.db.fields.length) {\n          util.db.fields = [{\"nome\":\"Oggetto\",\"type\":\"TEXT\"},{\"nome\":\"Tipo\",\"type\":\"TEXT\"},{\"nome\":\"DescrizioneShort\",\"type\":\"TEXT\"},{\"nome\":\"PosizioneIndossabile\",\"type\":\"TEXT\"},{\"nome\":\"Proprieta\",\"type\":\"TEXT\"},{\"nome\":\"Peso\",\"type\":\"NUMBER\"},{\"nome\":\"Valore\",\"type\":\"NUMBER\"},{\"nome\":\"Rent\",\"type\":\"NUMBER\"},{\"nome\":\"DescrizioneLong\",\"type\":\"TEXT\"},{\"nome\":\"Identify\",\"type\":\"TEXT\"},{\"nome\":\"Provenienza\",\"type\":\"TEXT\"},{\"nome\":\"Rare\",\"type\":\"BOOL\"},{\"nome\":\"NoRent\",\"type\":\"BOOL\"},{\"nome\":\"DannoArma\",\"type\":\"NUMBER\"},{\"nome\":\"Danno\",\"type\":\"NUMBER\"},{\"nome\":\"SP\",\"type\":\"NUMBER\"},{\"nome\":\"HP\",\"type\":\"NUMBER\"},{\"nome\":\"Mana\",\"type\":\"NUMBER\"},{\"nome\":\"Affect1Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect1Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect2Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect2Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect3Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect3Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect4Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect4Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect5Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect5Valore\",\"type\":\"TEXT\"},{\"nome\":\"ID\",\"type\":\"TEXT/NUMBER\"},{\"nome\":\"Nota\",\"type\":\"TEXT\"}];\n          buildFieldsPos();\n          if (util.debug()) {\n            print(\"Caricamento preset Fields\");\n          }\n        }\n\n\n\n        dbresult.close();\n        resolve()\n      };  \n    };\n  });\n}\n\n\n//Salve da memoria a indexedDB i 2 database.\nutil.save = async function(savePublic=false) {\n  return new Promise(function(resolve, reject) {\n    const dbconn = indexedDB.open(\"IdentDb\", 1);\n    dbconn.onerror = (event) => {\n      print(\"Errore nella connessione al DB degli ident\");\n      reject(\"Errore nella connessione al DB degli ident\")\n    };\n\n    dbconn.onsuccess = (event) => {\n      const dbresult = event.target.result;\n      const transaction = dbresult.transaction(\"JSONstore\", \"readwrite\");\n      const store = transaction.objectStore(\"JSONstore\");\n      if (savePublic) {\n        const saveobj = {dbinfo: util.db.dbinfo, fields:util.db.fields, data:util.db.ogglistPubl}\n        const addqueryPubl = store.put({ID:1, JSONstring: JSON.stringify(saveobj)});\n\n        addqueryPubl.onsuccess = function(event) {\n          if (util.debug()) {print(\"Ident DB Pubblico salvato\");}\n        };\n\n        addqueryPubl.onerror = (event) => {\n          if (util.debug()) {\n            print(\"addqueryPubl error. Vedi console\");\n            console.log(event.target.errorCode);\n          }\n          reject(\"addqueryPubl error. Vedi console\")\n        };   \n      } else {\n        const saveobjPriv = {dbinfo: {}, fields:util.db.fields, data:util.db.ogglistPriv}\n        const addqueryPriv = store.put({ID:2, JSONstring: JSON.stringify(saveobjPriv)});\n\n        addqueryPriv.onsuccess = function(event) {\n          if (util.debug()) {print(\"Ident DB Privato salvato\");}\n        };\n\n        addqueryPriv.onerror = (event) => {\n          if (util.debug()) {\n            print(\"addqueryPriv error. Vedi console\");\n            console.log(event.target.errorCode);\n          }\n          reject(\"addqueryPriv error. Vedi console\")\n        };\n      }    \n\n      transaction.oncomplete = function() {\n        if (util.debug()) {\n          print(\"Transaction complete\");\n          print(\"LOG Ident Publico DB Size:\" + util.getSize()[0]);\n          print(\"LOG Ident Privato DB Size:\" + util.getSize()[1]);\n        }\n        dbresult.close();\n        resolve()\n      };  \n    };\n  });\n}\n\n\n//Cerca l'oggetto basando su key, descshort e desclong\n//restituisce l'oggetto se trovato oppure null\n//Si usa l'assunto che gli oggetti del db sono univoci per Oggetto+Short+Long\n//Qualora ce ne fossero più d'uno viene restituito il primo\nutil.find = function(ogg) {\n  for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n    if (\n        (objdb[util.db.fieldsPos.Oggetto] === ogg.Oggetto) &&\n        (objdb[util.db.fieldsPos.DescrizioneShort] === ogg.DescrizioneShort) &&\n        (objdb[util.db.fieldsPos.DescrizioneLong] === ogg.DescrizioneLong)\n    )\n    {return objdb;}\n  }\n  return null;\n}\n\n\n//restituisce l'elenco degli oggetti con la descshort specificata\nutil.withshort = function(descshort) {\n    let found = [];\n    for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n        if ((objdb[util.db.fieldsPos.DescrizioneShort] == descshort) && !this.isalreadyin(found, objdb))  {\n            found.push(objdb)\n        }\n    }\n    return found;\n}\n\n//restituisce l'elenco degli oggetti con la desclong specificata\nutil.withlong = function(desclong) {\n    let found = [];\n    for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n        if ((objdb[util.db.fieldsPos.DescrizioneLong].split(\"\\n\")[0] == desclong) && !this.isalreadyin(found, objdb))  {\n            found.push(objdb)\n        }\n    }\n    return found;\n}\n\n\n//Cerca l'oggetto basando su ID\n//restituisce l'oggetto se trovato oppure null\n//Si usa l'assunto che gli oggetti del db sono univoci per ID\n//Qualora ce ne fossero più d'uno viene restituito il primo\nutil.findID = function(id) {\t\n    if (this.debug()) {\n\t\tprint(\"Ricerca dell'oggetto con ID: -->\" + id + \"<--\");\n\t}\n\tfor (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n      if (String(objdb[util.db.fieldsPos.ID]) === String(id)) {return objdb;}\n  \t}\n  \treturn null;\n}\n\n\n//La funzione delID permette di rimuovere un elemento dal db\n//è inernamente limitata a cancellare solo da db Privato.\nutil.delID = function(id) {\n  this.db.ogglistPriv = this.db.ogglistPriv.filter( _obj => (String(_obj[util.db.fieldsPos.ID]) != String(id)) ); \n  this.save();\n}\n\n\n//restituisce l'elenco degli oggetti che contengono\n//tutti gli elementi specificati nel testo e divisi da |, nell'ident\nutil.search = function(text) {\n    let criteriricerca = text.split(\"|\");\n    let found = [];\n    for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n      let criteriotrovato = true; \n      for (let criterio of criteriricerca) {\n      \t  if (\n            (objdb[util.db.fieldsPos.Identify] + \"\\n\" + objdb[util.db.fieldsPos.Provenienza]).toLowerCase().search(criterio.toLowerCase())<0\n          ) {\n          criteriotrovato = false;\n          break;\n          }\n        } \n      if ( criteriotrovato && !this.isalreadyin(found, objdb) ) {\n      \t//trovato un oggetto che soddisfa i requisiti\n        //e non già tra quelli trovati       \n        found.push(objdb);\n      }    \n    }\n    return found;\n}\n\n//Data una lista, verifica se l'oggetto è già presente nella lista\n//Da usare nelle varie funzioni find e search per non mettere duplicati\nutil.isalreadyin = function(list, ogg) {\n  let isgiatrovato = false;\n  for (let oggettolista of list) {\n    if (\n      (oggettolista[util.db.fieldsPos.Oggetto] === ogg[util.db.fieldsPos.Oggetto]) && \n      (oggettolista[util.db.fieldsPos.DescrizioneShort] === ogg[util.db.fieldsPos.DescrizioneShort]) &&\n      (oggettolista[util.db.fieldsPos.DescrizioneLong] === ogg[util.db.fieldsPos.DescrizioneLong])  \n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//Aggiunge l'oggetto passato al DB Privato e salva.\n//Assegna automaticamente il nuovo ID\nutil.add = function(ogg, oggisarray=false) {\n  function formattedDate(d = new Date) {\n    return [d.getDate(), d.getMonth()+1, d.getFullYear()].map(n => n < 10 ? `0${n}` : `${n}`).join('/');\n  }\n  \n  if (util.debug()) {print(\"LOG (util.add): Aggiunta dell'oggetto al DB Privato\");}    \n  util.db.lastID = \"Priv\" + String(this.getMaxID() + 1);\n  if (oggisarray) {    \n    ogg[util.db.fieldsPos.ID] = util.db.lastID;\n  \tif (util.debug()) {print(JSON.stringify(ogg));}\n  \tthis.db.ogglistPriv.push(ogg);    \n  } else {\n    ogg.ID = util.db.lastID;\n    let objarr = [ogg.Oggetto,\n                  null, //ogg.Tipo,\n                  ogg.DescrizioneShort,\n                  null, //ogg.PosizioneIndossabile,\n                  null, //ogg.Proprieta,\n                  null, //ogg.Peso,\n                  null, //ogg.Valore,\n                  null, //ogg.Rent,\n                  ogg.DescrizioneLong,\n                  ogg.Identify,\n                  ogg.Provenienza,\n                  null, //ogg.Rare,\n                  null, //ogg.NoRent,\n                  null, //ogg.DannoArma,\n                  null, //ogg.Danno,\n                  null, //ogg.SP,\n                  null, //ogg.HP,\n                  null, //ogg.Mana,\n                  null, //ogg.Affect1Tipo,\n                  null, //ogg.Affect1Valore,\n                  null, //ogg.Affect2Tipo,\n                  null, //ogg.Affect2Valore,\n                  null, //ogg.Affect3Tipo,\n                  null, //ogg.Affect3Valore,\n                  null, //ogg.Affect4Tipo,\n                  null, //ogg.Affect4Valore,\n                  null, //ogg.Affect5Tipo,\n                  null, //ogg.Affect5Valore,\n                  ogg.ID,\n                  formattedDate() //ogg.Nota\n                 ];\n  \tif (util.debug()) {print(JSON.stringify(objarr));}\n  \tthis.db.ogglistPriv.push(objarr);\n  }\n  this.save();\n  print(\"Oggetto aggiunto all'archivio privato con ID: \" + util.db.lastID)\n}\n\nutil.getStringIdents = function(arr) {\n  let out=\"\";\n  for (let ogg of arr) {\n      out += \"ID: \" + color(ogg[util.db.fieldsPos.ID],\"yellow\") + \"\\n\";\n      out += ogg[util.db.fieldsPos.Identify] + \"\\n\";\n      out += \"Provenienza: \" + ogg[util.db.fieldsPos.Provenienza] + \"\\n\\n\";\n  }\n  return(out);\n}\n\nutil.getSize = function() {\n  return [this.db.ogglistPubl?.length, this.db.ogglistPriv?.length];\n}\n\n//restituisce l'ID maggiore nell'db Privato\n//Nel DB privato gli ID vengono salvati nella forma PrivXXXX\nutil.getMaxID = function() {\n  let id = 0;\n  for (let objdb of this.db.ogglistPriv) {\n    let objdbid = Number(objdb[util.db.fieldsPos.ID].substring(4));\n    if (objdbid>id) {id=objdbid;}\n  }\n  return id;\n}\n\nutil.parseident = function(identText) {\n  let obj={};\n\n  try {\n    obj.Oggetto = identText.match(/^Oggetto '(.+?)' - Tipo: (.+)$/m)[1];\n    obj.Tipo = identText.match(/^Oggetto '(.+?)' - Tipo: (.+)$/m)[2];\n  }\n  catch(err) {\n    obj.Oggetto = \"\";\n    obj.Tipo = \"\";\n  }\n  \n  try {\n    obj.DescrizioneShort = identText.match(/^Descrizione (?:corta|short): '(.+?)'$/ms)[1].replace(\"\\n\",\" \");\n  }\n  catch(err) {\n    obj.DescrizioneShort = \"\";\n  }\n\n  try {\n    obj.DescrizioneLong = identText.match(/^Descrizione (?:lunga|long): '(.*?)'$/ms)[1].replace(\"\\n\",\" \");\n  }\n  catch(err) {\n    obj.DescrizioneLong = \"\";\n  }\n  \n  obj.Identify = identText;\n  obj.Provenienza = \"\"; \n  return obj;\n}\n\nutil.getCurrentZonaLabel = function() {\n  if (util.mapZones === undefined) {\n    util.mapZones = new Map(\n  \t\tmapper.db.zones.map(object => {\n    \t\treturn [object.id, object.label];\n  \t\t}),\n\t);\n  }\n  return util.mapZones.get(mapper?.current?.zone_id) || \"\";\n}\n\n\n/*util.getautoprovenienza = function() {\n  let prov = this.getCurrentZonaLabel();\n  if (util.autoprovenienza.ultimoMobUcciso != null) {\n    prov += \" - \" + util.autoprovenienza.ultimoMobUcciso;\n  }\n  if (util.autoprovenienza.room != null) {\n    prov += \" (\" + util.autoprovenienza.room + \")\";\n  }\n  return prov;\n}\n\n\nutil.buildautoprovenienza = function() {\n    print(link(\"Click per aggiungere la provenienza:\",()=>{\n      send(\"setprovenienza \\\"\" + util.getautoprovenienza() + \"\\\"\");\n    }\n    ) + \" \" + util.getautoprovenienza());\n  \n    print(link(\"Aggiungi ultimo mob ucciso:\", ()=>{\n        util.autoprovenienza.ultimoMobUcciso = (window.ultimoMobUcciso || null);\n        this.buildautoprovenienza();  \n    }                                                   \n    ) + \" \" + (window.ultimoMobUcciso || \"\") ); \n  \n    print(link(\"Aggiungi stanza:\", ()=>{\n        util.autoprovenienza.room = mapper.current.id;\n        this.buildautoprovenienza();\n    }                                                   \n    ) + \" \" + mapper.current.id);  \n    print(\"\\n\");\n}\n*/\n\nawait util.init_load();\n\n",
      "regex": false,
      "is_script": true,
      "class": "IdentInit",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^identimport( privato$| pubblico$| online$| purge$|$)",
      "id": "",
      "value": "let util = window.dbIdentUtil;\nif (!util) {\n  send(\"ident_init\")\n}\nutil = window.dbIdentUtil;\n\nconst database = match[1].trim() || \"privato\";\n\n\nasync function importPublicoObj(objparsed) {\n  util.db.ogglistPubl = objparsed.data;\n  util.db.dbinfo = objparsed.dbinfo;  \n  util.db.fields = objparsed.fields;\n  await util.save(true);\n}\n\nasync function importPublico(text) {\n  let objparsed = JSON.parse(text);\n  await importPublicoObj(objparsed)\n}\n\nasync function importPrivato(text) {\n  let objparsed = JSON.parse(text);\n  util.db.ogglistPriv = objparsed.data;\n  await util.save(false);\n}\n\n\nfunction importFromFile(callback) {\n    if (!callback) return;\n    let inp = document.createElement(\"input\");\n    inp.type = \"file\";\n    inp.style.visibility = \"hidden\";\n\n    inp.addEventListener(\"change\", (e) => {\n        let file = e.target.files[0];\n        if (!file) {\n            return;\n        }\n\n        let reader = new FileReader();\n        reader.onload = (e1) => {\n            let text = e1.target.result;\n            callback(text)\n        };\n        reader.readAsText(file);\n\n    });\n\n    document.body.appendChild(inp);\n    inp.click();\n    document.body.removeChild(inp);\n}\n\nasync function loadOnlineDB(prefix) {\n  //print(prefix + \"/identDbPublicVersion.json?rng=\"+Math.random())\n  const res1 = await fetch(prefix + \"/identDbPublicVersion.json?rng=\"+Math.random())\n  const verData = await res1.json();\n\n  if (verData.dbinfo.ver > (util.db.dbinfo?.ver || 0)) {\n    // versione nuova online, aggiorniamo il pubblico\n    \n  \tconst res2 = await fetch(prefix + \"/identDbPublic.json?rng=\"+Math.random())\n  \tconst dbObj = await res2.json();\n    importPublicoObj(dbObj)\n\t  print(\"Eseguo aggiornamento del DB Identify pubblico a v\" + verData.dbinfo.ver)\n  \n  } else {\n    //print(\"La versione del DB Identify pubblico e' aggiornata all'ultima versione disponibile sul server.\")\n  }\n}\n\nif (database == \"pubblico\") {\n  importFromFile(importPublico);\n} else if (database == \"privato\") {\n  importFromFile(importPrivato);\n} else if (database == \"purge\") {\n  util.db.ogglistPubl = [];\n  util.db.ogglistPriv = [];\n  util.db.dbinfo = {};  \n  util.db.fields = [];\n  util.save(true);\n  util.save(false);\n} else if (database == \"online\") {\n  //print(window.location)\n\n  let prefix = \"\"\n  if (window.ipcRenderer) {\n    // nel binario primo fetch locale, quello sotto non sovrascrive\n    // se contiene il piu recente in quanto fa il version check\n    prefix = \"electron://./dist/public\"\n    await loadOnlineDB(prefix);\n  }\n  \n  if (window.ipcRenderer) {\n    // binario prova a aggiornare dal live casomai abbia vecchio\n    prefix = \"https://www.temporasanguinis.it/client\"\n  } else if (window.location.hostname.indexOf(\"temporasanguinis\")!=-1) {\n     // online sul web nella cartella client\n    prefix = \"/client\"\n  } else {\n    // altri siti hostati in locale nel root\n    prefix = \"\"\n  }\n\n  loadOnlineDB(prefix);\n  \n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^l(o|$)(o|$)k{0,1} ?(.*)$",
      "id": "look",
      "value": "if (classEnabled(\"Ident\") && !($3)) toggleTrigger(\"usciteVisibili\", true);\nthis.Mobs = \"\"\nsend(\"~look\" + (($3) ? (\" \" + ($3)) : \"\"))",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^identdel (Priv\\d+|All)$",
      "id": "",
      "value": "var util = window.dbIdentUtil;\nif (match[1] == \"All\") {\n  util.db.ogglistPriv = [];\n  util.save();\n  print(\"il database privato è stato svuotato\");\n} else {\n\tutil.delID(match[1]);\n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^setprovenienza (Priv\\d+|\\d+)$|^setprovenienza$",
      "id": "",
      "value": "var util = window.dbIdentUtil;\n\nlet objID = match[1] || util.db.lastID;\nlet oggdb = util.findID(objID);\nif (oggdb == null) {\n  if (objID>=0) print(\"L'oggetto con ID \" + objID + \" non esiste\");\n  if (objID<0) print(\"Non hai aggiunto nessun oggetto al database\");\n  print(\"\\nUSO:\");\n  print(color(\"setprovenienza\",\"yellow\")+ \" -> apre la maschera per cambiare la provenienza dell'ultimo oggetto aggiunto al database\");\n  print(color(\"setprovenienza &ltid&gt\",\"yellow\")+ \" -> apre la maschera per cambiare la provenienza dell'oggetto con l'id specificato\");\n  print(\"L'id ò un numero per gli oggetti del database pubblico ed è Priv&ltnum&gt per gli oggetti del database privato\");\n \n  return;\n}\n\nconst title = \"Impostare provenienza\"; const name = title.replace(/ /g,\"-\");\nconst win = document.createElement(\"div\");\nwin.style.display = \"none\";\nwin.className = \"win-\"+name;\ndocument.body.appendChild(win);\n\nlet daAggiornare=false;\nlet provenienza_old = oggdb[util.db.fieldsPos.Provenienza];\nlet provenienza_new = provenienza_old;\n\n//se la provenienza contiene una virgola allora è per indicare provenienze multiple.\n//per ora non sono gestite quindi in caso svuoto i campi area-mob-room e uso solo il campo provenienza new\nlet prov_old_area=\"\";\nlet prov_old_mob=\"\";\nlet prov_old_room=\"\";\nif (provenienza_old.search(\",\")<0) {\n  const regexProv = /([^-\\(]+)?-?([^\\(]+)?\\(?(\\d+)?\\)?/;\n  const found = provenienza_old.match(regexProv);\n  prov_old_area = (found[1]||\"\").trim()\n  prov_old_mob = (found[2]||\"\").trim()\n  prov_old_room = (found[3]||\"\").trim()\n}\n\nwin.innerHTML = `\n<!--header-->\n  <div>${title}</div>\n<!--content-->\n<div id=\"win-${name}\" style=\"display:flex;flex-direction:column;justify-content:space-between;\">\n  <p>\n   <b>ID Oggetto: </b>${objID}<br>\n   <b>Oggetto: </b>${oggdb[util.db.fieldsPos.Oggetto]}<br>\n   <b>Attuale provenienza: </b>${provenienza_old}\n  </p>\n\n  <div style=\"display:grid;grid:30px 30px 30px / auto 50px auto;grid-gap:10px\">\n    <label id=\"lblarea\" style=\"align-self:center\"><b>Area:</b> ${util.getCurrentZonaLabel()}</label>\n    <button id=\"btnarea\">--&gt;</button>\n    <select id=\"area\" name=\"area\"></select>\n    <label id=\"lblmob\" style=\"align-self:center\"><b>Mob:</b> ${window.ultimoMobUcciso || \"\"}</label>\n    <button id=\"btnmob\">--&gt;</button>\n    <input id=\"mob\" type=\"text\" />\n    <label id=\"lblroom\" style=\"align-self:center\"><b>Room:</b> ${mapper?.current?.id || \"\"}</label>\n    <button id=\"btnroom\">--&gt;</button>\n    <input id=\"room\" type=\"text\" />    \n  </div> \n\n  <p>\n    <b>Nuova provenienza:</b><br>\n    <input id=\"newprovenienza\" type=\"text\" style=\"width:95%\" />\n  </p>\n  <button id=\"okbutton\" style=\"height:30px;font-size:2em\">Aggiorna provenienza</button>\n</div>\n`;\n\nlet zonelabels = mapper.db.zones.map(z=>z.label);\nzonelabels.sort();\nzonelabels.unshift(\"\");\n\n$('#area',win).empty();\n$.each(zonelabels, function(key, value) {\n  if (value!=undefined) {   \n    $('#area',win)\n      .append($('<option>', { value : key })\n      .text(value));\n  }\n});\n\nlet prov_old_area_index = zonelabels.indexOf(prov_old_area);\n//se l'area non corrisponde metto il primo elemento che è vuoto\nif (prov_old_area_index<0) prov_old_area_index = 0;\n$(\"#area>option:eq(\"+prov_old_area_index+\")\",win).prop(\"selected\",true);\n$('#mob',win).val(prov_old_mob);\n$('#room',win).val(prov_old_room);\n$(\"#newprovenienza\",win).val(provenienza_new);\nupdatebottone();\n\nconst wxWin = $(win).jqxWindow({width: 400, height: 350, resizable: true, showCollapseButton: true, autoOpen: false});\nwxWin.on(\"close\", () => {\n  $(win).jqxWindow('destroy')\n  $(win).remove()\n})\n\n$(win).jqxWindow(\"show\")\n$(win).jqxWindow(\"focus\")\n\n\nfunction updatenewprovenienza() {\n  const newarea = $(\"#area :selected\",win).text();\n  const newmob = $(\"#mob\",win).val();\n  const newroom = $(\"#room\",win).val();\n    \n  provenienza_new = $(\"#area :selected\",win).text();\n  if (newarea && newmob) provenienza_new += \" - \";\n  provenienza_new += newmob;\n  if (provenienza_new && newroom) provenienza_new += \" \";\n  if (newroom) provenienza_new += \"(\" + newroom + \")\";\n  \n  $(\"#newprovenienza\",win).val(provenienza_new);\n  updatebottone()\n}\n\nfunction updatebottone() {\n  provenienza_new = $(\"#newprovenienza\",win).val();\n  daAggiornare = !(provenienza_new==provenienza_old)\n  $(\"#okbutton\",win).text(daAggiornare?\"Aggiorna provenienza\":\"Annulla\")\n}\n\n$(\"#btnarea\",win).click(()=>{\n  let progarrayzone = zonelabels.indexOf(util.getCurrentZonaLabel());  \n  $(\"#area>option:eq(\"+progarrayzone+\")\",win).prop(\"selected\",true);\n  updatenewprovenienza();\n})\n$(\"#btnmob\",win).click(()=>{\n  $(\"#mob\",win).val(window.ultimoMobUcciso || \"\");\n  updatenewprovenienza();\n})\n$(\"#btnroom\",win).click(()=>{\n  $(\"#room\",win).val(mapper?.current?.id || \"\");\n  updatenewprovenienza();\n})\n$(\"#area\",win).on(\"keyup\", updatenewprovenienza);\n$(\"#area\",win).on(\"change\", updatenewprovenienza);\n$(\"#mob\",win).on(\"keyup\", updatenewprovenienza);\n$(\"#room\",win).on(\"keyup\", updatenewprovenienza);\n$(\"#newprovenienza\",win).on(\"keyup\", updatebottone);\n\n\n$(\"#okbutton\",win).click(()=>{\n  if (daAggiornare) {  \n    //2 possibili casi: \n    //1) Se l'oggetto è già nel db privato posso cambiare direttamente la provenienza\n    //2) Se l'oggetto è nel db pubblico devo fare una copia dell'oggetto \n    //con la nuova provenienza da mettere nel privato\n    if (String(oggdb[util.db.fieldsPos.ID]).slice(0,4)==\"Priv\") {    \n      oggdb[util.db.fieldsPos.Provenienza] = provenienza_new;\n      print(\"La provenienza dell'oggetto \\\"\" + oggdb[util.db.fieldsPos.Oggetto] + \"\\\" è stata cambiata\");\n      print(\"DA: \" + provenienza_old);\n      print(\"A: \" + provenienza_new);\n    } else {\n      let oggcopiato = JSON.parse(JSON.stringify(oggdb));\n      oggcopiato[util.db.fieldsPos.Provenienza] = provenienza_new;\n      print(\"La provenienza dell'oggetto \\\"\" + oggdb[util.db.fieldsPos.Oggetto] + \"\\\" è stata cambiata creando una copia nell'elenco privato\");\n      print(\"DA: \" + provenienza_old);\n      print(\"A: \" + provenienza_new);    \n      util.add(oggcopiato, true);\n    }  \n    util.save();\n  }\n  $(win).jqxWindow(\"close\")\n})\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^identexport( privato$| pubblico$|$)",
      "id": "",
      "value": "var util = window.dbIdentUtil;\nconst database = match[1].trim() || \"privato\";\n\nfunction downloadJsonToFile(json, filename) {\n    let jsonstr = JSON.stringify(json, null, 2);\n    downloadString(jsonstr, filename);\n}\n\nfunction downloadString(jsonstr, filename) {\n    let blob = new Blob([jsonstr], { type: \"octet/stream\" });\n    let url = window.URL.createObjectURL(blob);\n\n    let link = document.createElement(\"a\");\n    link.setAttribute(\"href\", url);\n    link.setAttribute(\"download\", filename);\n    link.style.visibility = \"hidden\";\n\n    document.body.appendChild(link);\n    link.click();\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(link);\n}\n\nfunction formattedDate(d = new Date) {\n    return [d.getDate(), d.getMonth()+1, d.getFullYear()].map(n => n < 10 ? `0${n}` : `${n}`).join('/');\n  }\n\nif (database == \"pubblico\") {\n  const saveobj = {dbinfo: util.db.dbinfo, fields:util.db.fields, data: util.db.ogglistPubl}\n  downloadJsonToFile(saveobj,\"identdbPubblico.json\");\n} else if (database == \"privato\") {\n  const privdbinfo = {\n    ver: util.db.dbinfo.ver,\n    data: formattedDate(),\n    msg: \"Exported from WebClient\" \n  }\n  const saveobj = {dbinfo: privdbinfo, fields:util.db.fields, data: util.db.ogglistPriv}\n  downloadJsonToFile(saveobj,\"identdbPrivato.json\");\n}\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^cani$",
      "id": "",
      "value": "const sogliaminima = 200;\n\nlet numclassi = 1;\nlet psimono = false;\nif (this.classi && this.classi.length) {\n  numclassi = this.classi.length || 1;\n  psimono = this.classi.includes(\"Ps\");\n}\n//print(numclassi);\n//print(\"\"+psimono);\nlet coeff=1;\nif ((numclassi == 1) && psimono) {\n  coeff = 0.5;\n} else if (numclassi ==1) {\n  coeff = 1\n} else {\n  coeff = 1.25\n}\n//print(coeff)\n\nlet deltaMana = Number(this.TSMaxMana) - Number(this.TSMana);\n//print(\"deltaMana:\" + deltaMana)\nlet caniAmount = Math.trunc(deltaMana*coeff);\n//print(\"caniAmount:\" + caniAmount)\nsend(\"canibalize \" + String(Math.min(caniAmount, this.TSHp-sogliaminima)));",
      "regex": true,
      "is_script": true,
      "class": "cani",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^cambiaarma(?: (.+)$|$)",
      "id": "",
      "value": "if (!match[1]) {\n  //no parametro => rotazione armi\n  if (this.rotazioneArmi) rotazioneArmi();\n  return;\n}\n//Passato paramento quindi monto l'arma prevista\n\nconst isUltimaArmaStandard = () => (\n  (this.ultimaArma==this.armaSlash) || \n  (this.ultimaArma==this.armaBlunt) || \n  (this.ultimaArma==this.armaPierce) || \n  (this.ultimaArma==this.armaExtra) || \n  (this.ultimaArma==this.arco))\n\nconst armaVoluta = match[1];\n\n//Se l'arma voluta non è definita oppure è già l'arma in uso esci.\n//Nel caso dell'arco carica la freccia\nif (!armaVoluta || this.ultimaArma == armaVoluta) {\n  if (this.freccia && this.ultimaArma == this.arco) {\n    send(`load ${this.freccia}`);\n  }\n  return;\n}\n\n\n//FASE 1: Prendo l'arma dalla borsa\nsend(`get ${armaVoluta} ${this.borsaArmi||this.borsa}`);\nif (armaVoluta == this.arco) send(`get faretra ${this.borsaArmi||this.borsa}`);\n\n//FASE 2: libero lo spazio in eq\nif (this.ultimaArma!=\"-no-\") {\n  //Nelle configurazioni con Arma la tolgo.\n  if (this.ultimaArma) {\n    send(`rem ${this.ultimaArma}`);\n  } else {\n    //Se ultimaArma non è definita tolgo tutte le armi standard\n    for (let a of [this.armaSlash, this.armaBlunt, this.armaPierce, this.armaExtra, this.arco]) {\n      if (a && a!=armaVoluta) send(`rem ${a}`);\n    }\n  }\n}\nlet newhold = this.ultimoHold;\nif (this.ultimoHold!=\"-no-\" && this.isMonk()) {\n  //Nella configurazione con Hold tolgo la hold\n  if (this.ultimoHold) {\n    send(`rem ${this.ultimoHold}`);\n  } else {\n    //Se ultimoHold non è definito tolgo l'hold standard\n    if (this.holdItem) send(`rem ${this.holdItem}`);\n  }\n  newhold=\"-no-\";\n} \n  \n//FASE 3: Impugno l'arma\nsend(`~wear ${armaVoluta}`);\n\nif (this.freccia && this.ultimaArma == this.arco) {\n  send(`get ${this.freccia} ${this.borsaArmi||this.borsa}`)\n  send(`load ${this.freccia}`)\n}\n\n\n//FASE 4: Metto l'oggetto tolto in borsa\nif (this.ultimaArma!=\"-no\") {\n  //Nelle configurazioni con Arma che ho tolto la metto in borsa\n  if (this.ultimaArma) {\n    //se ultimaArma è definita ed è tra quelle standard la mette in borsa altrimenti\n    //la lascia in inventario\n    if (isUltimaArmaStandard()) send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n    } else {\n      for (let a of [this.armaSlash, this.armaBlunt, this.armaPierce, this.armaExtra, this.arco]) {\n        if (a && a!=armaVoluta) send(`put ${a} ${this.borsaArmi||this.borsa}`);\n      }       \n    }\n  if (this.usiArco) {\n    send(`put faretra ${this.borsaArmi||this.borsa}`);\n    if (this.freccia) send(`put ${this.freccia} ${this.borsaArmi||this.borsa}`)\n  }\n}\nif (this.ultimoHold!=\"-no-\" && this.isMonk()) {\n  //Nella configurazione con Hold metto la hold in borsa\n  if (this.ultimoHold) {\n    //Se oggetto standard lo metto in borsa altrimenti lo lascio in inventario\n    if (this.ultimoHold==this.holdItem) send(`put ${this.ultimoHold} ${this.borsaArmi||this.borsa}`);\n  } else {\n    if (this.holdItem) send(`put ${this.holdItem} ${this.borsaArmi||this.borsa}`);\n  }\n} \n\nthis.usiSlash = false;\nthis.usiBlunt = false;\nthis.usiPierce = false;\nthis.usiExtra = false;\nthis.usiArco = false;\nthis.ultimaArma = armaVoluta;\nthis.ultimoHold = newhold;\n",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fire",
      "id": "",
      "value": "if (this.scoccato || this.scoccato === undefined) {\n\tsend(`~load faretra`)\n  this.scoccato = false\n}\nsend(`~fire ${$1}`)",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^ident$|^ident(Dev|) (.*)$",
      "id": "",
      "value": "var util = window.dbIdentUtil;\nconst isDev = (match[1] === \"Dev\")\nconst searchKey = (match[2] || \"\")\n\nif (searchKey==\"\") {\n  print(color(\"HELP COMANDI WEBCLIENT PER IDENT\",\"white\"));\n  print(color(\"\\n\" \n             +\"Sono disponibili 2 archivi di oggetti:\\n\"\n             +\"* uno pubblico non modificabile che viene scaricato dal server\\n\"\n             +\"* uno privato che può essere popolato dai giocatori\\n\"\n             +\"\\n\"\n             +\"Comandi per la gestione degli identify:\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"RICERCA: ident key1|key2|...|keyn\\n\",\"yellow\"));\n  print(color(\"Restituisce l'identify o l'elenco degli oggetti che hanno \"\n             +\"nel testo dell'identify tutte le parole indicate nelle chiavi.\\n\"\n             +\"Esempio: ident spada del sole|slayer\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"AGGIUNTA DI UN IDENTIFY:\",\"yellow\"));\n  print(color(\"Dopo l'identify di un oggetto compariranno alcune scritte per informare se \"\n             +\"l'oggetto è già nell'archivio oppure no.\\n\"\n             +\"In questo secondo caso cliccando su \\\"Click per aggiungerlo\\\" l'identify verrà aggiunto \"\n             +\"all'archivio privato e gli sarà assegnato un identificativo del tipo Priv#\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"AGGIUNTA/MODIFICA DELLA PROVENIENZA: setprovenienza ID \\\"testo libero\\\"\",\"yellow\"));\n  print(color(\"Ad ogni oggetto si possono aggiungere informazioni utili (normalmente la provenienza)\\n\"\n             +\"- ID e' l'identificativo dell'oggetto nell'archivio pubblico o privato\\n\"\n             +\"- testo libero, racchiuso tra virgolette e' il testo che si vuole aggiungere \"\n             +\"solitamente nella forma Area - Mob Locazione Altre info\\n\"\n             +\"Esempio: setprovenienza Priv5 \\\"Blackmouth - Alchimista teneborsa (10781)\\\"\",\"lightgray\")); \n  print(color(\"EXTRA: setprovenienza \\\"testo libero\\\"\",\"yellow\"));\n  print(color(\"setprovenienza senza indicare l'ID agisce sull'ultimo oggetto che e' stato aggiunto al database\\n\",\"lightgray\"));\n  print(color(\"EXTRA: setprovenienza\",\"yellow\"));\n  print(color(\"setprovenienza senza indicare nulla deve essere lanciato nella locazione dove si \"\n             +\"raccoglie l'oggetto appena dopo averlo preso.\\n\"\n             +\"Apre una piccola interfaccia per facilitare la compilazione della provenienza\\n\"\n             +\"\\n\",\"lightgray\")); \n  print(color(\"CANCELLAZIONE DI UN IDENTIFY: identdel Priv#\",\"yellow\"));\n  print(color(\"Rimuove dall'archivio privato l'oggetto con l'id indicato\\n\"\n             +\"Esempio: idendel Priv1\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"CANCELLAZIONE DELL'ARCHIVIO PRIVATO: identdel All\",\"yellow\"));\n  print(color(\"Svuota l'archivio privato. Tipicamente utile dopo una esportazione.\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"ESPORTAZIONE: identexport\",\"yellow\"));\n  print(color(\"Viene aperta una machera per salvare in locale sul proprio pc l'archivio privato.\\n\"\n             +\"\\n\",\"lightgray\"));   \n  print(color(\"IMPORTAZIONE: identimport\",\"yellow\"));\n  print(color(\"Viene aperta una maschera per scegliere dal proprio pc il file da utilizzare \"\n             +\"per popolare l'archivio privato\",\"lightgray\")); \n  return;\n}\n\n\nlet r;\nif (searchKey.search(/^\\d+$|^Priv\\d+/)==0) {\n  r = [util.findID(searchKey)];\n} else {\n  r = util.search(searchKey);\n}\n\nfunction buildIdentifyStr(ogg, dev) {\n  let out = (\"ID: \" + color(ogg[util.db.fieldsPos.ID],\"yellow\") + \"\\n\");\n  out += (ogg[util.db.fieldsPos.Identify] + \"\\n\");\n  out += (\"Provenienza: \" + ogg[util.db.fieldsPos.Provenienza] + \"\\n\");\n  \n  if (dev) {\n  \tout += \"Oggetto: \" + ogg[util.db.fieldsPos.Oggetto] + \"\\n\";\n  \tout += \"DescrizioneShort: \" + ogg[util.db.fieldsPos.DescrizioneShort] + \"\\n\";\n  \tout += \"DescrizioneLong: \" + ogg[util.db.fieldsPos.DescrizioneLong] + \"\\n\";    \n  \tout += \"Tipo: \" + ogg[util.db.fieldsPos.Tipo] + \"\\n\";\n  \tout += \"PosizioneIndossabile: \" + ogg[util.db.fieldsPos.PosizioneIndossabile] + \"\\n\";\n  \tout += \"Proprieta: \" + ogg[util.db.fieldsPos.Proprieta] + \"\\n\";\n  \tout += \"Peso: \" + ogg[util.db.fieldsPos.Peso] + \"\\n\";\n  \tout += \"Valore: \" + ogg[util.db.fieldsPos.Valore] + \"\\n\";\n  \tout += \"Rent: \" + ogg[util.db.fieldsPos.Rent] + \"\\n\";   \n  \tout += \"Rare: \" + ogg[util.db.fieldsPos.Rare] + \"\\n\";\n  \tout += \"NoRent: \" + ogg[util.db.fieldsPos.NoRent] + \"\\n\";\n  \tout += \"DannoArma: \" + ogg[util.db.fieldsPos.DannoArma] + \"\\n\";\n    out += \"Danno: \" + ogg[util.db.fieldsPos.Danno] + \"\\n\";\n  \tout += \"SP: \" + ogg[util.db.fieldsPos.SP] + \"\\n\";\n  \tout += \"HP: \" + ogg[util.db.fieldsPos.HP] + \"\\n\";\n  \tout += \"Mana: \" + ogg[util.db.fieldsPos.Mana] + \"\\n\";\n  \tout += \"Affect1Tipo: \" + ogg[util.db.fieldsPos.Affect1Tipo] + \"\\n\";\n  \tout += \"Affect1Valore: \" + ogg[util.db.fieldsPos.Affect1Valore] + \"\\n\";\n  \tout += \"Affect2Tipo: \" + ogg[util.db.fieldsPos.Affect2Tipo] + \"\\n\";\n  \tout += \"Affect2Valore: \" + ogg[util.db.fieldsPos.Affect2Valore] + \"\\n\";\n  \tout += \"Affect3Tipo: \" + ogg[util.db.fieldsPos.Affect3Tipo] + \"\\n\";\n  \tout += \"Affect3Valore: \" + ogg[util.db.fieldsPos.Affect3Valore] + \"\\n\";\n  \tout += \"Affect4Tipo: \" + ogg[util.db.fieldsPos.Affect4Tipo] + \"\\n\";\n  \tout += \"Affect4Valore: \" + ogg[util.db.fieldsPos.Affect4Valore] + \"\\n\";\n  \tout += \"Affect5Tipo: \" + ogg[util.db.fieldsPos.Affect5Tipo] + \"\\n\";\n  \tout += \"Affect5Valore: \" + ogg[util.db.fieldsPos.Affect5Valore] + \"\\n\";\n \n  }\n  out += \"\\n\";\n  return out;\n}\n\nconsole.log(r);\n\nif (r[0]==null) { //Nessun oggetto trovato => notifica\n  print(\"Nessun oggetto trovato con i criteri richiesti\");\n} else if (r.length == 1) { //1 solo oggetto trovato => mando direttamente a screen principale\n  print(buildIdentifyStr(r[0], isDev));\n} else { //Più oggetti trovati => Mando a window specifica\n  \n  pageContent(\"Identify\", (pageIndex, pageSize) => {\n    let total = 0\n    let data = r;\n    if (data && (total = data.length))\n    {\n      for (let i = pageIndex * pageSize; i < (pageIndex+1) * pageSize && i < total; i++) {\n        let line = link(color(data[i][util.db.fieldsPos.ID], !data[i][util.db.fieldsPos.Provenienza]?\"yellow\":\"lighgreen\", null, false, true) + color(\" \", \"lightgray\") + color(data[i][util.db.fieldsPos.Oggetto], !data[i][util.db.fieldsPos.Provenienza]?\"yellow\":\"lighgreen\", null, true), () => print(buildIdentifyStr(data[i], isDev)))\n        line += \"\\n \" + color(data[i][util.db.fieldsPos.DescrizioneShort], \"lightgray\")\n        print(line,\"Identify\")\n      }\n    } else {\n      print(color(\" Nessuno :(\",\"red\"), \"Ricerca locazioni\")\n    }\n    return total;\n  }, \"Oggetti trovati per: \"+color(searchKey,\"yellow\"), 0, 10, 450, 440)\n  \n}\n\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "rc",
      "id": "",
      "value": "if (this.healtype?.indexOf(\"C\")>-1) {\n\tsend(`cast remove-curse ${$1}`)\n} else {\n\tsend(`unstash scrigno-remove;get pergamena scrigno;stash scrigno;recite pergamena ${$1}`)\n}",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^help($| client full$| client$| blocco (.+)$)",
      "id": "",
      "value": "if (!match[1]) {\n  \tsend('~help');\n  \tsend(\"echo $c0015Per il help degli alias o trigger del client digita '$c1115help client$c0015', oppure '$c1115help client full$c0015'.\");  \n\treturn;\n}\n\nconst helptxt = `\nElenco comandi webclient\nredatto sulla base della versione 25\n\n\n-----COMBATTIMENTO-----\n\nKILL\n    kill | kill \\<target\\> \n      Corrisponde a \"kill\" o \"kill <target>\"\n\nSTOP\n    stop\n      Toglie l'autoassist e interrompe il combattimento\n\nASSIST\n    ass | ass <target>\n      Assiste il Tank o il <target> specificato\n\nRESCUE\n    rescue|r | rescue <target>|r <target>\n      Viene \"rescuato\" il tank o il <target> specificato\n\nTHROW\n    shuri\n      Prende l'oggetto da lancio dalla borsa\n    shuri <target>\n      Prende l'oggetto da lancio dalla borsa e chiama il <target>\n\nATTACK\n    attack\n      Attacca il primo mob della stanza con l'attacco predefinito dalla classe\n    attack <target>\n      Attacca il <target> specificato con l'attacco predefinito dalla classe\n\nARCO\n    fire <target>\n      carica l'arco e spara una freccia al <target>\n\nORDER FOLLOWERS\n    of <comando>\n      Corrisponde a \"order followers <comando>\"\n\n\n\n-----AUTOMATISMI-----\n\nAUTOASSIST\n  Assist automatico all'entrata in combat del gruppo\n    autoassist on|true\n      Abilita l'autoassit\n    autoassist off|false\n      Disabilita l'autoassit\n    autoassist|aa\n      Inverte l'attivazione dell'autoassist\n\nAUTOBASH\n  Bash o kick automatico quando in combat\n    autobash on|true\n      Abilita l'autobash\n    autobash off|false  \n      Disabilita l'autobash\n    autobash|ab\n      Inverte l'attivazione dell'autobash\n\nAUTOCLERIC\n  Cura e refresh automatici dei membri del gruppo sotto la soglia impostata [Routine: cura]\n    autocleric <num>\n      Abilita l'autocleric impostando la soglia specificata in <num>. Se <num> e' 0 disabilita      \n    autocleric|acl\n      Se abilitato, disabilita l'autoassist. Se disabilitato lo abilita con la soglia preimpostata del 70%\n\nAUTOGROUP\n  Gruppa automaticamente chi segue\n    autogroup on|true\n      Abilita l'autogroup\n    autogroup off|false\n      Disabilita l'autogroup\n    autogroup\n      Inverte l'attivazione dell'autogroup\n\nAUTOLOOT\n  Evocazione del famiglio per la raccolta automatica dei loot\n    autoloot on|true\n      Abilita l'autoloot\n    autoloot off|false\n      Disabilita l'autoloot\n    autoloot\n      Inverte l'attivazione dell'autoloot\n    \nAUTOFOLLOW\n  Inseguimento automatico del capogruppo quando entra nei portali, negli stagni o qualora dovesse tornare in rece\n    autofollow on|true\n      Abilita l'autofollow\n    autofollow off|false\n      Disabilita l'autofollow\n    autofollow\n      Inverte l'attivazione dell'autofollow\n    \nAUTOORDER\n  Permette di ricevere comandi dal capogruppo in group tell della forma <nomepg>:<comando>\n  Oppure all:<comando>\n    autoorder on|true\n      Abilita l'autoorder\n    autoorder off|false\n      Disabilita l'autoorder\n    autoorder\n      Inverte l'attivazione dell'autoorder\n\nSELFSHIELD \n  Abitlita l'autocast su se stessi dello scudo al suo scadere\n    selfshield on|true\n      Abilita il selfshield\n    selfshield off|false\n      Disabilita il selfshield\n    selfshield\n      Inverte l'attivazione del selfshield\n\nSELFSANC \n  Autocast su se stessi del sanc al suo scadere\n    selfsanc on|true\n      Abilita il selfsanc\n    selfsanc off|false\n      Disabilita il selfsanc\n    selfsanc\n      Inverte l'attivazione del selfsanc  \n\nAUTOSANC\n  Autocast del sanc sulla lista dei target impostata oppure Gard [routine: sancaAutosanc]\n    autosanc|asanc\n      Inverte la selezione dell'autosanc senza cancellare la lista dei target\n    autosanc|asanc off|false\n      Disabilita l'autosanc e svuota la lista.\n    autosanc|asanc <target>\n      Abilita l'autosanc e aggiunge il target alla lista\n\nAUTOSTAB E AUTOSLAM\n  Stab o slam automatici nell'entrata in combat\n    autostab|autoslam|as on|true\n      Abilita l'autostab o l'autoslam\n    autostab|autoslam|as off|false\n      Disabilita l'autostab o l'autoslam\n    autostab|autoslam|as \n      Inverte l'attivazione dell'autostab o dell'autoslam\n\nAUTOFURY\n  Fury automatico nell'entrata in combat\n    autofury|af on|true\n      Abilita l'autofury\n    autofury|af off|false\n      Disabilita l'autofury\n    autofury|af\n      Inverte l'attivazione dell'autofury  \n    \nAUTOCAST\n  Casta automaticamente durante il combat\n    autocast on|true\n      Abilita l'autocast\n    autocast off|false\n      Disabilita l'autocast\n    autocast|ac \n      Inverte l'attivazione dell'autocast   \n\n    casta\n      Casta il cast predefinito di attacco al mob in combat\n    casta <target>\n      Casta il cast predefinito di attacco al <target>\n\nAUTORESCUE\n  \"Rescua\" automaticamente\n    autoresccue on|true\n      Abilita l'autorescue\n    autoresccue off|false\n      Disabilita l'autorescue\n    autoresccue|ar\n      Inverte l'attivazione dell'autorescue   \n\nAUTOSTOP\n  Interrompe automaticamente il combattimento\n    autostop on|true\n      Abilita l'autostop\n    autostop off|false\n      Disabilita l'autostop\n    autostop \n      Inverte l'attivazione dell'autostop   \n\nAUTOARMI\n  Cambio automatico dell'arma se il client si accorge che l'arma impugnata non coplisce\n    autoarmi on|true\n      Abilita l'autoarmi\n    autoarmi off|false\n      Disabilita l'autoarmi\n    autoarmi \n      Inverte l'attivazione dell'autoarmi   \n\nANTISPALM\n  Cambio automatico degli scudi se il client si accorge di ricevere danni su uno scudo del mob\n    antispalm on|true\n      Abilita l'antispalm\n    antispalm off|false\n      Disabilita l'antispalm\n    antispalm \n      Inverte l'attivazione dell'antispalm   \n\nAUTOKILL\n  Kill automatico dei mob (per la lista dei mob su cui funziona l'autokill: variables autoKillMobs)\n    autokill on|true\n      Abilita l'autokill\n    autokill off|false\n      Disabilita l'autokill\n    autokill|ak\n      Inverte l'attivazione dell'autokill\n\nSTATUS\n    status\n      Comunica sul gruppo lo stato di abilitazione degli automatismi\n\nALLOFF\n    alloff\n      Spegne tutti gli automatismi\n\n\n\n-----CAST-----\n\nCURA\n    heal|h\n      Cura se stessi con il migliore cast a disposizione della classe, oppure con second wind\n    heal <target> | h <target>\n      Cura il <target> con il migliore cast a disposizione della classe\n\nASTRAL\n    astral\n      Trasferisce il pg e il gruppo in astral utilizzando il cast adeguato alla classe\n\nREMOVE CURSE\n    rc <target>\n      Casta remove curse sul target.\n      Per i non chierici prende la pergamena dallo scrigno e usa quella.\n\nPORTAL\n    portal <mob> | po <mob>\n      Corrispondente a \"cast 'portal' <mob>\" \n\nFIRESHIELD\n    fs\n      Casta fireshield o flame shroud in base alla classe\n\nDISPEL\n    dispe|dispel \n      Corrisponde a \"cast 'dispel magic' \"\n    dispe|dispel <target>\n      Corrisponde a \"cast 'dispel magic' <target> \"\n\nSILENCE\n    sil|sile|sila\n      Corrisponde a \"cast 'silence' \"\n    sil|sile|sila <target>\n      Corrisponde a \"cast 'silence' <target>\"\n\nSANC\n    sanc\n      Corrisponde a \"cast 'sanc'\" oppure \"cast 'natures prot' su se stessi \n    sanc <target>\n      Corrisponde a \"cast 'sanc'\" oppure \"cast 'natures prot' sul target specificato \n\nCHAIN\n    chain | chain <target>\n      Corrisponde a \"cast 'chain lightn'\" su se stessi o sul <target> specificato\n\nFLY\n    fly | fly <target>\n      Corrisponde a \"cast 'fly'\" su se stessi o sul <target> specificato\n\n    gfly\n      Corrisponde a \"cast 'group fly'\"\n\nTRUE SIGHT\n    ts | ts <target>\n      Corrisponde a \"cast 'true sig'\" su se stessi o sul <target> specificato\n\nWATCH\n    wat|watc|watch\n      Rimuove l'oggetto che fornisce true sight prima di usare l'abilita' watch\n\nREMOVE PARAL\n    rp <target>\n      Corrisponde a 'remove paralisis' sul <target> specificato\n\nSNARE\n    snare | snare <target>\n      Corrisponde a \"cast 'snare' \" sul mob in combattimento o sul <target> specificato\n\nREFRESH\n    refresh <target>\n      Se possibile casta 'second wind' sul <target> oppure comunica sul gruppo\n\nFOG\n    fog\n      Corrisponde a \"cast 'faerie-fog' \"\n\nCANIBALIZE\n    cani\n      cani senza parametri corrisponde al cani per recuperare tutto il mana ma restando con almeno 200hp\n\nCAST\n    cast '<spell>' | cast '<spell>' <target>\n      Sceglie cast, recall o mind in funzione della classe del pg\n\n\n-----MAPPER-----\n\nVAI\n    vai <destinazione>\n      Abilita l'autodirezioni per andare alla locazione <destinazione>.\n      <destinazione> puo' essere il numero di room oppure un descrittivo associato alla stanza.\n    vai\n      vai senza parametro va alla stanza successiva dell'elenco restituito dal comando cerca\n\n    room\n      Restituisce la stanza in cui ci si trova\n\n    cerca <criterio>\n      Restituisce le stanze e l'area il cui nome corriponde al <criterio> specificato\n\n    ricercaprecedente\n      Restituisce le stanze trovate dalla ricerca già effettuata\n\n    salta | salta <num_room>\n      Toglie dall'elenco delle stanze trovate dal comando cerca la prima stanza o la stanza specificata\n\n    roomedit\n      Modifca la room del mapper\n\n    tesoro|tesori\n      Mostra un elenco cliccabile dei tesori da raccogliere\n\nAPERTURA USCITE\n    dig <target>\n      Impugna l'oggetto per dig e cut giusto il tempo per scavare il <target>\n\n    cut <target>\n      Impugna l'oggetto per dig e cut giusto il tempo per tagliare il <target>\n\n    porte\n      Apre tutte le porte presenti nella stanza\n\nENTRATA VELOCE\n    es\n      Corrisponde a \"enter stagno\"\n    ep\n      Corrisponde a \"enter portale\"\n\n\n    \n-----CAMBIO EQ-----\n\nSCUDI\n    ia|immuacid\n      Indossa lo scudo acido\n    ic|immucold|immuice\n      Indossa lo scudo cold\n    ie|immuele\n      Indossa lo scudo elettrico\n    if|immufire\n      Indossa lo scudo fire\n\nARMI\n    blunt\n      Cambia l'arma e impugna l'arma blunt    \n    slash\n      Cambia l'arma e impugna l'arma slash    \n    pierce\n      Cambia l'arma e impugna l'arma pierce \n    extra\n      Cambia l'arma e impugla l'arma extra\n    arco\n      Cambia l'arma e impugna l'arco\n    wield\n      Senza parametro reimpugna l'ultima arma usata\n    hold\n      Senza parametro riprende l'ultimo oggetto usato\n\n-----ALTRO-----\n\nAFK\n  Nota: in AFK alcuni automatismi si comportano in modo diverso\n    afk on|true\n      Abilita lo stato di afk del personaggio e aggiorna il title\n    afk off|false\n      Disabilita lo stato di afk del personaggio e aggiorna il title\n    afk\n      Inverte lo stato di afk del personaggio e aggiorna il title.\n\nBORSA\n    gb <item>\n      Prende l'item dalla borsa\n    pb <item>\n      Metti l'item in borsa\n\nCOMUNICAZIONE\n    gui|guild|gt|ot|sh|hg|herog|shout|gos|goss|gossip|grida|say <messaggio>\n      Manda il messaggio sul canale richiesto\n    t|tell|suss|send|telep|mess <destinatario> <messaggio>\n      Manda il messaggio al destinatario scelto\n    gtTrigget <messaggio>\n      Manda il messaggio al gruppo anteponendo la scritta (trigger).\n      Usato per i messaggi mandati in automatico dagli script\n\n    manca\n      Comunica al gruppo chi non e' nella stanza\n\n    tick\n      Comunica quanto rimane alla scadenza dell'ora\n\n    sessione\n      Comunica al gruppo quanti divini e quanti xp sono stati fatti nella sessione di gioco      \n\nALIGN\n    align\n      Estra dallo score il valore dell'align e lo manda a schermo\n\nCASA\n    rece|casa\n      Ritorna a casa con il metodo concesso dalla classe.\n      Per chi non ha cast viene cercata una pergamenta di ritorno in uno scrigno tenuto in borsa\n\nTOUCH\n    touch\n      Inverte l'abilitazione del pannellino per il touchscreen\n\nORDINABORSA\n    ordinaborsa\n      Mette in ordine la borsa spostando tutti i cristalli e gemme nel loro contenitore\n\nMESTIERI\n    mining\n      Svolge la sequenza opportuna per poter minare\n\n    fishing\n      Svolge la sequenza opportuna per poter pescare\n\n    esca <target>\n      Imposta l'esca da utilizzare per la pesca a <target>\n\nDHETHOR\n    qr\n      Corrisponde a \"quest request\"\n    qc\n      Corrisponde a \"quest complete\"\n\nFIX\n    fixxa <pg>\n      Toglie gli oggetti e richiede il fix a <pg>\n\nIDENTIFICA IL PROPRIO EQ\n    identeq\n      Da eseguire da Gwiryn: identifica tutto il proprio eq e scarica il file con esso\n\nTOOL\n    tool\n      Senza parametri mostra l'elenco degli strumenti disponibili\n\n\n-----SPECIFICI DELLA CLASSE BARDO-----\n\nREVEAL\n    fog\n      Corrisponde a \"cast 'reveal'\"\n\nPOISON\n    poison\n      Casta 'poison' sull'arma e sull'oggetto tenuto\n\nAUTOINSPIRE\n  Mantiene automaticamente l'ispirazione del bardo al massimo livello\n    autoinspire on|true\n      Abilita l'autonspire\n    autoinspire off|false\n      Disabilita l'autonspire\n    autoinspire\n      Inverte lo stato di attivazione dell'autonspire\n\nPLAY\n  Mantiene automaticamente suonata la canzone attivata\n    autosong on|true\n      Abilita l'autsong\n    autosong off|false\n      Disabilita l'autsong\n    autosong\n      Inverte lo stato di attivazione dell'autsong\n\n    war\n      corrisponde a \"play song of war\"\n    life\n      corrisponde a \"play song of life\"\n    nat\n      corrisponde a \"play song of nature\"\n    dumb\n      corrisponde a \"play song of dumb\"\n    peace\n      corrisponde a \"play song of peace\"\n\n    play\n      risuona l'ultima song suonata\n    play <song>\n      suona la song scelta\n\nFOCUS\n    focus\n      Casta \"spirit-focus\" sul primo oggetto personale dell'equipaggiamento\n\nTALES\n    bash|gig|giga <target>\n      Effettua la tale sul <target>\n    ven|vend <target>\n      Effettua la tale sul <target>\n    spi|spir <target>\n      Effettua la tale sul <target>\n    ero|eroe <target>\n      Effettua la tale sul <target>\n    dra|drag <target>\n      Effettua la tale sul <target>\n    fug|fugg <target>\n      Effettua la tale sul <target>\n    idi|idio <target>\n      Effettua la tale sul <target>\n\nSLAM\n    slam\n      Effettua lo slam indossando se necessario prima lo strumento adeguato (e cambiando la song per l'autosong)\n\n\n\n-----SPECIFICI DELLA CLASSE DRUIDO-----\n\nBUFF\n    bark | bark <taget>\n      Corrisponde a \"cast 'barkskin'\" su se stessi o sul <target> specificato\n    \n    anim | anim <taget>\n      Corrisponde a \"cast 'animal aff'\" su se stessi o sul <target> specificato\n\n    do | do <taget>\n      Corrisponde a \"cast 'detect original'\" su se stessi o sul <target> specificato\n\n    hum|grow |  hum <taget>|grow <taget>\n      Corrisponde a \"cast 'humanoid grow'\" su se stessi o sul <target> specificato\n\n    bloom\n      Corrisponde a \"cast 'bloom'\"\n\nOFFENSIVE CAST\n    storm|sblinka\n      Corrisponde a \"cast 'firestorm'\"\n\n    heat | heat <target>\n      Corrisponde a \"cast 'heat st'\" sul mob target del combattimento o sul <target> specificato\n\n    flo | flo <target>\n      Corrisponde a \"cast 'floating l'\" sul mob target del combattimento o sul <target> specificato\n\n    enta | enta <target>\n      Corrisponde a \"cast 'entangle'\" sul mob target del combattimento o sul <target> specificato\n\nEVOCATI\n    terra\n      Corrisponde a \"cast 'earth se'\"\n    aria\n      Corrisponde a \"cast 'wind se'\"\n    acqua\n      Corrisponde a \"cast 'water se'\"\n    fuoco\n      Corrisponde a \"cast 'fire se'\"\n\nALTRO\n    portal|tran|transport\n      Apre un menu' di scelta per il portal o il transport via plant\n    portal|tran|transport <albero>\n      Effettua il portal o il tansport via plant per l'<albero> selezionato\n\n\n\n-----SPECIFICI DELLE CLASSI MAGO-----\n\nPOLYMORPH\n    pola <creatura>\n      Casta polymorph self nella creatura specificata\n\nOFFENSIVE CAST\n    storm|sblinka\n      Corrisponde a \"cast 'incendiary'\"\n\n\n\n-----SPECIFICI DELLA CLASSE STREGONE-----\n\nGESTIONE DEL LIBRO DEGLI INCANTESIMI\n    libro assegna\n      Legge il contenuto del tuo libro e lo usa come template per memmare\n    libro aggiorna\n      Simile ad assegna ma se fai cambiamenti aggiorni il libro voluto (template)\n    libro cancella\n      Cancella il libro voluto (template), e quindi automemorize non funziona piu\n\n    mem|memo <num> '<cast>'  \n      Si siede e studia <num> volte il <cast> indicato\n\n    forg|forge|forget '<cast>'\n      Dimentica il <cast>. Il libro voluto (template) non viene alterato\n\n    memma\n      Si siede e studia gli incantesimi necessari a ripopolare il libro voluto (template)\n\nAUTOMEM\n  Memorizzazione automatica all'avvicinarsi del tick per ripopolare il libro [routine: automemma, finememorize]\n    automem|automemo on|true\n      Abilita l'automem\n    automem|automemo off|false\n      Disabilita l'automem\n    automem|automemo \n      Inverte lo stato dell'automem\n\n\n-----SPECIFICI DELLA CLASSE LADRO-----\n\nPOISON\n    poison\n      Applica 'poison' sull'arma e sull'oggetto tenuto\n\nRESTAB\n    restab|rs\n      Flea, ritorna e stabba\n\n`\nlet helplist = helptxt.replaceAll('<','&lt;').replaceAll('>','&gt;').split(\"\\n\");\n\nif (match[1] == \" client full\") {\n  print(color(helplist.join(\"\\n\"),\"lightgray\").replaceAll(/-----(.+)-----/g,color(\"-----$1-----\",\"yellow\")))\n  return\n}\n\nlet sezioni=[]\n\nfor (let riga of helplist) {\n  if (riga.substr(0,5) == '-----') {\n    //Inizio sezione\n    let sezione = {};\n    sezione.nome = riga.substr(5,riga.length-10);\n    sezione.blocchi = [];\n    sezioni.push(sezione)\n    continue;\n  }\n  if (sezioni.length == 0) continue; //Scarta tutte le righe iniziali prima della prima sezione\n  if ((riga.trim()==\"\") || (riga.trim()==\"Uso:\")) continue; //Salta le righe vuote e quelle con la scritta Uso:\n\n  if (riga.substr(0,1)!=\" \") { //se la riga inizia con un comando allora è un blocco\n    let blocco = {};\n    blocco.nome = riga.trim();\n    blocco.comandi = [];\n    let sezionecorrente = sezioni[sezioni.length-1];\n    sezionecorrente.blocchi.push(blocco);\n  } else if ((riga.substr(0,2)==\"  \") && (riga.substr(2,1)!=\" \")) { //se la riga ha solo 2 spazi di indentazione è la descrizione del blocco\n    let sezionecorrente = sezioni[sezioni.length-1];\n    let bloccocorrente = sezionecorrente.blocchi[sezionecorrente.blocchi.length-1];\n    bloccocorrente.descrizione = riga.trim();\n  } else if ((riga.substr(0,4)==\"    \") && (riga.substr(4,1)!=\" \")) { //se la riga ha solo 4 spazi di indentazione è il nome di un comando\n    let comando = {};\n    let sezionecorrente = sezioni[sezioni.length-1];\n    let bloccocorrente = sezionecorrente.blocchi[sezionecorrente.blocchi.length-1];\n    comando.nome = riga.trim();\n    comando.descrizione = \"\";\n    bloccocorrente.comandi.push(comando);\n  } else if ((riga.substr(0,6)==\"      \") && (riga.substr(6,1)!=\" \")) { //se la riga ha solo 6 spazi di indentazione è la spiegazione del comando\n    let sezionecorrente = sezioni[sezioni.length-1];\n    let bloccocorrente = sezionecorrente.blocchi[sezionecorrente.blocchi.length-1];\n    let comandocorrente = bloccocorrente.comandi[bloccocorrente.comandi.length-1];\n    comandocorrente.descrizione += riga.trim();\n  }\n}\n\nif (match[1] == \" client\") {\n  //menu degli help del client\n  for (let sezione of sezioni) {\n    print(color(sezione.nome,\"yellow\"));\n    let blocconomi = [];\n    for (let blocco of sezione.blocchi) {\n      const strcomandi = blocco.comandi.map( (comando)=> {return (comando.nome)} ).join(\", \");\n      blocconomi.push( link(blocco.nome, ()=>{send('help blocco ' + sezione.nome + \"|\" + blocco.nome)}, strcomandi))\n    }\n    print(\"  \" + color(blocconomi.join(\", \"),\"lightgray\") + \"\\n\");\n  }\n} else if (match[1].substr(1,6) == \"blocco\") {\n  let ricerca_sezione = match[2].split(\"|\")[0] || \"\";\n  let ricerca_blocco = match[2].split(\"|\")[1] || \"\";\n  //print(\"Ricerca sezione:\" + ricerca_sezione);\n  //print(\"Ricerca blocco: ->\" + ricerca_blocco + \"<-\");\n  for (let sezione of sezioni) {\n    //print(sezione.nome);\n    if (sezione.nome != ricerca_sezione) continue;\n    for (let blocco of sezione.blocchi) {\n      if (blocco.nome.trim() != ricerca_blocco.trim()) continue;\n\t  //print(\"INNER: \" + blocco.nome);\n      print(color(ricerca_sezione + \" - \" + ricerca_blocco + \":\",\"yellow\") + \"\\n\");\n      if (blocco.descrizione) print(color(blocco.descrizione,\"lightgray\") + \"\\n\");\n      for (let comando of blocco.comandi) {\n      \tprint(color(comando.nome + \":\",\"yellow\"));\n        print(color(\"   \" + comando.descrizione,\"lightgray\") + \"\\n\");\n      }\n    }\n  }\n}\n",
      "regex": true,
      "is_script": true,
      "class": "help",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "relinkLab",
      "id": "",
      "value": "const rooms = mapper.getZoneRooms(157)\nconst current = mapper.current\nfor (const room of rooms) {\n\tif (room.name == \"Nel Labirinto\")\n    {\n      room.color = \"rgb(177,177,177)\"\n      room.exits = {}\n    }\n}\nmapper.prepare()\nif (current) {\n\tmapper.setRoomById(current.id)\n}",
      "regex": false,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "kirin",
      "id": "",
      "value": "ask ki aiuto\nask ki libera\nask ki foresta\nask ki imperatrice\nask ki pace\nask ki veleno\nask ki artefatti",
      "regex": false,
      "is_script": false,
      "class": "zone:135",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^clearlab",
      "id": "",
      "value": "//LAB\n//zone:157\n/*\n#ALIAS clearLab {\n\t#VAR arcieri {0};\n    #VAR paladini {0};\n    #VAR inquisitori {0};\n    #VAR arcangeli {0};\n    #VAR maghi {0};\n    #VAR scudieri {0};\n    #VAR lab_multi 0\n} */\nconst LAB_AREA_ID = 35; //157;\n\n\nlet lab = window.lab;\nif (lab == undefined) {\n  print(\"lanciare prima initlab\");\n  return;\n}\nlab.arcieri = 0;\nlab.paladini = 0;\nlab.inquisitori = 0;\nlab.arcangeli = 0;\nlab.maghi = 0;\nlab.scudieri = 0;\nlab.lab_multi = 0;\n\nsend(\"relinklab\")",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^initlab ?(\\d)?",
      "id": "",
      "value": "var lab = (window.lab = {});\nsend(\"clearlab\");\nsend(\"setlab \" + match[1] || \"\");\nif (isCapogruppo()) {\n\tprint(\"\\nSei capogruppo. Mapper messo in modalita' mappaggio.\\nVerra' disabilitato appena esci di zona.\")\n\tmapper.mapmode = true\n}",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^setlab ?(\\d)?",
      "id": "",
      "value": "//LAB\n//zone:157\n/* #ALIAS setlab {\n\t#IF (@lab_multi<%int( %1) or @lab_multi==0) {\n    \t#VAR lab_multi {%if( %1!=\"\", %int( %1), 1)};\n        #SH %ansi( high, green)Labirinto inizializzato x@lab_Multi, per cambiare moltiplicatore usa 'setlab numero' dove numero e' 1, 2 o 3. Per riavviarlo 'initlab'. Per status: 'statuslab'.\n    }\n}\n*/\nlet lab = window.lab;\nif (lab == undefined) {\n  print(\"lanciare prima initlab\");\n  return;\n}\nif ( (parseInt(lab.lab_multi)<parseInt(match[1])) || (lab.lab_multi == 0) ) {\n\tlab.lab_multi = match[1] || 1;\n\tprint(\"Labirinto inizializzato X\" + lab.lab_multi +\"\\nPer cambiarlo:  'setlab numero' dove numero e' 1, 2 o 3.\\nPer riavviarlo: 'initlab'.\\nPer status:     'statuslab'.\");\n}\n",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^statuslab$",
      "id": "",
      "value": "//LAB\n//zone:157\n/* #ALIAS statuslab {\ngt ~(trigger~) Al Lab x@lab_multi abbiamo ucciso:;\ngt $c0009Arcieri: @arcieri su %eval( 30*@lab_multi) $c0009~(%int( %eval( (%float( @arcieri)/(30*@lab_multi))*100))%~);\ngt $c0009Scudieri: @scudieri su %eval( 10*@lab_multi) $c0009~(%int( %eval( (%float( @scudieri)/(10*@lab_multi))*100))%~);\ngt $c0009Paladini: @paladini su %eval( 5*@lab_multi) $c0009~(%int( %eval( (%float( @paladini)/(5*@lab_multi))*100))%~);\ngt $c0009Inquisitori: @inquisitori su %eval( 8*@lab_multi) $c0009~(%int( %eval( (%float( @inquisitori)/(8*@lab_multi))*100))%~);\ngt $c0009Maghi: @maghi su %eval( 6*@lab_multi) $c0009~(%int( %eval( (%float( @maghi)/(6*@lab_multi))*100))%~);\ngt $c0009Arcangeli: @arcangeli su %eval( 7*@lab_multi) $c0009~(%int( %eval( (%float( @arcangeli)/(7*@lab_multi))*100))%~)}\n*/\nlet lab = window.lab;\nif (lab == undefined) {\n  print(\"lanciare prima initlab\");\n  return;\n}\nconst saycmd=\"gt\";\n\nlet percentuale = (num,tot) => {return (\"\"+parseInt(100*num/tot).toString().padStart(3,' ')+\"%\")}\nlet struccisioni = (mob,num,coeff) => {return (\n  \"\"+mob+\": \"+num.toString().padStart(3,' ')+\" su \"+(coeff*lab.lab_multi).toString().padStart(3,' ')+\" (\"+percentuale(num,coeff*lab.lab_multi)+\")\"\n  )} \n\nsend(saycmd+\" Al Lab X\" + lab.lab_multi + \" abbiamo ucciso:\");\nsend(saycmd+\" \"+struccisioni(\"Arcieri    \",lab.arcieri, 30));\nsend(saycmd+\" \"+struccisioni(\"Scudieri   \",lab.scudieri, 10));\nsend(saycmd+\" \"+struccisioni(\"Paladini   \",lab.paladini, 5));\nsend(saycmd+\" \"+struccisioni(\"Inquisitori\",lab.inquisitori, 8));\nsend(saycmd+\" \"+struccisioni(\"Maghi      \",lab.maghi, 6));\nsend(saycmd+\" \"+struccisioni(\"Arcangeli  \",lab.arcangeli, 7));\n",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "followorder",
      "id": "",
      "value": "const order = ($1).toString()\nconst ordiniVietati = [\"trai\",\"pr\",\"alle\",\"wit\",\"de\",\"prel\",\"grid\",\"sh\",\"ot\",\"gos\",\"sa\",\"par\",\"di\",\"set\",\"pwp\",\"rpg\",\"tit\",\"quit\"]\nif (ordiniVietati.find((e) => order.toLowerCase() == e || order.toLowerCase().startsWith(e + \" \"))) {\n  this.parlaStato = true\n  send(\"sayStatus Ordine vietato\")\n  this.parlaStato = this.afk\n  return\n}\nsend(order)",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "identeq",
      "id": "",
      "value": "toggleTrigger(\"fineidentifyeq\", true)\nNotification.Show(\"Inizio identify EQ\")\nsend(\"rem \"+oggettoTrueSight)\nif (healtype==\"C\"||healtype==\"D\"||canPlay) {\n  send(\"ts\")\n} else {\n  send(\"watch\")\n}\nsend(\"wear \"+oggettoTrueSight)\nfor(let i = 1; i<22; i++) {\n  send(\"rem \"+i+\";give ed\"+@TSPersonaggio+\" gwiryn;\"+(i==16?\"~wield\":\"wear\")+\" ed\"+@TSPersonaggio)\n}\noutputManager.outputWin.log=true\nsend(\"echo $c4011Fine identify EQ$c0007\")",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autosplit ?(.*)?",
      "id": "autosplit",
      "value": "this.autosplit = !this.autosplit;\n\nif (match && match[1] != undefined) {\n\tthis.autosplit = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autosplit\", this.autosplit);\nlet str = (\"AutoSplit: \"+ (this.autosplit ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fog",
      "id": "",
      "value": "send(\"sit;springleap\")",
      "regex": false,
      "is_script": true,
      "class": "monk",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "pugni",
      "id": "",
      "value": "const isUltimaArmaStandard = () => ((this.ultimaArma==this.armaSlash) || (this.ultimaArma==this.armaBlunt) || (this.ultimaArma==this.armaPierce) || (this.ultimaArma==this.arco) || (this.ultimaArma==this.armaExtra))\n\nif (this.ultimaArma!=\"-no-\") {\n  //Nelle configurazioni con Arma la tolgo.\n  if (this.ultimaArma) {\n    send(`rem ${this.ultimaArma}`);\n  } else {\n    if (this.armaSlash) send(`rem ${this.armaSlash}`);\n    if (this.armaBlunt) send(`rem ${this.armaBlunt}`);\n    if (this.armaPierce) send(`rem ${this.armaPierce}`);\n    if (this.armaExtra) send(`rem ${this.armaExtra}`);\n    if (this.arco) send(`rem ${this.arco}`);\n  }\n}\n\nlet newhold = this.ultimoHold;\nif (this.holdItem && this.isMonk()) {\n  send(`get ${this.holdItem} ${this.borsaArmi||this.borsa}`);\n  send(`~hold ${this.holdItem}`);\n  newhold = this.holdItem;\n}\n\nif (this.ultimaArma!=\"-no-\") {\n  //Nelle configurazioni con Arma che ho tolto la metto in borsa\n  if (this.ultimaArma) {\n    //se ultimaArma è definita ed è tra quelle standard la mette in borsa altrimenti\n    //la lascia in inventario\n    if (isUltimaArmaStandard())  send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n  } else {\n    if (this.armaSlash) send(`put ${this.armaSlash} ${this.borsaArmi||this.borsa}`);\n    if (this.armaBlunt) send(`put ${this.armaBlunt} ${this.borsaArmi||this.borsa}`);\n    if (this.armaPierce) send(`put ${this.armaPierce} ${this.borsaArmi||this.borsa}`);\n    if (this.armaExtra) send(`put ${this.armaExtra} ${this.borsaArmi||this.borsa}`);\n    if (this.arco) send(`put ${this.arco} ${this.borsaArmi||this.borsa}`);\n  }\n  if (this.usiArco) {\n    send(`put faretra ${this.borsaArmi||this.borsa}`);\n    if (this.freccia) send(`put ${this.freccia} ${this.borsaArmi||this.borsa}`)\n  }\n}\n\n\nthis.usiSlash = false;\nthis.usiBlunt = false;\nthis.usiPierce = false;\nthis.usiExtra = false;\nthis.usiArco = false;\nthis.ultimaArma = \"-no-\";\nthis.ultimoHold = newhold;",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "class": "scudi",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "cambiascudo",
      "regex": false,
      "value": "if (!this.ultimoScudo) {\n  send(\"ia\");\n  return;\n}\n\nif (this.ultimoScudo == this.scudoAcid) {\n  send(\"ie\");\n} else if (this.ultimoScudo == this.scudoEle) {\n  send(\"ic\");\n} else if (this.ultimoScudo == this.scudoCold) {\n  send(\"if\");\n} else if (this.ultimoScudo == this.scudoFire) {\n  send(\"ia\");\n}",
      "shortcut": "",
      "script": null
    },
    {
      "class": "disarm",
      "enabled": true,
      "id": "detrap",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^detrap$",
      "regex": true,
      "value": "if (this.roomTraps.length>0) {\n  const keytrap = this.roomTraps[0];\n  toggleTrigger(\"disarm-rigavuota\", false);\n  toggleTrigger(\"disarm-ko\", false);\n  toggleTrigger(\"disarm-click\", true);\n\n  /*if (this.pgInGruppo().length > 1) {\n    send(\"gtTrigger Attenzione c'e' una trappola! Provo a disarmarla.\");\n  }*/\n  send(\"disarm \" + keytrap);\n} else {\n  print(\"Nulla da disarmare\");\n}",
      "shortcut": "",
      "script": null
    },
    {
      "class": "util",
      "enabled": true,
      "id": "autodisarm",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^autodisa?r?m? ?(.*)?",
      "regex": true,
      "value": "const oldVal = this.autodisarm;\n\nthis.autodisarm = !this.autodisarm;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autodisarm = (match[1] == \"true\" || match[1] == \"on\");\n}\n\nif (oldVal != this.autodisarm) {\n  let str = (\"AutoDisarm: \"+ (this.autodisarm ? \"ABILITATO\" : \"DISABILITATO\"));\n  this.diciStatus(str);\n}\nif (this.autodisarm) send(\"autotraps on\");",
      "shortcut": "",
      "script": null
    },
	{
      "class": "util|staffe",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^(bastone|bacchetta)(?:\\s+(.+))?$",
      "regex": true,
      "value": "if (!$2) {\n  const staffe = getvar(\"staffe\")\n  let search = $1 + \" \" + getvar(\"staffa\")\n  let tipostaffa = $1\n  \n  if (search && staffe[0]) {\n    let i = staffe.findIndex(v => v.indexOf(search) == 0)\n    if (i == -1) {\n      search = $1\n      i = staffe.findIndex(v => v.indexOf(search) == 0)\n    }\n    let newI = -1;\n    if (i>-1) {\n      for (let x = i+1; x < staffe.length; x++) {\n        if (staffe[x].indexOf(tipostaffa) == 0) {\n          newI = x;\n          break;\n        }\n      }\n    }\n    if (newI >= staffe.length || newI < 0) {\n      for (let x = 0; x < i; x++) {\n        if (staffe[x].indexOf(tipostaffa) == 0) {\n          newI = x;\n          break;\n        }\n      }\n    }\n    if (newI > -1 && newI < staffe.length) {\n      send(staffe[newI])\n    }\n  }\n  return\n}\nsetvar(\"staffa\", $2)\n//setvar(\"tipostaffa\", $1)\nprint($1.toUpperCase() + \" da usare assegnata/o: \" + color($2, \"red\"))",
      "shortcut": "",
      "script": null
    },
    {
      "class": "util|staffe",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^(usastaffa|ub|us)( .+)?$",
      "regex": true,
      "value": "let listastaffe = getvar(\"listastaffe\")\nif (!listastaffe) {\n  print(\"Alias usastaffa/ub/us non ha una lista di bacchette o bastoni configurate. Usa alias 'staffe' per configurare quali staff o wand vuoi usare.\")\n  return;\n}\n\nconst staffe = new Map(listastaffe);\n\nsetvar(\"staffe\", [...staffe].map(kv => kv[1].tipo + \" \" + kv[0]))\n\nconst tipoStaffa = getvar(\"staffa\")\nif (!tipoStaffa) return;\nif (!staffe.has(tipoStaffa)) {\n  print(\"La staffa \" + tipoStaffa + \" non e' configurata\")\n  return;\n}\n\nconst datiStaffa = staffe.get(tipoStaffa)\nif (!datiStaffa) return;\n\nlet holdando = getvar(\"ultimoHold\") || getvar(\"holdItem\")\nconst target = ($2||\"\").trim()\n\nlet usa = (datiStaffa, target) => {\n  if (holdando) send(\"rem \"+holdando)\n  \n  send(`\n    ${datiStaffa.prendi} ${datiStaffa.key}\n    ~hold ${datiStaffa.key}\n    use ${datiStaffa.key} ${datiStaffa.tipo==\"bacchetta\"?target:\"\"}\n    rem ${datiStaffa.key}\n    ${datiStaffa.riponi} ${datiStaffa.key}\n  `)\n\n  if (holdando) send(\"~hold \"+holdando)\n}\n\nlet mobs = this.getMobs() ?? []\nlet gruppo = this.pgInGruppo()\nif (datiStaffa.tipo==\"bacchetta\" && !target) {\n  print(\"Seleziona il target:\")\n  print(\"MOBS:\")\n  for (let m of mobs) {\n    print(\" - \" + link(\"MOB: \" + m, () => usa(datiStaffa, m)))\n  }\n  print(\"PLAYERS:\")\n  for (let m of gruppo) {\n    print(\" - \" + link(\"PG: \" + (m==this.TSPersonaggio?\"TE STESSO\":m), () => usa(datiStaffa, m)))\n  }\n} else if (datiStaffa.tipo==\"bacchetta\") {\n  usa(datiStaffa, target)\n} else {\n  usa(datiStaffa, null)\n}",
      "shortcut": ""
    },
    {
      "class": "util|staffe",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "staffe",
      "regex": false,
      "value": "let listastaffe = getvar(\"listastaffe\") || [\n  /*[\"invis\", { key: \"bacchetta\", tipo: \"bacchetta\", prendi: \"gb\", riponi: \"pb\"}],\n  [\"sleep\", { key: \"scettro-magico\", tipo: \"bastone\", prendi: \"unstash\", riponi: \"stash\"}],\n  [\"heal\", { key: \"bacchetta-heal\", tipo: \"bacchetta\", prendi: \"gb\", riponi: \"pb\"}],\n  [\"shield\", { key: \"scettro-shield\", tipo: \"bastone\", prendi: \"unstash\", riponi: \"stash\"}],\n*/]\n\nlet askStaffa = async (staffa) => {\n  let nome = staffa[0]\n  let key = staffa[1].key\n  let bacchetta = staffa[1].tipo == \"bacchetta\" ? true : false\n  let stash = staffa[1].prendi == \"unstash\" ? true : false\n  let res = await Messagebox.ShowMultiInput((staffa[1].tipo + \" \" + staffa[0]).toUpperCase(), [\"Nome\",\"Key\",\"Bacchetta?\", \"Da stash\"], [nome, key, bacchetta, stash]) \n  if (res.button == 1) {\n    nome = res.results[0]\n    key = res.results[1]\n    bacchetta = res.results[2]\n    stash = res.results[3]\n    staffa[0] = nome\n    staffa[1].key = key\n    staffa[1].tipo = bacchetta ? \"bacchetta\" :\"bastone\"\n    staffa[1].prendi = stash ? \"unstash\" : \"gb\"\n    staffa[1].riponi = stash ? \"stash\" : \"pb\"\n    print(`${bacchetta ? \"Bacchetta\":\"Bastone\"} ${nome} con key: ${key} ${stash ? \"Da stash\":\"Da borsa\"}`)\n    return staffa\n  } else {\n    if (res.result) {\n      return null\n    } else {\n      return -1\n    }\n  }\n}\n\nlet printStaffe = () => {\n  print(\"Le tue staffe:\")\n  print(listastaffe.map(v => {\n    return color(v[0],\"white\") + \" : \" + v[1].tipo + \" con key: '\" + v[1].key + \"' \" + (v[1].prendi == \"unstash\" ? \"(da stash)\" : \"\")\n  }).join(\"\\n\"))\n}\nlet configuraStaffe = async () => {\n  if (listastaffe.length) {\n    await Messagebox.Show(\"Info\", \"Stai per modificare la lista delle staffe.\\nPremi Annulla per interrompere.\\nCancella il nome ad una per cancellarla.\")\n  }\n  for (let i = 0; i < listastaffe.length; i++) {\n    let lstItem = listastaffe[i]\n    let res = await askStaffa(clone(lstItem))\n    if (res == null) {\n      print(\"Ok, Interrompo.\")\n      return;\n    }\n    if (res == -1 || !res[0]) {\n      print(\"Cancello la staffa.\")\n      listastaffe.splice(i, 1)\n      i--;\n    } else {\n      listastaffe[i] = clone(res)\n    }\n  }\n  let newEl = null\n  let template = () => {\n    return [\"nuovo bastone\",{\"key\":\"\",\"tipo\":\"bastone\",\"prendi\":\"gb\",\"riponi\":\"pb\"}]\n  }\n  if ((await Messagebox.Question(\"Vuoi inserire nuove staffe?\\nPremi Annulla quando hai finito.\")).button==1) while ((newEl = await askStaffa(clone(template()))) && newEl != null && newEl != -1) {\n    if (newEl[0] && newEl[1].key) {\n      listastaffe.push(newEl)\n    } else if (!newEl[0] || !newEl[1].key) {\n      print(\"Errore: I campi Nome e Key sono necessari. Premi Annulla se vuoi interrompere.\")\n    } else {\n      break;\n    }\n  }\n  printStaffe()\n  setvar(\"listastaffe\", [...listastaffe])\n  delvar(\"staffa\")\n  delvar(\"staffe\")\n  setvar(\"staffa\", listastaffe.length ? [...listastaffe][0][0] : \"\")\n  setvar(\"staffe\", [...listastaffe].map(kv => kv[1].tipo + \" \" + kv[0]))\n  print(\"Ok ora puoi usare alias bacchetta, bastone e usastaffa\")\n}\nif (listastaffe.length) {\n  printStaffe()\n  print(link(\"MODIFICA\", configuraStaffe))\n} else {\n  print(\"Non hai staffe configurate.\")\n  print(link(\"CONFIGURA\", configuraStaffe))\n}\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "thief",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "poison",
      "regex": false,
      "value": "if (this.ultimaArma && this.ultimaArma!=\"-no-\") {\n  send(\"rem \" + this.ultimaArma);\n  send(\"~poison \" + this.ultimaArma);\n  send(\"wear \" + this.ultimaArma);\n}\n\n\nif (!this.ultimoHold) {\n  if (this.holdItem) this.ultimoHold = this.holdItem;\n}\n\nif (this.ultimoHold && this.ultimoHold!=\"-no-\") {\n  send(\"rem \" + this.ultimoHold);\n  send(\"~poison \" + this.ultimoHold);\n  send(\"wear \" + this.ultimoHold);\n}\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "initTrapOnline",
      "regex": false,
      "value": "//lista di trappole hardcodate qualora fallisse il fetch del file da server\n//corrispondono all'aggiornamento del 19.01.2024\nlet trappole = [\n  {\"long\": \"Una trappola giace qui.\", \"key\": \"trappola\"},\n  {\"long\": \"Un tronco appuntito giace qui nascosto nelle ombre.\", \"key\": \"tronco\"},\n  {\"long\": \"Una pozza d'acido si accumula qui.\", \"key\": \"pozza\"},\n  {\"long\": \"Una trappola giace pericolosamente al suolo.\", \"key\": \"trappola\"},\n  {\"long\": \"Una sfera magica di pura energia vola a mezz'aria.\", \"key\": \"sfera\"},\n  {\"long\": \"Delle macerie pericolanti sembrano sul punto di cadere.\", \"key\": \"macerie\"},\n  {\"long\": \"Per terra noti uno strano focolare.\", \"key\": \"focolare\"},\n  {\"long\": \"Noti alcune lame taglienti sul pavimento.\", \"key\": \"lame\"},\n  {\"long\": \"Fai attenzione alla trappola esplosiva per terra!\", \"key\": \"trappola\"},\n  {\"long\": \"Una trappola nascosta nell'ombra giace qui.\", \"key\": \"trappola\"},\n  {\"long\": \"Una trappola nascosta alla vista giace qui.\", \"key\": \"trappola\"},\n  {\"long\": \"Una trappola ben nascosta giace qui.\", \"key\": \"trappola\"},\n  {\"long\": \"Una mina esplosiva, creata dagli ingegneri Skaven per estrarre Warpietra dalle miniere, e' qui nascosta.\", \"key\": \"mina\"},\n  {\"long\": \"C'e' un pezzo di ragnatela...\", \"key\": \"ragnatela\"},\n  {\"long\": \"C'e' un enorme stalattite a pezzi sul pavimento.\", \"key\": \"stalattite\"},\n  {\"long\": \"La statua di un mago sembra stia per lanciare un incantesimo...\", \"key\": \"statua\"},\n  {\"long\": \"Per terra vedi una trappola con simboli demoniaci.\", \"key\": \"trappola\"},\n  {\"long\": \"Noti qualcosa di strano...\", \"key\": \"trap\"},\n  {\"long\": \"C'e' una trappola di fuoco per terra.\", \"key\": \"trappola\"},\n  {\"long\": \"Di fronte a te c'e' una statua raffigurante uno spadaccino umano.\", \"key\": \"statua\"},\n  {\"long\": \"A poca distanza da te vedi una corda tesa, collegata ad un piccolo masso.\", \"key\": \"corda\"},\n  {\"long\": \"Un fuoco brucia qui.\", \"key\": \"fuoco\"},\n  {\"long\": \"una bellissima conchiglia e' semi immersa nella sabbia.\", \"key\": \"conchiglia\"},\n  {\"long\": \"C'e' un lungo bastone appuntito qui!\", \"key\": \"bastone\"},\n  {\"long\": \"Uno strano congegno brilla di una luce verdastra. Grossi fili e complicati meccanismi si intrecciano intorno all'oggetto.\", \"key\": \"congegno\"},\n  {\"long\": \"Una trappola a tagliola e' nascosta nella polvere.\", \"key\": \"trappola\"},\n  {\"long\": \"Dei grossi cespugli di rovi spinosi ricoprono le rocce delle colline.\", \"key\": \"rovi\"},\n  {\"long\": \"Delle macerie pericolanti sembrano sul punto di cadere.\", \"key\": \"macerie\"},\n  {\"long\": \"Il corpo di un guerriero dei popoli liberi e' qui per terra.\", \"key\": \"trappola\"},\n  {\"long\": \"Un'enorme lama e' qui in terra.\", \"key\": \"lama\"},\n  {\"long\": \"Una ragnatela ti impedisce il passaggio...\", \"key\": \"ragnatela\"},\n  {\"long\": \"Un grosso lastrone di granito, piuttosto rovinato, giace a terra.\", \"key\": \"lastrone\"},\n  {\"long\": \"Una ragnatela ti impedisce il passaggio.\", \"key\": \"ragnatela\"},\n  {\"long\": \"Noti una trappola posizionata sul fondo del pozzo.\", \"key\": \"trappola\"},\n  {\"long\": \"noti dei filamenti oscuri avvolgere i cunicoli......\", \"key\": \"ragnatela\"},\n  {\"long\": \"Vedi una runa brillare debolmente sul muro.\", \"key\": \"runa\"},\n  {\"long\": \"Una trappola e' qui a terra...\", \"key\": \"trappola\"},\n  {\"long\": \"Vedi una strana pianta colorata a terra.\", \"key\": \"pianta\"},\n  {\"long\": \"C'e' uno strano oggetto a terra... ha numerose lame.\", \"key\": \"trappola\"},\n  {\"long\": \"Un occhio di pietra e' stato scolpito sull'entrata della caverna.\", \"key\": \"occhio\"},\n  {\"long\": \"Noti una liana tesa a terra.\", \"key\": \"liana\"},\n  {\"long\": \"Una piccola trappola quasi invisibile non sfugge al tuo occhio allenato.\", \"key\": \"trappola\"},\n  {\"long\": \"Vedi sul muro una runa brillare di una debole luce rossa.\", \"key\": \"runa\"},\n  {\"long\": \"una roccia spigolosa impedisce il passaggio.\", \"key\": \"roccia\"}  \n]\n\nsetvar(\"elencoTraps\", trappole, \"\", true)\nthis.initTraps();\nconsole.log(\"Caricate trappole da lista hardcodata\")\n\nlet prefix = \"\"\n  \nif (window.ipcRenderer) {\n  // binario prova a aggiornare dal live casomai abbia vecchio\n  prefix = \"https://www.temporasanguinis.it/client\"\n} else if (window.location.hostname.indexOf(\"temporasanguinis\")!=-1) {\n   // online sul web nella cartella client\n  prefix = \"/client\"\n} else {\n  // altri siti hostati in locale nel root\n  prefix = \"\"\n}\n\n\nfetch(prefix+\"/trappole.json?rng=\"+Math.random()).then(async r => {\n  try {\n    const onlineTraps = await r.json()\n    setvar(\"elencoTraps\", onlineTraps, \"\", true)\n    this.initTraps()\n    console.log(\"Caricate trappole da lista online\")\n  } catch {\n    console.log(\"Errore nel fetch di trappole.json\")\n  }\n})",
      "shortcut": "",
      "script": null
    },
    {
      "class": "tool",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^tool socket$",
      "regex": true,
      "value": "let name = \"Socket calculator\"\nlet win = document.createElement(\"div\");\nwin.style.display = \"none\";\nwin.className = \"win-\"+name.replace(\" \",\"-\") + \" socket-calculator\";\ndocument.body.appendChild(win);\n\nwin.innerHTML = `\n<!--header-->\n  <div>${name}</div>\n<!--content-->\n<div style=\"display: flex;\">\n   <style>\n        .socket-calculator label {\n          color: #666666;\n        }\n        \n        .socket-calculator .body {\n          background-color: #9FB39D;\n          padding: 10px;\n          margin: 3px;\n          flex: 1;\n        }\n        \n        .socket-calculator table {\n            border-collapse: collapse;\n            border-style: 5px solid black;\n            width: 30%;\n        }\n        .socket-calculator table td {\n            padding: 0.5rem;\n            border: 1px solid black;\n        }\n\n        .socket-calculator .rev {\n          font-style: italic;\n          text-align: right;\n        }\n\n        .socket-calculator h3.titolotabella {\n          padding-top: 0px;\n          margin-bottom: 5px;\n          margin-top: 5px;\n        }\n\n        .socket-calculator table.tebellacriteri {\n          border: 6px solid #24943A;\n          background-color: #D4EED1;\n          width: 90%;\n          text-align: left;\n          box-shadow: 5px 5px 15px 5px #000000;\n        }\n        .socket-calculator table.tebellaparametri {\n          border: 6px solid #5E5887;\n          background-color: #9D94B3 ;\n          width: 90%;\n          text-align: left;\n          box-shadow: 5px 5px 15px 5px #000000;\n        }\n        .socket-calculator table.tabellarisultato {\n          border: 6px solid #AD7457;\n          background-color: #FFAA80 ;\n          width: 100%;\n          text-align: left;\n          box-shadow: 5px 5px 15px 5px #000000;\n        }\n        .socket-calculator table.tebellacriteri td, .socket-calculator table.tebellacriteri th, .socket-calculator table.tabellaparametri td, .socket-calculator table.tabellaparametri th, .socket-calculator table.tabellarisultato td, .socket-calculator table.tabellarisultato th {\n          border: 1px solid #24943A;\n          padding: 5px 30px 5px 5px;\n        }\n\n        .socket-calculator .titlecells {\n        background: #AD7457;\n        font-size: large;\n        font-weight: bold;\n        }\n\n        .socket-calculator #btnCalcola {\n          box-shadow: 5px 5px 15px 5px #000000;\n          background:linear-gradient(to bottom, #77b55a 5%, #72b352 100%);\n          background-color:#77b55a;\n          border-radius:10px;\n          border:2px solid #4b8f29;\n          display:inline-block;\n          cursor:pointer;\n          color:#ffffff;\n          font-family:Arial;\n          font-size:18px;\n          font-weight:bold;\n          padding:10px 15px;\n          text-decoration:none;\n          text-shadow:0px 1px 0px #5b8a3c;\n          margin-top: 5px;\n          width:90%;\n        }\n        .socket-calculator #risultato .titolotabella {\n          display: none;\n        }\n        .socket-calculator #risultato {\n          margin-top: 25px;\n          text-align: center;\n        }\n    </style>\n  <div class=\"scrollable body\" id=\"win-${name.replace(\" \",\"-\")}\">\n  <form>\n    <div style=\"display:flex;flex-direction:row\">\n     <div style=\"flex:1\">\n      <h3 class=\"titolotabella\">Criteri di creazione:</h3>\n      <table class=\"tebellacriteri\">\n      <tbody>\n      <tr>\n      <td><label for=\"sk1\">Socket 0->1:</label></td> <td><select name=\"sk1\" id=\"sk1\"></select></td></tr>\n      <tr>\n      <td><label for=\"sk2\">Socket 1->2:</label></td> <td><select name=\"sk2\" id=\"sk2\"></td></tr>\n      <tr>\n      <td><label for=\"sk3\">Socket 2->3:</label></td> <td><select name=\"sk3\" id=\"sk3\"></td></tr>\n      <tr>\n      <td><label for=\"sk4\">Socket 3->4:</label></td> <td><select name=\"sk4\" id=\"sk4\"></td></tr>\n      <tr>\n      <td><label for=\"sk5\">Socket 4->5:</label></td> <td><select name=\"sk5\" id=\"sk5\"></td></tr>\n      </tbody>\n      </table>\n      <input id=\"btnCalcola\" type=\"button\" value=\"Calcola!\">\n     </div>\n     <div style=\"flex:1\">\n      <h3 class=\"titolotabella\">Parametri di calcolo:</h3>\n      <table class=\"tebellaparametri\">\n      <tbody>\n      <tr>\n      <td><label for=\"costoedit\">Costo edit:</label></td> <td><input type=\"text\" id=\"costoedit\" name=\"costoedit\"></td></tr>\n      <tr>\n      <td><label for=\"confidenza\">Confidenza:</label></td> <td><input type=\"text\" id=\"confidenza\" name=\"confidenza\"></td></tr>\n      <tr>\n      <td><label for=\"simulazioni\">Num simulazioni:</label></td> <td><input type=\"text\" id=\"simulazioni\" name=\"simulazioni\"></td></tr>\n      <tr>\n      <td><label for=\"maxlivello\">Max Livello:</label></td> <td><input type=\"text\" id=\"maxlivello\" name=\"maxlivello\"></td></tr>\n      </tbody>\n      </table>\n     </div>\n     </div>\n      \n    </form>\n    <div id=\"risultato\">\n      <h3 class=\"titolotabella\">Risultato del calcolo:</h3>\n    </div>\n  </div>\n</div>\n`;\n\nconst wxWin = $(win).jqxWindow({width: 650, height: 420, closeButtonSize: 16, resizable: false, showCollapseButton: false, autoOpen: false});\n\nwxWin.on(\"close\", () => {\n  $(win).jqxWindow('destroy')\n  $(win).remove()\n})\n\n$(win).jqxWindow(\"show\")\n\n //Inizializzazione dropdown boxes\nfor (let idxDropdown = 1; idxDropdown<=4; idxDropdown++) {\n  const dropdown = document.querySelector('.socket-calculator #sk' + idxDropdown);\n  dropdown.options[0] = new Option(\"Edit\", \"edit\");\n  dropdown.options[1] = new Option(\"Insert\", \"insert\");\n}\n  const dropdown5 = document.querySelector('.socket-calculator #sk5');\n  dropdown5.options[0] = new Option(\"Overedit\", \"overedit\");\n  dropdown5.options[1] = new Option(\"Insert\", \"insert\");\n\n//PRESET PARAMETRI\nlet SIMULAZIONI = 25000\nlet CONFIDENZA = 0.95\nlet MAXLIVELLO = 8\nlet COSTOEDIT = 400\nconst LIMITEPASSAGGI = 3000 //Se dopo questo limite non ho ancora creato l'oggetto mi fermo\ndocument.querySelector('.socket-calculator #sk1').value = \"insert\"\ndocument.querySelector('.socket-calculator #sk2').value = \"insert\"\ndocument.querySelector('.socket-calculator #sk3').value = \"edit\"\ndocument.querySelector('.socket-calculator #sk4').value = \"edit\"\ndocument.querySelector('.socket-calculator #sk5').value = \"insert\"\ndocument.querySelector('.socket-calculator #confidenza').value = CONFIDENZA;\ndocument.querySelector('.socket-calculator #simulazioni').value = SIMULAZIONI;\ndocument.querySelector('.socket-calculator #maxlivello').value = MAXLIVELLO;\ndocument.querySelector('.socket-calculator #costoedit').value = COSTOEDIT;\n\n\ndocument.querySelector('.socket-calculator #btnCalcola').addEventListener(\"click\", calcola);\n\nconst costoinsert = {\n  0: {'costo': 0,\n      'nextlivok': 1,\n      'nextlivko': 0,\n      'percok': 0.8},\n  1: {'costo': 100000,\n      'nextlivok': 2,\n      'nextlivko': 1,\n      'percok': 0.73},\n  2: {'costo': 200000,\n      'nextlivok': 3,\n      'nextlivko': 1,\n      'percok': 0.66},\n  3: {'costo': 300000,\n      'nextlivok': 4,\n      'nextlivko': 2,\n      'percok': 0.59},\n  4: {'costo': 400000,\n      'nextlivok': 5,\n      'nextlivko': 3,\n      'percok': 0.52},\n  5: {'costo': 500000,\n      'nextlivok': 6,\n      'nextlivko': 0,\n      'percok': 0.45},\n  6: {'costo': 1000000,\n      'nextlivok': 7,\n      'nextlivko': 0,\n      'percok': 0.38},\n  7: {'costo': 2000000,\n      'nextlivok': 8,\n      'nextlivko': 0,\n      'percok': 0.31},\n  8: {'costo': 3000000,\n      'nextlivok': 9,\n      'nextlivko': 0,\n      'percok': 0.24},\n  9: {'costo': 5000000,\n      'nextlivok': 10,\n      'nextlivko': 0,\n      'percok': 0.17}\n  }\n\n\n\n//Simula la creazione di un oggetto fino al livello goal. Restituisce l'oggetto e tutti i costi per generarlo con le logiche specificate nella pag web\nfunction creaoggetto(goal) {\n  let oggetto = {\n    'iterazioni': 0,\n    'liv': 0,\n    'costo': 0,\n    'numcristalli': 0,\n    'numedit': 0,\n    'numoveredit':0\n  }\n\n  for (let i=0; i<LIMITEPASSAGGI; i++) {\n    oggetto.iterazioni += 1;\n    const livoggetto = oggetto['liv'];\n\n    let tipo;\n    if (livoggetto <= 4) {\n      tipo = document.querySelector(\".socket-calculator #sk\" + (livoggetto+1).toString()).value;\n    } else {\n      tipo = \"insert\";\n    }\n\n    if (tipo == 'insert') {\n      const r = Math.random();\n      if ( r<=costoinsert[livoggetto]['percok'] ) {\n        // Insert ok\n        oggetto.liv = costoinsert[livoggetto]['nextlivok'];\n      } else {\n        // Insert fallito\n        oggetto.liv = costoinsert[livoggetto]['nextlivko'];\n      }\n      oggetto.costo += costoinsert[livoggetto]['costo'];\n      oggetto.numcristalli += 1;\n    } else if (tipo == 'edit') {\n      oggetto.liv += 1;\n      oggetto.numedit += 1;\n    } else if (tipo == 'overedit') {\n      oggetto.liv += 1;\n      oggetto.numoveredit += 1\n    }\n\n    if (oggetto.liv == goal) {\n      break\n    }\n  }\n  return(oggetto)\n}\n\n\n// Restituisce l'elenco di num SIMULAZIONI oggetti creati\nfunction calcolagoal(goal) {\n  let elenco = [];\n  for (let estrazione = 1; estrazione<=SIMULAZIONI; estrazione++ ) {\n    const oggetto = creaoggetto(goal)\n    elenco.push(oggetto)\n  }\n\n  return elenco;\n}\n\n\n// Data una lista di valori numerici restituisce il numero corrispondente al livello di confidenza impostato\nfunction getconfidenza(lista) {\n  function compareNumbers(a, b) {\n    return a - b;\n  }\n  lista.sort(compareNumbers);\n  return lista.slice(0, Math.floor(SIMULAZIONI*CONFIDENZA)).at(-1);\n}\n\n\nfunction calcola() {\n  // Pulisce eventuale tabella preesistente\n  const t = document.querySelector('.socket-calculator table.tabellarisultato')\n  if (t) {t.remove();}\n  \n  const msg = document.createElement('p');\n  msg.classList.add(\"messaggio\")\n  msg.appendChild(document.createTextNode(\"Calcolo in corso, attendere...\"))\n  const domRisultato = document.querySelector('.socket-calculator #risultato');\n  domRisultato.appendChild(msg);\n  \n  let calcolo = async () => {\n  CONFIDENZA = document.querySelector('.socket-calculator #confidenza').value;\n  SIMULAZIONI = document.querySelector('.socket-calculator #simulazioni').value;\n  MAXLIVELLO = document.querySelector('.socket-calculator #maxlivello').value;\n  COSTOEDIT = document.querySelector('.socket-calculator #costoedit').value;\n\n  const tbl = document.createElement('table');\n  tbl.classList.add(\"tabellarisultato\")\n\n  let tr,td\n  tr = tbl.insertRow();\n  tr.classList.add(\"titlecells\");\n  td = tr.insertCell(); td.appendChild(document.createTextNode(\"Livello\"));\n  td = tr.insertCell(); td.appendChild(document.createTextNode(\"Coin\"));\n  td = tr.insertCell(); td.appendChild(document.createTextNode(\"Cristalli\"));\n  td = tr.insertCell(); td.appendChild(document.createTextNode(\"Divini\"));  \n  td = tr.insertCell(); td.appendChild(document.createTextNode(\"Edit\"));\n  td = tr.insertCell(); td.appendChild(document.createTextNode(\"Overedit\"));\n\n  \n  for (let livello = 1; livello <= MAXLIVELLO; livello++) {\n    const elenco = calcolagoal(livello);\n    const conf_costo = getconfidenza(elenco.map(el => el.costo))\n    const conf_cristalli = getconfidenza(elenco.map(el => el.numcristalli))\n    const conf_edit = getconfidenza(elenco.map(el => el.numedit))\n    const conf_overedit = getconfidenza(elenco.map(el => el.numoveredit))\n\n    tr = tbl.insertRow();\n    td = tr.insertCell(); td.appendChild(document.createTextNode(livello));\n    td.classList.add(\"titlecells\");\n    td = tr.insertCell(); td.appendChild(document.createTextNode(\"\" + (conf_costo/1000000) + \"M\" ));\n    td = tr.insertCell(); td.appendChild(document.createTextNode(conf_cristalli));\n    td = tr.insertCell(); td.appendChild(document.createTextNode(conf_edit*COSTOEDIT + conf_overedit*COSTOEDIT*2));        \n    td = tr.insertCell(); td.appendChild(document.createTextNode(conf_edit));\n    td = tr.insertCell(); td.appendChild(document.createTextNode(conf_overedit));\n  }\n  \n  const remove = document.querySelector('.socket-calculator .messaggio')\n  if (remove) {remove.remove();}\n  \n  domRisultato.appendChild(tbl);\n  document.querySelector(\".socket-calculator #risultato .titolotabella\").style.display = \"block\";\n    let body = document.querySelector('.socket-calculator .body')\n    $(body).animate({ scrollTop: body.scrollHeight }, 1000)\n  };\n  setTimeout(calcolo, 100)\n}",
      "shortcut": ""
    },
    {
      "class": "tool",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^tool$",
      "regex": true,
      "value": "print(\"Elenco dei tool disponibili:\");\nprint(\"----------------------------\");\nprint(link(\"Simulatore costo socket\",()=>{send(\"tool socket\");},\"tool socket\"));\nprint(link(\"Calcolatore costo train\",()=>{send(\"tool costotrain\");},\"tool costotrain <num?> <num?>\"));\nprint(link(\"Gestione database identify\",()=>{send(\"tool ident\");},\"tool ident\"));\n",
      "shortcut": ""
    },
    {
      "class": "tool",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^tool costotrain ?(\\d+)? ?(\\d+)?",
      "regex": true,
      "value": "let tend = 0;\nlet tstart = 0;\n\nconst askNumTrain = async () => {\n  let colori = (this.colori instanceof Array) ? this.colori.join(\",\") : (this.colori || \"$c0009\");\n\n  const results = (await Messagebox.ShowMultiInput(\"Personale\",\n                   [\"Da che livello di train\",\"A che livello di train\"],\n                   [0,\"\"])).results;\n  tstart = Number(results[0]);\n  tend = Number(results[1]);\n  \n  return results\n};\n\n\nif (!match[1]) {\n  //aprire inputbox\n  await askNumTrain();\n} else {\n  if (!match[2]) {\n\t  tend = Number(match[1]);\n  \ttstart = 0;\n  } else {\n  \ttend = Number(match[2]);\n  \ttstart = Number(match[1]);\n  }\n}\n\nif (tend<=tstart) {\n  print(\"Il numero di train finale deve essere maggiore di quello iniziale\");\n  return;\n}\nconst costo_train = 400 * tend\nconst costo_cum = 400 * ( tend*(tend+1)/2 - tstart*(tstart+1)/2)\nprint(\"Il costo del train numero \" + tend + \" e' di \" + costo_train + \" divini\")\nprint(\"Il costo per andare dal train \" + tstart + \" al train \" + tend + \" e' di \" + costo_cum + \" divini\");\n\n\n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "tool",
      "enabled": true,
      "id": "tool ident",
      "is_prompt": false,
      "is_script": true,
      "pattern": "tool ident",
      "regex": false,
      "value": "var util = window.dbIdentUtil;\nif (!util || !util.db) {\n  print(\"DB Identify non configurato/abilitato\")\n  return\n}\n\nfunction formattedDate(d = new Date, sep = '/') {\n  return [d.getDate(), d.getMonth()+1, d.getFullYear()].map(n => n < 10 ? `0${n}` : `${n}`).join(sep||'/');\n}\n\nconst title = \"DB Identify tool\"; const name = title.replace(/ /g,\"-\");\n\nfunction cleanup() {\n  if ($(\".\"+\"win-\"+name).length==0) {\n    return\n  }\n  $(\"#selDb\").jqxDropDownList(\"destroy\")\n  $(\"#identToolMenu\").jqxMenu(\"destroy\")\n  $(\".\"+\"win-\"+name).jqxWindow('destroy')\n  $(\".\"+\"win-\"+name).remove()\n}\ncleanup();\n\nconst win = document.createElement(\"div\");\nwin.style.display = \"none\";\nwin.className = \"win-\"+name + \" customWindow\";\ndocument.body.appendChild(win);\n\nconst menu_labels = {\n mostraTutto: {txt:\"Tutto (_)\", val:0},\n mostraNoProv: {txt:\"Senza provenienza (_)\", val:0},\n mostraErrori: {txt:\"Errori (_)\", val:0},\n mostraErroriParsing: {txt:\"Errori parsing (_)\", val:0},\n mostraAvvertimenti: {txt:\"Avvertimenti (_)\", val:0},\n mostraErroriEAvvertimenti: {txt:\"Errori e avvertimenti (_)\", val:0},\n mostraDuplicati: {txt:\"Duplicati (_)\", val:0},\n mostraPrivati: {txt:\"Privati (_)\", val:0},\n mostraPersonali: {txt:\"Personali (_)\", val:0},\n}\n\nwin.innerHTML = `\n<!--header-->\n  <div>${title}</div>\n<!--content-->\n<div style=\"display:flex;box-sizing: border-box;\">\n  <div id=\"win-${name}\" style=\"box-sizing: border-box;padding: 5px !important;border: 2px solid transparent;flex:1;display:flex;box-sizing: border-box;position:absolute;left:0;right:0;top:0;bottom:0;\">\n    <div style=\"flex:1;display:flex;flex-direction:column\">\n     <div class=\"body\" style=\"flex:1;position:relative;\">\n      <div id=\"identDataTable\"></div>\n      <div style=\"flex:none;position:absolute;right:10px;top:2px;\">\n       </div>\n       <div style=\"flex:none;position:absolute;left:10px;bottom:2px;z-index: 1111;\">\n       <div id=\"selDb\" style=\"display:inline-block;\"></div>\n        <div id=\"identToolMenu\" style=\"display:inline-block;\">\n          <ul>\n            <li id=\"identMenuMostra\">Mostra\n              <ul>\n                <li id=\"mostraTutto\">Tutto</li>\n                <li id=\"mostraNoProv\">Senza provenienza</li>\n                <li id=\"mostraErrori\">Errori</li>\n                <li id=\"mostraErroriParsing\">Errori parsing</li>\n                <li id=\"mostraAvvertimenti\">Avvertimenti</li>\n                <li id=\"mostraErroriEAvvertimenti\">Errori e avvertimenti</li>\n                <li id=\"mostraDuplicati\">Duplicati</li>\n                <li id=\"mostraPrivati\">Privati</li>\n                <li id=\"mostraPersonali\">Personali</li>\n              </ul>\n            </li>\n            <li id=\"identMenuCorreggi\">Azioni\n              <ul>\n                <li id=\"correzioniLabel\" style=\"opacity:0.3;\">Correzioni:</li>\n                <li id=\"cancellaPrivati\">1. Cancella personali</li>\n                <li id=\"coreggiErrori\">2. Parsa campi da Identify</li>\n                <li id=\"coreggiDuplicati\">3. Correggi duplicati</li>\n                <li id=\"rinumera\">4. Rinumera ID privati</li>\n                <li type=\"separator\"></li>\n                <li id=\"selezioneLabel\" style=\"opacity:0.3;\">Selezione:</li>\n                <li id=\"selectVisible\">Seleziona filtrati</li>\n                <li id=\"selectAll\">Seleziona tutto</li>\n                <li id=\"selectNone\">Deseleziona tutto</li>\n                <li type=\"separator\"></li>\n                <li id=\"azioniLabel\" style=\"opacity:0.3;\">Azioni:</li>\n                <li id=\"parseSelected\">Riparsa ogg. sel.</li>\n                <li id=\"deleteSelected\">Cancella ogg. sel.</li>\n                <li id=\"duplicateSelected\">Duplica ogg. sel.</li>\n              </ul>\n            </li>\n            <li id=\"identMenuSalva\">Dati\n              <ul>\n                <li id=\"persistLabel\" style=\"opacity:0.3;\">Persistenza:</li>\n                <li id=\"saveCurrentDB\">Salva DB attuale</li>\n                <li id=\"saveAllDB\">Salva tutti i DB</li>\n                <li type=\"separator\"></li>\n                <li id=\"mergeLabel\" style=\"opacity:0.3;\">Merge:</li>\n                <li id=\"fondiPrivati\">Copia privato in pubblico</li>\n                <li id=\"cleanPrivati\" title=\"Elimina oggetti privati che non hanno provenienza se esistono con provenienza nel pubblico\">Pulisci priv. senza prov.</li>\n                <li type=\"separator\"></li>\n                <li id=\"fileLabel\" style=\"opacity:0.3;\">Da file:</li>\n                <li id=\"caricaJSON\">Importa da file JSON</li>\n                <li id=\"esportaIdentInJSON\">Esporta DB in JSON</li>\n              </ul>\n            </li>\n          </ul>\n        </div>\n       </div>\n     </div>\n    </div>\n  </div>\n</div>\n`;\n\nconst databases = [\"Database Pubblico\",\"Database Privato\"]\nconst dbState = {\n  current: null\n}\n\nfor (let d of databases) {\n  dbState[d] = {\n    lastValidation: new Map(),\n    modified: false,\n    dbData: null\n  }\n}\n\nfunction anyModifications() {\n  for (let d of databases) {\n    if (dbState[d].modified) return true\n  }\n  return false\n}\nfunction getDBData() {\n  return dbState[dbState.current].dbData\n}\nfunction setDBData(data) {\n  dbState[dbState.current].dbData = data\n}\nfunction getModified() {\n  return dbState[dbState.current].modified\n}\nfunction setModified(val, name) {\n  dbState[name||dbState.current].modified = val\n  setTitle()\n}\nfunction getValidation(name) {\n  return dbState[name||dbState.current].lastValidation || new Map()\n}\nfunction setValidation(validation, dbName) {\n  dbState[dbName||dbState.current].lastValidation = validation || new Map()\n}\n\nfunction setTitle() {\n  $(win).jqxWindow('setTitle', 'DB Identify Tool - '+dbState.current + (getModified()?\" MODIFICATO\":\"\") + \" (v\" + getDBData().dbinfo.ver + \" \" + getDBData().dbinfo.data + \" - \" + getDBData().dbinfo.msg + \")\");\n}\n\nasync function editDbInfo(title, dbinfo) {\n  dbinfo = JSON.parse(JSON.stringify(dbinfo))\n  let re = await Messagebox.ShowMultiInput(title, [\"Messaggio\", \"Data\", \"Versione\"], [dbinfo.msg, formattedDate(), dbinfo.ver])\n  if (re.button == 1) {\n    if (!re.results[2] || !Number.isInteger(Number(re.results[2])) || Number(re.results[2])<1) {\n      Notification.Warning(\"Cambio info scartato perche la versione non e' un numero intero maggiore a 0.\")\n    } else {\n      dbinfo.ver = re.results[2]\n      dbinfo.data = re.results[1]\n      dbinfo.msg = re.results[0]\n    }\n  }\n  return dbinfo;\n}\n\n\nasync function importPublicoObj(objparsed) {\n  dbPubblico.dbinfo = objparsed.dbinfo;  \n  dbPubblico.fields = objparsed.fields;\n  dbPubblico.data = objparsed.data;\n  setModified(true, databases[0]);\n  Notification.Show(databases[0] + \" importato in memoria. Devi salvare se vuoi persisterlo nel client.\")\n  gridUtil.setSource(dbUtil.loadDatabase(databases[0]))\n}\n\nasync function importPublico(text) {\n  let objparsed = JSON.parse(text);\n  await importPublicoObj(objparsed)\n}\n\nasync function importPrivato(text) {\n  let objparsed = JSON.parse(text);\n  dbPrivato.data = objparsed.data;\n  setModified(true, databases[1]);\n  Notification.Show(databases[1] + \" importato in memoria. Devi salvare se vuoi persisterlo nel client.\")\n  gridUtil.setSource(dbUtil.loadDatabase(databases[1]))\n}\n\n\nfunction importFromFile(callback) {\n    if (!callback) return;\n    let inp = document.createElement(\"input\");\n    inp.type = \"file\";\n    inp.style.visibility = \"hidden\";\n\n    inp.addEventListener(\"change\", (e) => {\n        let file = e.target.files[0];\n        if (!file) {\n            return;\n        }\n\n        let reader = new FileReader();\n        reader.onload = (e1) => {\n            let text = e1.target.result;\n            callback(text)\n        };\n        reader.readAsText(file);\n\n    });\n\n    document.body.appendChild(inp);\n    inp.click();\n    document.body.removeChild(inp);\n}\n\nasync function saveDB(name) {\n  name = name || dbState.current\n  let dbData = dbState[name].dbData\n  \n  let errors = [...getValidation(name).values()].filter(v => v.error).length\n  let warnings = [...getValidation(name).values()].filter(v => v.warning).length\n  if (errors > 0) {\n    let re = await Messagebox.Question(\"Ci sono \" + errors + \" errori in \" + name + \". Vuoi continuare?\")\n    if (re.button != 1) return\n  }\n  if (warnings > 0 && name == databases[0]) {\n    let re = await Messagebox.Question(\"Ci sono \" + warnings + \" avvertimenti in \" + name + \". Vuoi continuare?\")\n    if (re.button != 1) return\n  }\n\n  if (name==databases[0]) {\n    dbData.dbinfo = await editDbInfo(\"Salvataggio di \" + name, dbData.dbinfo)\n    util.db.dbinfo = dbData.dbinfo\n    util.db.ogglistPubl = dbData.data\n    util.save(true)\n  } else {\n    util.db.ogglistPriv = dbData.data\n    util.save(false)\n  }\n  setModified(false, name)\n  Notification.Show(name + \" salvato\")\n}\n\nlet rowsByID = new Map()\n\nconst wxWin = $(win).jqxWindow({minWidth: 730, width: 820, minHeight: 300, height: 550, resizable: true, showCollapseButton: true, autoOpen: false});\nconst menues = ['identMenuMostra','identMenuCorreggi','identMenuSalva']\n\nlet menu = $(\"#identToolMenu\",$(win)).jqxMenu({ mode:'horizontal', autoCloseOnClick: true, clickToOpen: true, autoSizeMainItems:false})\nmenu.jqxMenu('setItemOpenDirection', 'identMenuMostra', 'right', 'up');\nmenu.jqxMenu('setItemOpenDirection', 'identMenuCorreggi', 'right', 'up');\nmenu.jqxMenu('setItemOpenDirection', 'identMenuSalva', 'right', 'up');\nmenu.jqxMenu(\"disable\",\"correzioniLabel\",true)\nmenu.jqxMenu(\"disable\",\"azioniLabel\",true)\nmenu.jqxMenu(\"disable\",\"selezioneLabel\",true)\nmenu.jqxMenu(\"disable\",\"persistLabel\",true)\nmenu.jqxMenu(\"disable\",\"mergeLabel\",true)\nmenu.jqxMenu(\"disable\",\"fileLabel\",true)\n\nmenu.on('shown', (ev) => { \n  let id = ev.args.id\n  if (id != \"identMenuMostra\") return;\n  menu_labels.mostraTutto.val = getDBData() ? getDBData().data.length : 0;\n  $(\"li\", $(\"#mostraTutto\").parent()).each((i,e)=>{\n    let id = e.id\n    $(e).html(menu_labels[id].txt.replace(\"_\", \"<b>\" + menu_labels[id].val + \"</b>\"))\n  })\n}); \n\n$(win).on(\"close\", async () => {\n  if (anyModifications()) {\n    let re = await Messagebox.Question(\"Ci sono dati non salvati. Vuoi davvero uscire e perderli?\")\n    if (re.button != 1) {\n      $(win).jqxWindow(\"open\")\n      return\n    }\n  }\n  cleanup()\n})\n$(win).jqxWindow(\"show\")\n$(win).jqxWindow(\"focus\")\n\nconst dbPubblico = JSON.parse(JSON.stringify({dbinfo: util.db.dbinfo, fields:util.db.fields, data: util.db.ogglistPubl}))\nconst privdbinfo = {\n  ver: util.db.dbinfo.ver,\n  data: formattedDate(),\n  msg: \"attuale\" \n}\nconst dbPrivato = JSON.parse(JSON.stringify({dbinfo: privdbinfo, fields:util.db.fields, data: util.db.ogglistPriv}))\n\nconst fPos = (util.db.fieldsPos||[])\nconst source = {\n  localData: [],\n  dataType: \"array\",\n  dataFields: (util.db.fields||[]).sort(f => fPos[f]).map(f => {\n    return f.nome == \"ID\" ? {\n      \"name\":f.nome,\n      \"type\": \"int\"\n    } :\n    {\n      \"name\":f.nome,\n      \"type\":f.type==\"NUMBER\"?\"int\":f.type==\"BOOL\"?\"bool\":\"string\"\n    }\n  })\n};\n\nlet clearLabelValues = () => {\n  for (let ml of Object.keys(menu_labels)) {\n    menu_labels[ml].val = 0\n  }\n}\nconst gridUtil = {\n  updateRowField: (id, field, value) => {\n    let dbrow = rowsByID.get(id.toString())\n    let rowIndex = getDBData().data.indexOf(dbrow)\n    if (!dbrow || rowIndex<0) return;\n    let gridRow = source.localData[rowIndex]\n    gridRow[field] = value\n    dbrow[fPos[field]] = value\n    setModified(true)\n    if (field==\"Identify\") getDBData().data[rowIndex] = dbUtil.parseRow(getDBData(), dbrow)\n    let validations = dbUtil.validateDB(getDBData())\n    gridUtil.gridRowFromDbRow(gridRow, getDBData().data[rowIndex])\n    source.localData[rowIndex] = gridRow\n    gridUtil.applyValidations(source.localData, validations)\n    gridRow.DBROW = getDBData().data[rowIndex];\n    gridUtil.createRowVirtualColumns(getDBData(), gridRow)\n    $(\"#identDataTable\", $(win)).jqxDataTable('updateRow', rowIndex, gridRow);\n    return gridRow\n  },\n  gridRowFromDbRow: (gr, dbr) => {\n    for (let f of source.dataFields) {\n      gr[f.name] = dbr[parseInt(fPos[f.name])]\n    }\n    gr[\"DBROW\"] = dbr\n    rowsByID.set(gr.ID.toString(), dbr)\n  },\n  getData: (db) => {\n    rowsByID.clear()\n    source.localData = (db).data.map(v => {\n      let r = {};\n      gridUtil.gridRowFromDbRow(r, v)\n      return r\n    })\n    return source\n  },\n  createRowVirtualColumns: (db, r) => {\n      r[\"Personal\"] = dbUtil.isItemPrivato(r[\"DBROW\"])\n      r[\"Private\"] = (r.ID).toString().startsWith(\"Priv\")\n      r[\"ParseError\"] = (db.parseErrors||new Map()).has(r.ID)\n      r[\"Duplicate\"] = db.duplicati.includes(r.ID)\n  },\n  createVirtualColumns: (db, localData) => {\n    localData.map(r => {\n      gridUtil.createRowVirtualColumns(db, r)\n      return r\n    })\n    return localData\n  },\n  applyValidations: (rows, validation) => {\n    setValidation(validation)\n    for (let row of rows) {\n      let id = row.ID\n      row[\"Warning\"] = validation.get(id.toString())?.warning ? true : false;\n      row[\"Error\"] = validation.get(id.toString())?.error ? true : false;\n    }\n  },\n  getSelectedRows: () => {\n    var selection = $(\"#identDataTable\", $(win)).jqxDataTable('getSelection');\n    return selection\n  },\n  selectNone: () => {\n    var rows = $(\"#identDataTable\", $(win)).jqxDataTable('getRows');\n    let tbl = $(\"#identDataTable\", $(win))\n    for (var i = 0; i < rows.length; i++) {\n      tbl.jqxDataTable('_doSelection', rows[i].uid, false, false)\n    }\n    tbl.jqxDataTable('_renderrows')\n  },\n  selectAll: (visible) => {\n    var rows = visible ? $(\"#identDataTable\", $(win)).jqxDataTable('getView') : $(\"#identDataTable\", $(win)).jqxDataTable('getRows');\n    let tbl = $(\"#identDataTable\", $(win))\n    for (var i = 0; i < rows.length; i++) {\n      tbl.jqxDataTable('_doSelection', rows[i].uid, true, false)\n    }\n    tbl.jqxDataTable('_renderrows')\n    Notification.Show(rows.length + \" oggetti selezionati\")\n  },\n  setSource: (source) => {\n    clearLabelValues()\n    $(\"#identDataTable\", $(win)).jqxDataTable(\"source\",source) \n    menu_labels.mostraErroriEAvvertimenti.val = menu_labels.mostraAvvertimenti.val + menu_labels.mostraErrori.val\n  },\n  refreshRowDetails: (index) => {\n    let rows = $(\"#identDataTable\", $(win)).jqxDataTable('getRows')\n    let cnt = 0\n    for (let row of rows) {\n      if (row._refreshDetails && (cnt==index || !index)) row._refreshDetails()\n      cnt++;\n    }\n  }\n}\n\nvar dbUtil = {\n  getmaxid: (id1, id2) => {\n    const val1 = {};\n    val1.ispriv = (String(id1).substring(0,4)==\"Priv\")\n    val1.val = (val1.ispriv) ? Number(id1.substring(4)) : Number(id1);\n    const val2 = {};\n    val2.ispriv = (String(id2).substring(0,4)==\"Priv\")\n    val2.val = (val2.ispriv) ? Number(id2.substring(4)) : Number(id2);\n\n    if ( (val1.ispriv && val2.ispriv) || (!val1.ispriv && !val2.ispriv) ) {\n      //Omogenei\n      if (val2.val > val1.val) {\n        return {nuovo:id2, vecchio:id1};\n      } else {\n        return {nuovo:id1, vecchio:id2};\n      }\n    } else {\n      //Disomogenei\n      return (val1.ispriv) ? {nuovo:id1, vecchio:id2} : {nuovo:id2, vecchio:id1};\n    }\n  },\n  loadDatabase: (dbStr) => {\n    dbState.current = dbStr\n    $(\"#selDb\", $(win)).jqxDropDownList('selectIndex', databases.indexOf(dbStr) );\n    \n    setValidation(null)\n    \n    let db = (dbStr == databases[0] ? dbPubblico : dbPrivato);\n    setDBData(db)\n    setTitle()\n    \n    let source = gridUtil.getData(db)\n    let validation = dbUtil.validateDB(db)\n    gridUtil.createVirtualColumns(db, source.localData)\n    gridUtil.applyValidations(source.localData, validation)\n    const dataAdapter = new $.jqx.dataAdapter(source);\n    return dataAdapter;\n  },\n  isItemPrivato: (item) => {\n    return ( \n            //Non importo oggetti ed.+ personali\n            ( item[fPos[\"Identify\"]].search(/Su quest'oggetto sono stati spesi \\d+ Sigilli Divini/i) > -1 ) ||\n            ( item[fPos[\"Oggetto\"]].search(/^bande cuoio/) > -1 ) ||  //Non importo se key contiene bande cuoio\n            ( item[fPos[\"Oggetto\"]].search(/\\bvenditore\\S+ prezzo\\d+$/) > -1 )    //Non importo se key contiene venditore e prezzo(oggetto dall'asta)\n           ) \n  },\n  mergeAndFix: (db, dbIdent, validation, recordDaCancellare) => {\n    /*if (db.dbinfo.ver != dbIdent.dbinfo.ver) {\n            alert(\"Versioni database non corrispondenti. Merge non possibile\");\n            return;\n          }*/\n\n    dbUtil.dbSort(db);\n    dbUtil.dbFix(db); //Costruisce la versione parsando dall'ident\n\n    //Scarto gli elementi con parseerrors\n    let cntDataFixed = db.dataFixed.length\n    let cntDiff = 0\n    db.dataFixed = db.dataFixed.filter( el => !db.parseErrors.has(el[fPos[\"ID\"]]));  \n    \n    if ((cntDiff = (cntDataFixed - db.dataFixed.length))) {\n      Notification.Warning(cntDiff + \" oggetti invalidi/non parsabili scartati.\")\n    }\n    cntDataFixed = db.dataFixed.length\n    \n    //Scarto gli oggetti privati      \n    db.dataFixed = db.dataFixed.filter( el => !dbUtil.isItemPrivato(el) );  \n    \n    if ((cntDiff = (cntDataFixed - db.dataFixed.length))) {\n      Notification.Show(cntDiff + \" oggetti privati scartati.\")\n    }\n    \n    //Scarto gli oggetti che hanno l'ID già presente\n    let dbIdentMapID = new Map();\n    for (let item of dbIdent.data) {\n      dbIdentMapID.set(item[fPos[\"ID\"]],item);\n    }\n    /*for (let i = db.dataFixed.length - 1; i >= 0; i--) {\n      if ( dbIdentMapID.has(db.dataFixed[i][fPos[\"ID\"]]) ) { \n        db.dataFixed.splice(i,1);\n      }\n    } */\n    \n    //db.data = db.dataFixed; //Tiene la versione fixata\n    dbIdent.data = dbIdent.data.concat(db.dataFixed.filter(d => {\n      return !dbIdentMapID.has(d[fPos[\"ID\"]])\n    }).map(v => JSON.parse(JSON.stringify(v))));\n    dbUtil.dbSort(dbIdent);\n    dbUtil.searchduplicates(dbIdent, validation, false);\n    dbUtil.fixDuplicati(dbIdent, validation, recordDaCancellare);\n    databases.forEach(db => setModified(true, db))\n    return dbIdentMapID\n  },\n  fixDuplicati: (dbIdent, validation, mapProvenienzaCopiataSuVecchi) => {\n    setModified(true)\n    const getmaxdata = (strData1, strData2) => {\n      const d1 = (strData1 || \"01/01/1900\").split(\"/\")\n      const d2 = (strData2 || \"01/01/1900\").split(\"/\")\n\n      const data1 = new Date(d1[2], d1[1] -1, d1[0] );\n      const data2 = new Date(d2[2], d2[1] -1, d2[0] );\n      const maxdata = new Date(Math.max(data1,data2))\n      return ((strData1 == \"\") && (strData2 == \"\")) ? \"\" : formattedDate(maxdata);\n\n      function formattedDate(d = new Date) {\n        return [d.getDate(), d.getMonth()+1, d.getFullYear()].map(n => n < 10 ? `0${n}` : `${n}`).join('/');\n      }\n    }\n    //per ogni duplicazione nel set unito decido se posso scartare qualcosa\n    for (let itemduplicati of dbIdent.mapDuplicati.values()) {\n      for (let idx=1; idx<itemduplicati.length; idx++) {\n        //se il vecchio ha provenienza e il nuovo no duplico la provenienza\n        if ( (itemduplicati[0][fPos[\"Provenienza\"]] !== \"\") && (itemduplicati[idx][fPos[\"Provenienza\"]] == \"\") ) {\n          itemduplicati[idx][fPos[\"Provenienza\"]] = itemduplicati[0][fPos[\"Provenienza\"]];\n        }\n        //se il nuovo ha provenienza e il vecchio no duplico la provenienza\n        if ( (itemduplicati[idx][fPos[\"Provenienza\"]] !== \"\") && (itemduplicati[0][fPos[\"Provenienza\"]] == \"\") ) {\n          itemduplicati[0][fPos[\"Provenienza\"]] = itemduplicati[idx][fPos[\"Provenienza\"]];\n          mapProvenienzaCopiataSuVecchi.set(itemduplicati[idx][fPos[\"ID\"]].toString(), itemduplicati[idx])\n        }\n\n\n        //Se ident uguali e provenienza uguale metto ad entrambi la data più recente\n        if ( ( itemduplicati[0][fPos[\"Identify\"]] == itemduplicati[idx][fPos[\"Identify\"]] ) &&\n             ( itemduplicati[0][fPos[\"Provenienza\"]] == itemduplicati[idx][fPos[\"Provenienza\"]] ) ) {\n          //Cerco tra i 2 la data più recente\n          const datamax = getmaxdata(itemduplicati[0][fPos[\"Nota\"]], itemduplicati[idx][fPos[\"Nota\"]])\n          //Metto la data più recente ad entrambi\n          itemduplicati[0][fPos[\"Nota\"]] = datamax;\n          itemduplicati[idx][fPos[\"Nota\"]] = datamax;\n          mapProvenienzaCopiataSuVecchi.set(itemduplicati[idx][fPos[\"ID\"]].toString(), itemduplicati[idx])\n        }\n\n        const orderedid = dbUtil.getmaxid(itemduplicati[0][fPos[\"ID\"]], itemduplicati[idx][fPos[\"ID\"]]);\n        if ( itemduplicati[0][fPos[\"Identify\"]] !== itemduplicati[idx][fPos[\"Identify\"]] ) {\n          //se ident diversi tengo il più nuovo ed elimino il più vecchio\n          dbIdent.data = dbIdent.data.filter( el => el[fPos[\"ID\"]] !== orderedid.vecchio );\n        } \n\n        if ( ( itemduplicati[0][fPos[\"Identify\"]]    == itemduplicati[idx][fPos[\"Identify\"]] ) &&\n             ( itemduplicati[0][fPos[\"Provenienza\"]] == itemduplicati[idx][fPos[\"Provenienza\"]] ) ) {\n          //se ident uguali e provenienza uguale tengo il più vecchio ed elimino il più nuovo\n          dbIdent.data = dbIdent.data.filter( el => el[fPos[\"ID\"]] !== orderedid.nuovo );\n        }\n      }\n    }\n    dbIdent.dataFixed = dbIdent.data;\n    return dbUtil.searchduplicates(dbIdent, validation);\n  },\n  fixId: (dbIdent) => {\n    setModified(true)\n    //Cerca l'ID da usare (il più grande)\n    let maxID = 0;\n    for (let el of dbIdent.data) {\n      if ( Number.isInteger(el[fPos[\"ID\"]]) && (Number(el[fPos[\"ID\"]]) > maxID) ) {\n        maxID = el[fPos[\"ID\"]];\n      }\n    }\n    let newID = maxID+1;  \n\n    //A tutti quelli non interi (della forma Priv##) assegna il numero\n    for (let i in dbIdent.data) {\n      if (!Number.isInteger(dbIdent.data[i][fPos[\"ID\"]])) {\n        dbIdent.data[i][fPos[\"ID\"]] = newID;\n        //if (dbIdent.dataFixed) dbIdent.dataFixed[i][fPos[\"ID\"]] = newID;\n        newID++;\n      }\n    }\n  },\n  parseRow: (db, item) => {\n    const objFixed = dbUtil.parseident(item[fPos[\"Identify\"]]);\n    const fixedRow = [];\n    (db.fields||[]).sort(f => fPos[f.nome]).forEach(f => {\n      fixedRow.push(objFixed[f.nome])\n    })\n    fixedRow[fPos[\"Identify\"]] = item[fPos[\"Identify\"]]\n    fixedRow[fPos[\"Provenienza\"]] = item[fPos[\"Provenienza\"]]\n    fixedRow[fPos[\"ID\"]] = item[fPos[\"ID\"]]\n    fixedRow[fPos[\"Nota\"]] = item[fPos[\"Nota\"]]\n\n    if (objFixed.parseErrors.length > 0) {\n      if (!db.parseErrors) db.parseErrors = new Map()\n      db.parseErrors.set(item[fPos[\"ID\"]],objFixed.parseErrors);\n    }\n    return fixedRow\n  },\n  dbFix: (db) => {\n    setModified(true)\n    db.dataFixed = [];\n    db.parseErrors= new Map();\n    //row._refreshDetails\n    for (let item of db.data) {\n      let fixedRow = dbUtil.parseRow(db, item)\n      db.dataFixed.push(fixedRow);\n    }\n    gridUtil.refreshRowDetails()\n    db.data = db.dataFixed\n  },\n  dbSort: (db) => {\n    setModified(true)\n    //dbIdent.data.sort( (a,b) => Number(a[fPos[\"ID\"]]) - Number(b[fPos[\"ID\"]]) ); //Ordina per ID\n    db.data.sort( (a,b) => {\n      if (\n        [a[fPos[\"Oggetto\"]],a[fPos[\"DescrizioneShort\"]],a[fPos[\"DescrizioneLong\"]]].join(\"|\").toLowerCase() >= \n        [b[fPos[\"Oggetto\"]],b[fPos[\"DescrizioneShort\"]],b[fPos[\"DescrizioneLong\"]]].join(\"|\").toLowerCase() ) return 1;\n      return -1;\n    }); //Ordina per Nome oggetto\n  },\n  searchduplicates: (db, validation, confrontacolonne = true) => {\n    let mapItems = new Map();\n    let mapID = new Map();\n    let keyduplicate = [];\n    db.data.forEach( el => {\n      //Costruisco l'elemento univoco ogg|short|long\n      let ogg_short_long = [el[fPos[\"Oggetto\"]],el[fPos[\"DescrizioneShort\"]],el[fPos[\"DescrizioneLong\"]]].join(\"|\");\n      \n      let rId = el[fPos[\"ID\"]].toString()\n      mapID.set(rId, (mapID.get(rId)||0)+1)\n      \n      if ((mapID.get(rId)||0)>1) {\n        let val = validation.get(rId)||{warning:\"\",error:\"\"}\n        if (!val.error.includes(\"ID Duplicato\")) val.error = val.error + \"ID Duplicato\\n\"\n        validation.set(rId, val)\n      }\n\n      let mapvalue = mapItems.get(ogg_short_long);\n      if (mapvalue === undefined) {\n        // se non è in mappa lo aggiungo\n        mapItems.set(ogg_short_long,[el]);\n      } else {\n        // se è già in mappa aggiungo solo l'item alla stessa chiave\n        mapvalue.push(el); \n        keyduplicate.push(ogg_short_long); //e mi tengo traccia delle chiavi che hanno piu' di un elemento per filtare poi\n      }\n    });\n\n    //tengo solo i mapItems che hanno duplicati\n    db.mapDuplicati = new Map();\n    for ( let i of mapItems.keys()) {\n      let v = mapItems.get(i);\n      if (v.length >= 2) {\n        db.mapDuplicati.set(i, v);\n      } \n    }\n\n    db.duplicati = [];\n    db.duplicatiColonnaDiversa = new Map();\n    for (let numcolonna=0; numcolonna<db.fields.length; numcolonna++) {\n      db.duplicatiColonnaDiversa.set(numcolonna,[]);\n    }\n    //if (!confrontacolonne) return;\n\n    //Scorro solo quelli con duplicati\n    keyduplicate.forEach( (ogg_short_long) => { \n      let identUguali = true;\n      let provenienzaUguale = true;\n      let colonnaUguale=[]\n      for (let numcolonna=0; numcolonna<db.fields.length; numcolonna++) {\n        colonnaUguale.push(true);\n      }\n      //confronto gli ident\n      let items = mapItems.get(ogg_short_long);\n\n      for (let idx = 1; idx<items.length; idx++) {\n        for (let numcolonna=0; numcolonna<db.fields.length; numcolonna++) {\n          if (items[0][numcolonna] !== items[idx][numcolonna]) {\n            colonnaUguale[numcolonna] = false;\n          }\n        }      \n      }\n      items.map( el => el[fPos[\"ID\"]] ).forEach( id => {\n        db.duplicati.push(id)\n        let val = validation.get(id.toString())||{warning:\"\",error:\"\"}\n        if (!val.error.includes(\"Duplicato\")) val.error = val.error + \"Duplicato\\n\"\n        validation.set(id.toString(), val)\n      });\n      for (let numcolonna=0; numcolonna<db.fields.length; numcolonna++) {\n        if (!colonnaUguale[numcolonna]) {\n          items.map( el => el[fPos[\"ID\"]]).forEach( id => { \n            let tmp = db.duplicatiColonnaDiversa.get(numcolonna);\n            tmp.push(id);\n            let colName = source.dataFields[numcolonna].name\n            if (colName != \"ID\") {\n              let vobj = validation.get(id.toString())||{warning:\"\",error:\"\"}\n              vobj.warning += \"Colonna cambiata \" + numcolonna + \" (\" + colName + \")\\n\"\n              validation.set(id.toString(), vobj)\n            }\n          });  \n        }\n      }  \n    });\n    \n    return validation\n  },\n  parseident: (identText) => {\n    let obj={};\n    obj.parseErrors = [];\n    //console.log(identText);\n\n    try {\n      obj.Oggetto = identText.match(/^Oggetto '(.+?)' - Tipo: (.+)$/m)[1];\n      //se nel nome oggetto trova EDNome per oggetto personalizzato lo toglie\n      obj.Oggetto = obj.Oggetto.replace(/\\b(\\s?ED\\S+)/,'').trim();\n\n      obj.Tipo = identText.match(/^Oggetto '(.+?)' - Tipo: (.+)$/m)[2];\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in Oggetto+tipo\\n\" + err)\n      obj.Oggetto = \"\";\n      obj.Tipo = \"\";\n    }\n\n    try {\n      //Nelle DescrizioneShort e Long sostituisco eventualmente gli a-capo con uno spazio\n      //Negli ident ricevuto da webclient non viene ricevuto il /t sugli a-capo\n      //  quindi non c'e' bisogno di toglierlo\n      obj.DescrizioneShort = identText.match(/^Descrizione (?:corta|short): '(.+?)'$/ms)[1];\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in DescrizioneShort\\n\" + err)\n      obj.DescrizioneShort = \"\";\n    }\n\n    try {\n      obj.DescrizioneLong = identText.match(/^Descrizione (?:lunga|long): '(.*?)'$/ms)[1];\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in DescrizioneLong\\n\" + err)\n      obj.DescrizioneLong = \"\";\n    }\n\n    try {\n      obj.PosizioneIndossabile=\"\";\n      if (identText.search(/^Posizione indossabile: (.+)$/m)>-1) {\n        let posizioni = identText.match(/^Posizione indossabile: (.+)$/gm);\n        for (let posizione of posizioni) {\n          if (obj.PosizioneIndossabile.length>0) {obj.PosizioneIndossabile += \", \";}\n          obj.PosizioneIndossabile += posizione.match(/^Posizione indossabile: (.+)$/)[1]\n        }\n        obj.PosizioneIndossabile = obj.PosizioneIndossabile.trim();\n      }\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in PosizioneIndossabile\\n\" + err)\n      obj.PosizioneIndossabile = \"\";\n    }\n\n    try {\n      if (identText.search(/^L'oggetto non ha particolari caratteristiche\\.$/m)>-1) {\n          obj.Proprieta = \"\";\n      } else if (identText.search(/^L'oggetto e': (.+)$/m)>-1) {\n          obj.Proprieta = identText.match(/^L'oggetto e': (.+)$/m)[1].trim();\n      } else {\n          obj.Proprieta = \"\";\n      }\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in Proprieta\\n\" + err)\n      obj.Proprieta = \"\";\n    }\n\n    try {\n      obj.Peso =   Number(identText.match(/^Peso: (\\d+), Valore: (\\d+), Costo di (?:affitto|Rent): (\\d+)/m)[1]);\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in Peso\\n\" + err)\n      obj.Peso = 0;\n    }\n\n    try {\n      obj.Valore = Number(identText.match(/^Peso: (\\d+), Valore: (\\d+), Costo di (?:affitto|Rent): (\\d+)/m)[2]);\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in Valore\\n\" + err)\n      obj.Valore = 0;\n    }\n\n    try {\n      obj.Rent = Number(identText.match(/^Peso: (\\d+), Valore: (\\d+), Costo di (?:affitto|Rent): (\\d+)/m)[3]);\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in Rent\\n\" + err)\n      obj.Rent = 0;\n    }\n\n    try {\n      obj.Rare = ( (identText.search(/^Peso: (\\d+), Valore: (\\d+), Costo di (?:affitto|Rent): (\\d+) \\[(?:RARO|RARE)\\]/m)>-1) || (obj.Proprieta.search(\"RARE\")>-1) );\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in Rare\\n\" + err)\n      obj.Rare = false;\n    }\n    try {\n      obj.NoRent = identText.search(/^Peso: (\\d+), Valore: (\\d+), Costo di (?:affitto|Rent): (\\d+) (?:\\[NON-RENTABILE\\]|\\[NORENT\\]|NORENT)/m)>-1\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in NoRent\\n\" + err)\n      obj.NoRent = false;\n    }\n\n    obj.Identify = identText;\n    obj.Provenienza = \"\";\n    obj.Nota = \"\";\n\n    try {\n      //Sezione Affects\n      for (let i=1; i<=5; i++) {\n        obj[\"Affect\" + i + \"Tipo\"] = \"\";\n        obj[\"Affect\" + i + \"Valore\"] = \"\";\n      }\n\n      obj.Danno = 0;\n      obj.SP = 0;\n      obj.HP = 0;\n      obj.Mana = 0;\n      let abilspec = identText.search(/^Abilita' speciali:$/m);\n      if (abilspec > -1) {\n        let affects = identText.substring(abilspec).match(/^\\s*(Affects:|Aumenta|Diminuisce|Riduce|Abilita|Conferisce) (.+)$/gm);\n        for (let idxaffect in affects) {\n          let idx = Number(idxaffect)+1;\n          let affectparts = affects[idxaffect].match(/^\\s*(Affects:|Aumenta|Diminuisce|Riduce|Abilita|Conferisce) (.+) (by|di) (.+)$/)\n          if (!affectparts && affects[idxaffect].match(/Conferisce (PERK|BENEFICIO)/)) {\n            affectparts = affects[idxaffect].match(/^\\s*(Affects:|Aumenta|Diminuisce|Riduce|Abilita|Conferisce) ([A-Z -_]+) ?(by|di)? (.+)$/);\n          }\n          //let affectparts = affects[idxaffect].match(/^\\s*(Affects:|Aumenta|Diminuisce|Riduce|Abilita|Conferisce) (.+) (by|di) (.+)$/);\n          //let affectparts = affects[idxaffect].match(/^\\s*(Affects:|Aumenta|Diminuisce|Riduce|Abilita|Conferisce) ([A-Z -_]+) ?(by|di)? (.+)$/);\n          obj[\"Affect\" + idx + \"Tipo\"] = (String(affectparts[2]).trim());\n          if (affectparts[1].search(/Diminuisce|Riduce/)>-1) {\n            obj[\"Affect\" + idx + \"Valore\"] = \"-\" + String(affectparts[4]).trim();\n          } else {\n            obj[\"Affect\" + idx + \"Valore\"] = (String(affectparts[4]).trim());\n          }\n          if (obj[\"Affect\" + idx + \"Tipo\"] == \"DAMROLL\")     {obj.Danno += Number(obj[\"Affect\" + idx + \"Valore\"]);}\n          if (obj[\"Affect\" + idx + \"Tipo\"] == \"HIT&DAM\")     {obj.Danno += Number(obj[\"Affect\" + idx + \"Valore\"]);}\n          if (obj[\"Affect\" + idx + \"Tipo\"] == \"HIT-N-DAM\")   {obj.Danno += Number(obj[\"Affect\" + idx + \"Valore\"]);}\n          if (obj[\"Affect\" + idx + \"Tipo\"] == \"MANA\")        {obj.Mana += Number(obj[\"Affect\" + idx + \"Valore\"]);}\n          if (obj[\"Affect\" + idx + \"Tipo\"] == \"HIT\")         {obj.HP += Number(obj[\"Affect\" + idx + \"Valore\"]);}\n          if (obj[\"Affect\" + idx + \"Tipo\"] == \"SPELL-POWER\") {obj.SP += Number(obj[\"Affect\" + idx + \"Valore\"]);}\n          if (obj[\"Affect\" + idx + \"Tipo\"] == \"SPELLFAIL\")   {obj.SF += Number(obj[\"Affect\" + idx + \"Valore\"]);}\n        }\n        let affCol = \"\"\n        for (let i=1; i<=5; i++) {\n          if (obj[\"Affect\" + i + \"Tipo\"]) {\n            let affline = obj[\"Affect\" + i + \"Tipo\"] + \" : \" + obj[\"Affect\" + i + \"Valore\"];\n            affCol += affline + \"\\n\"\n          }\n        }\n        obj.Affects = affCol\n      }\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in Affects\\n\" + err)\n      for (let i=1; i<=5; i++) {\n        obj[\"Affect\" + i + \"Tipo\"] = \"\";\n        obj[\"Affect\" + i + \"Valore\"] = \"\";\n      }\n      console.log(err)\n    }\n\n    try {\n      let danno = identText.match(/^Danno: .+ (\\d+)d(\\d+), in condizioni ottimali d(\\d+)$/m);\n      if (danno != null) {\n        obj.DannoArma = Number(danno[1] * danno[3]);\n      } else {\n        obj.DannoArma = 0;\n      }\n\n    }\n    catch(err) {\n      obj.parseErrors.push(\"Parse error in DannoArma\\n\" + err)\n      obj.DannoArma = 0;\n    }\n    return obj;\n  },\n  validateDB: (db) => {\n    const validation = new Map();\n    db.parseErrors = new Map()\n    db.duplicati = []\n    dbUtil.searchduplicates(db, validation, true)\n    let index = 0\n    for (let v of db.data) {\n      let id = (v[parseInt(fPos[\"ID\"])]).toString()\n      if (id.includes(\"_\")) {\n        let valObj = null\n        if (validation.get(id)) {\n          valObj = validation.get(id)\n        } else {\n          valObj = { error: \"\", warning: \"\"}\n          validation.set(id, valObj)\n        }\n        if (dbState.current != databases[0]) {\n          valObj.warning = (valObj.warning||\"\") + \"Oggetto con ID non valido\\n\"\n        } else {\n          valObj.error = (valObj.error||\"\") + \"Oggetto con ID non valido\\n\"\n        }\n      }\n      if (id.startsWith(\"Priv\") && dbState.current == databases[0]) {\n        let valObj = null\n        if (validation.get(id)) {\n          valObj = validation.get(id)\n        } else {\n          valObj = { error: \"\", warning: \"\"}\n          validation.set(id, valObj)\n        }\n        valObj.error = (valObj.error||\"\") + \"Oggetto Privato in Database pubblico\\n\"\n      }\n      if ((v[parseInt(fPos[\"Provenienza\"])]).toString().trim()==\"\" && dbState.current != databases[0]) {\n        let valObj = null\n        if (validation.get(id)) {\n          valObj = validation.get(id)\n        } else {\n          valObj = { error:\"\", warning: \"\"}\n          validation.set(id, valObj)\n        }\n        valObj.warning = (valObj.warning||\"\") + \"Oggetto senza provenienza in Database privato\\n\"\n      }\n      if (dbState.current == databases[0] && dbUtil.isItemPrivato(v)) {\n        let valObj = null\n        if (validation.get(id)) {\n          valObj = validation.get(id)\n        } else {\n          valObj = { error:\"\", warning: \"\"}\n          validation.set(id, valObj)\n        }\n        valObj.warning = (valObj.warning||\"\") + \"Oggetto Personale in Database pubblico\\n\"\n      }\n      let o = dbUtil.parseident(v[parseInt(fPos[\"Identify\"])])\n \n      if (o.parseErrors.length) {\n        if (!db.parseErrors) db.parseErrors = new Map()\n        db.parseErrors.set(v[parseInt(fPos[\"ID\"])], o.parseErrors)\n\n        let valObj = null\n        if (validation.get(id)) {\n          valObj = validation.get(id)\n        } else {\n          valObj = { warning: \"\", error: \"\"}\n          validation.set(id, valObj)\n        }\n        o.parseErrors.forEach(ve => valObj.error = (valObj.error||\"\") + ve + \"\\n\") \n      }\n      if (!v[parseInt(fPos[\"Tipo\"])]) {\n        let valObj = null\n        if (validation.get(id)) {\n          valObj = validation.get(id)\n        } else {\n          valObj = { error: \"\", warning: \"\"}\n          validation.set(id, valObj)\n        }\n        valObj.warning = (valObj.warning||\"\") + \"Oggetto non parsato\\n\" \n      }\n      function evidenziaerrore(colonna) {\n        if (v[colonna] != db.dataFixed[index][colonna] ) {\n          if (String(v[colonna]).trim() == String(db.dataFixed[index][colonna]).trim()) {\n            let val = validation.get(id)||{ warning: \"\", error: \"\"};\n            val.warning = (val.warning||\"\") + \"Spazi diversi su colonna \"+colonna\n            validation.set(id, val)\n          } else {\n            let val = validation.get(id)||{ warning: \"\", error: \"\"};\n            val.error = (val.error||\"\") + \"Parsato male colonna \"+colonna\n            validation.set(id, val)\n          } \n        }\n      }\n      for (let i = 0; i < fPos.length; i++) {\n        evidenziaerrore(i)\n      }\n      index++;\n    }\n    return validation\n  }\n}\n\ndbState[databases[0]].dbData = dbPubblico\ndbState[databases[0]].lastValidation = dbUtil.validateDB(dbPubblico)\ndbState[databases[1]].dbData = dbPrivato\ndbState[databases[1]].lastValidation = dbUtil.validateDB(dbPrivato)\n\nsource.dataFields.push({\n  \"name\": \"Warning\",\n  \"type\": \"bool\"\n})\nsource.dataFields.push({\n  \"name\": \"Error\",\n  \"type\": \"bool\"\n})\nsource.dataFields.push({\n  \"name\": \"Duplicate\",\n  \"type\": \"bool\"\n})\nsource.dataFields.push({\n  \"name\": \"ParseError\",\n  \"type\": \"bool\"\n})\nsource.dataFields.push({\n  \"name\": \"Private\",\n  \"type\": \"bool\"\n})\nsource.dataFields.push({\n  \"name\": \"Personal\",\n  \"type\": \"bool\"\n})\nsource.dataFields.push({\n  \"name\": \"Affects\",\n  \"type\": \"string\"\n})\n\nfunction clearFilters() {\n  clearLabelValues()\n  let tbl = $(\"#identDataTable\", $(win))\n  tbl.jqxDataTable('clearFilters')\n}\n\nconst actions = {\n  mostraTutto: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    clearFilters()\n  },\n  mostraNoProv: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    let filter = filtergroup.createfilter('stringfilter', \"\", 'null');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"Provenienza\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  mostraErrori: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    let filter = filtergroup.createfilter('booleanfilter', true, 'equal');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"Error\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  mostraErroriEAvvertimenti: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    filtergroup.operator = 'or';\n    let filter = filtergroup.createfilter('booleanfilter', true, 'equal');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"Error\", filtergroup);\n    filtergroup = new $.jqx.filter();\n    filtergroup.operator = 'or';\n    filter = filtergroup.createfilter('booleanfilter', true, 'equal');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"Warning\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  mostraAvvertimenti: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    let filter = filtergroup.createfilter('booleanfilter', true, 'equal');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"Warning\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  mostraDuplicati: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    let filter = filtergroup.createfilter('booleanfilter', true, 'equal');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"Duplicate\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  mostraErroriParsing: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    let filter = filtergroup.createfilter('booleanfilter', true, 'equal');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"ParseError\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  mostraPrivati: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    let filter = filtergroup.createfilter('stringfilter', \"Priv\", 'starts_with');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"ID\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  mostraPersonali: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let tbl = $(\"#identDataTable\", $(win))\n    clearFilters()\n    let filtergroup = new $.jqx.filter();\n    let filter = filtergroup.createfilter('booleanfilter', true, 'equal');\n    filtergroup.addfilter(0, filter);\n    tbl.jqxDataTable('addFilter', \"Personal\", filtergroup);\n    tbl.jqxDataTable('applyFilters');\n  },\n  cancellaPrivati: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let dbIdent = getDBData()\n    for (let i = dbIdent.data.length - 1; i >= 0; i--) {\n      if (dbUtil.isItemPrivato(dbIdent.data[i]) ) { \n        dbIdent.data.splice(i,1);\n        setModified(true)\n        if (dbIdent.dataFixed) dbIdent.dataFixed.splice(i,1);\n      }\n    }\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n  },\n  coreggiErrori: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    \n    dbUtil.dbFix(getDBData())\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n  },\n  coreggiDuplicati: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    let val = new Map()\n    dbUtil.fixDuplicati(getDBData(), val)\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n  },\n  rinumera: () => {\n    if (!getDBData()) { Notification.Warning(\"Devi avere un DB caricato\"); return; }\n    if (dbState.current!=\"Database Pubblico\") { Notification.Warning(\"Questa azione e' valida solo sul DB Pubblico\"); return; }\n    dbUtil.fixId(getDBData())\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n  },\n  selectAll: () => {\n    gridUtil.selectAll(false)\n  },\n  selectVisible: () => {\n    gridUtil.selectAll(true)\n  },\n  selectNone: () => {\n    gridUtil.selectNone()\n  },\n  deleteSelected: async () => {\n    let rows = gridUtil.getSelectedRows().map(r => r.ID.toString())\n    let idPos = fPos[\"ID\"]\n    if (rows.length < 1) {\n      Notification.Show(\"Nessun oggetto selezionato\")\n      return\n    }\n    let re = await Messagebox.Question(\"Sei sicuro di voler cancellare \" + rows.length + \" oggetti da \" + dbState.current + \"?\")\n    if (re.button != 1) {\n      return\n    }\n    getDBData().data = getDBData().data.filter( el => !rows.includes(String(el[idPos])));\n    if (getDBData().dataFixed) getDBData().dataFixed = getDBData().dataFixed.filter( el => !rows.includes(String(el[idPos])));\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n    Notification.Show(rows.length + \" oggetti cancellati\")\n  },\n  parseSelected: () => {\n    let rows = gridUtil.getSelectedRows()\n    if (rows.length < 1) {\n      Notification.Show(\"Nessun oggetto selezionato\")\n      return\n    }\n    for (let row of rows) {\n      let gr = gridUtil.updateRowField(row.ID, \"Identify\", row.Identify)\n    }\n    gridUtil.refreshRowDetails()\n    Notification.Show(rows.length + \" oggetti parsati\")\n  },\n  duplicateSelected: () => {\n    let rows = gridUtil.getSelectedRows()\n    if (rows.length < 1) {\n      Notification.Show(\"Nessun oggetto selezionato\")\n      return\n    }\n    let dbIdent = getDBData()\n    let idPos = fPos[\"ID\"]\n    for (let row of rows) {\n      let copy = JSON.parse(JSON.stringify(rowsByID.get(row.ID.toString())));\n      copy[idPos] = String(copy[idPos]) + \"_c\";\n      dbIdent.data.push(copy);\n    }\n    dbUtil.dbSort(dbIdent);\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n    Notification.Show(rows.length + \" oggetti clonati\")\n  },\n  fondiPrivati: async () => {\n    if (dbState.current == databases[0]) {\n      Notification.Warning(\"Non puoi farlo sulla schermata del DB pubblico\")\n      return\n    }\n    let errors = [...getValidation().values()].filter(v => v.error).length\n    let warnings = [...getValidation().values()].filter(v => v.warning).length\n    if (errors > 0) {\n      Notification.Warning(\"Ci sono \" + errors + \" errori. Devi prima risolverli.\")\n      return\n    }\n    if (warnings > 0) {\n      let re = await Messagebox.Question(\"Ci sono \" + warnings + \" avvertimenti. Vuoi continuare?\")\n      if (re.button != 1) return\n    }\n    let validation = new Map()\n    let recordDaCancellare = new Map()\n    let oldDbIdentMapID = dbUtil.mergeAndFix(dbPrivato, dbPubblico, validation, recordDaCancellare)\n    let dbIdentMapID = new Map();\n    for (let item of dbPubblico.data) {\n      dbIdentMapID.set(item[fPos[\"ID\"]],item);\n    }\n    Notification.Show(\"Merge eseguito. Controlla di non avere ID privati nel pubblico!\")\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n    let ref = await Messagebox.Question(\"Vuoi cancellare dal privato gli oggetti mergiati?\")\n    if (ref.button == 1) {\n      for (let i = dbPrivato.data.length - 1; i >= 0; i--) {\n        if ( dbIdentMapID.has(dbPrivato.data[i][fPos[\"ID\"]]) ||\n            recordDaCancellare.has(dbPrivato.data[i][fPos[\"ID\"]].toString())\n           ) { \n          dbPrivato.data.splice(i,1);\n        }\n      }\n    }\n    gridUtil.setSource(dbUtil.loadDatabase(databases[0]))\n    errors = [...getValidation().values()].filter(v => v.error).length\n    if (errors > 0) {\n      let re = await Messagebox.Question(\"Attenzione il risultante DB pubblico ha \" + errors + \" errori.\\nVuoi visualizzarli?\")\n      if (re.button == 1) {\n        actions.mostraErroriEAvvertimenti()\n      }\n    }\n  },\n  cleanPrivati: () => {\n    if (dbState.current == databases[0]) {\n      Notification.Warning(\"Non puoi farlo sulla schermata del DB pubblico\")\n      return\n    }\n    let map = new Map();\n    for (let el of dbPubblico.data) {\n      let key = [el[fPos[\"Oggetto\"]],el[fPos[\"DescrizioneShort\"]],el[fPos[\"DescrizioneLong\"]]].join(\"|\");\n      map.set(key,el);\n    }\n    let cnt = 0\n    for (let i = dbPrivato.data.length - 1; i >= 0; i--) {\n      let el = dbPrivato.data[i]\n      let key = [el[fPos[\"Oggetto\"]],el[fPos[\"DescrizioneShort\"]],el[fPos[\"DescrizioneLong\"]]].join(\"|\");\n      if ( map.has(key) && map.get(key)[fPos[\"Provenienza\"]] && !el[fPos[\"Provenienza\"]]) {\n        cnt++;\n        dbPrivato.data.splice(i,1);\n      }\n    }\n    if (cnt>0) {\n      setModified(true)\n    }\n    Notification.Show(cnt + \" oggetti privati senza provenienza presenti nel pubblico sono stati cancellati\")\n    gridUtil.setSource(dbUtil.loadDatabase(dbState.current))\n  },\n  caricaJSON: () => {\n    importFromFile(dbState.current==databases[0]?importPublico:importPrivato)\n  },\n  saveAllDB: () => {\n    databases.forEach(db => saveDB(db))\n  },\n  saveCurrentDB: () => {\n    saveDB()\n  },\n  esportaIdentInJSON: async () => {\n    if (getModified()) {\n      Notification.Show(\"Stai esportando dati non salvati da memoria. Ricordati di salvare se lo volevi.\")\n    }\n    let db = getDBData()\n    let dbName = dbState.current\n    let obj = {\n      data: db.data,\n      fields: dbPubblico.fields,\n      dbinfo: db.dbinfo\n    }\n    if (dbName == databases[0]) {\n      obj.dbinfo = db.dbinfo;\n      obj.dbinfo = await editDbInfo(\"Versione export di DB pubblico\", obj.dbinfo)\n      downloadJsonToFile({ dbinfo: obj.dbinfo }, \"identDbPublicVersion.json\")\n    } else {\n      obj.dbinfo.data = formattedDate()\n      obj.dbinfo.msg = \"Client export\"\n    }\n    let filename = \"Export \"+ dbState.current + \" v\" + obj.dbinfo.ver + \" \" + formattedDate(new Date(), '') + \".json\"\n    downloadJsonToFile(obj, filename)\n  },\n}\n\nfunction downloadJsonToFile(json, filename) {\n    let jsonstr = JSON.stringify(json, null, 2);\n    downloadString(jsonstr, filename);\n}\n\nfunction downloadString(jsonstr, filename) {\n    let blob = new Blob([jsonstr], { type: \"octet/stream\" });\n    let url = window.URL.createObjectURL(blob);\n\n    let link = document.createElement(\"a\");\n    link.setAttribute(\"href\", url);\n    link.setAttribute(\"download\", filename);\n    link.style.visibility = \"hidden\";\n\n    document.body.appendChild(link);\n    link.click();\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(link);\n}\n\nmenu.on('itemclick', (event) =>\n{\n  let owner = event.args.owner;\n  let elem = event.args\n  if (owner) {\n    owner.items.filter(i => i.parentItem == null).forEach(i => {\n      menu.jqxMenu('closeItem', i.id)\n    })\n  }\n  if (elem.id && actions[elem.id]) {\n    actions[elem.id]()\n  }\n});\n\nconst dataAdapter = new $.jqx.dataAdapter(source);\n\nlet columns = [{\n  text: 'ID',\n  dataField: 'ID',\n  width: 52,\n  editable: false,\n  pinned: true,\n  cellsRenderer: function (row, column, value, rowData) {\n    let rowId = (source.localData[row] ? source.localData[row].ID : rowData.ID).toString()\n    let color = \"\"; let title = \"\";\n    let vals = getValidation()\n    let val = vals.get(rowId)\n    if (val?.warning) {\n      color = \"background-color: yellow;\"\n      title += \"Avvertimenti:\\n\" + val.warning + \"\\n\"\n    }\n    if (val?.error) {\n      color = \"background-color: orange;\"\n      title += \"Errori:\\n\" +val.error\n    }\n    var container = '<div style=\"width: 100%; height: 100%;'+color+'\" title=\"'+ title +'\">'\n    container += rowId\n    if (val?.error) {\n      container += \"💥\"\n    }\n    container += \"</div>\";\n    return container;\n  }\n},{\n  text: 'Key',\n  dataField: 'Oggetto',\n  width: 125,\n  editable: false,\n  pinned: true\n}, {\n  text: 'Tipo',\n  dataField: 'Tipo',\n  width: 80\n}, {\n  text: 'Pos',\n  dataField: 'PosizioneIndossabile',\n  width: 60\n}, {\n  text: 'Short',\n  dataField: 'DescrizioneShort',\n  width: 130\n}, {\n  text: 'Dadi',\n  dataField: 'DannoArma',\n  width: 40,\n  align: \"right\", cellsalign: \"right\"\n}, {\n  text: 'Dam',\n  dataField: 'Danno',\n  width: 40,\n  align: \"right\", cellsalign: \"right\"\n}, {\n  text: 'HP',\n  dataField: 'HP',\n  width: 40,\n  align: \"right\", cellsalign: \"right\"\n}, {\n  text: 'SP',\n  dataField: 'SP',\n  width: 40,\n  align: \"right\", cellsalign: \"right\"\n}, {\n  text: 'Mana',\n  dataField: 'Mana',\n  width: 40,\n  align: \"right\", cellsalign: \"right\"\n}, {\n  text: 'Provenienza',\n  dataField: 'Provenienza',\n  width: 100\n}, {\n  text: 'NoRent',\n  dataField: 'NoRent',\n  width: 50,\n  align: \"left\"\n},{\n  text: 'Identify',\n  dataField: 'Identify',\n  width: 0,\n  hidden:true\n}, {\n  text: 'Affects',\n  dataField: 'Affects',\n  width: 0,\n  hidden:true\n}]\n\nfor (let df of source.dataFields) {\n  if (columns.find(c => c.dataField == df.name)) continue;\n  columns.push({\n    text: df.name,\n    dataField: df.name,\n    align: (df.type==\"string\"?'left':'right'),\n    cellsalign: (df.type==\"string\"?'left':'right'),\n    minWidth: 80\n  })\n}\n\ncolumns.find(c => c.dataField == \"Provenienza\").aggregates = [\n  { 'NoProv':\n    function (aggregatedValue, currentValue) {\n        if (aggregatedValue==0) {\n          menu_labels.mostraNoProv.val=0\n        }\n        if ((currentValue||\"\").toString().trim()==\"\") {\n          menu_labels.mostraNoProv.val = aggregatedValue + 1\n          return (menu_labels.mostraNoProv.val);\n        }\n        //menu_labels.mostraAvvertimenti.val = aggregatedValue\n        return aggregatedValue;\n    }\n}];\n\ncolumns.find(c => c.dataField == \"Error\").aggregates = [\n  { 'Errors':\n    function (aggregatedValue, currentValue) {\n        if (aggregatedValue==0) {\n          menu_labels.mostraErrori.val=0\n        }\n        if (currentValue) {\n          menu_labels.mostraErrori.val = aggregatedValue + 1\n          return (menu_labels.mostraErrori.val);\n        }\n        //menu_labels.mostraAvvertimenti.val = aggregatedValue\n        return aggregatedValue;\n    }\n}];\n\ncolumns.find(c => c.dataField == \"Warning\").aggregates = [\n  { 'Warnings':\n    function (aggregatedValue, currentValue) {\n        if (aggregatedValue==0) {\n          menu_labels.mostraAvvertimenti.val=0\n        }\n        if (currentValue) {\n            menu_labels.mostraAvvertimenti.val = aggregatedValue + 1\n            return (menu_labels.mostraAvvertimenti.val);\n        }\n        //menu_labels.mostraAvvertimenti.val = aggregatedValue\n        return aggregatedValue;\n    }\n}];\n\ncolumns.find(c => c.dataField == \"Personal\").aggregates = [\n  { 'Personals':\n    function (aggregatedValue, currentValue) {\n        if (aggregatedValue==0) {\n          menu_labels.mostraPersonali.val=0\n        }\n        if (currentValue) {\n            return (menu_labels.mostraPersonali.val = aggregatedValue + 1);\n        }\n        //menu_labels.mostraPersonali.val = aggregatedValue\n        return aggregatedValue;\n    }\n}];\n\ncolumns.find(c => c.dataField == \"Private\").aggregates = [\n  { 'Privates':\n    function (aggregatedValue, currentValue) {\n        if (aggregatedValue==0) {\n          menu_labels.mostraPrivati.val=0\n        }\n        if (currentValue) {\n            return (menu_labels.mostraPrivati.val = aggregatedValue + 1);\n        }\n        //menu_labels.mostraPrivati.val = aggregatedValue\n        return aggregatedValue;\n    }\n}];\n\ncolumns.find(c => c.dataField == \"ParseError\").aggregates = [\n  { 'ErrParse':\n    function (aggregatedValue, currentValue) {\n        if (aggregatedValue==0) {\n          menu_labels.mostraErroriParsing.val=0\n        }\n        if (currentValue) {\n            return (menu_labels.mostraErroriParsing.val = aggregatedValue + 1);\n        }\n        //menu_labels.mostraErroriParsing.val = aggregatedValue\n        return aggregatedValue;\n    }\n}];\n\ncolumns.find(c => c.dataField == \"Duplicate\").aggregates = [\n  { 'Duplicates':\n    function (aggregatedValue, currentValue) {\n        if (aggregatedValue==0) {\n          menu_labels.mostraDuplicati.val=0\n        }\n        if (currentValue) {\n            return (menu_labels.mostraDuplicati.val = aggregatedValue + 1);\n        }\n        //menu_labels.mostraDuplicati.val = aggregatedValue\n        return aggregatedValue;\n    }\n}];\n\nvar initRowDetails = (id, row, element, rowinfo) => {\n  var tabsdiv = null;\n  var information = null;\n  var notes = null;\n  var affects = null;\n  rowinfo.detailsHeight = 270;\n  element.append($(\"<div style='margin: 10px;'><ul style='margin-left: 10px;'><li class='title'>Oggetto</li><li>Affects</li><li>Identify</li></ul><div class='information'></div><div class='affects'></div><div style='position:relative;' class='identify'></div></div>\"));\n  tabsdiv = $(element.children()[0]);\n  if (tabsdiv != null) {\n    information = tabsdiv.find('.information');\n    notes = tabsdiv.find('.identify');\n    affects = tabsdiv.find('.affects');\n    var title = tabsdiv.find('.title');\n    title.text(row.Oggetto);\n    var container = $('<div style=\"margin: 5px;\"></div>');\n    container.appendTo($(information));\n    var leftcolumn = $('<div style=\"float: left; width: 70%;\"></div>');\n    var rightcolumn = $('<div style=\"float: left; width: 30%;\"></div>');\n    container.append(leftcolumn);\n    container.append(rightcolumn);\n    \n    var tipo = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Tipo:</b> <span>\" + \"N/A\" +\"</span></div>\");\n    //var key = \"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Key:</b> \" + row.Oggetto + \"</div>\";\n    var short = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Short:</b> <span>\" + \"N/A\" + \"</span></div>\");\n    var long = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Long:</b> <span>\" + \"N/A\" + \"</span></div>\");\n    var flags = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Flags:</b> <span>\" + \"N/A\" + \"</span></div>\");\n    var prov = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Prov.:</b> <input class='inputprovenienza' style='width:380px;border: none;margin: 0;' type='text' placeholder='[nessuna]' value='\" + \"N/A\" + \"'><button title='Salva provenienza' class='saveprovenienza' style='display:none;padding: 0;padding-left: 2px;padding-right: 2px;background-color:yellowgreen;'>&check;</button></div>\");\n    $(leftcolumn).append(tipo);\n    //$(leftcolumn).append(key);\n    $(leftcolumn).append(short);\n    $(leftcolumn).append(long);\n    $(leftcolumn).append(flags);\n    $(leftcolumn).append(prov);\n    function createTldr(row) {\n    let altroText = \"\"\n      if (row.Tipo==\"WEAPON\") {\n        altroText += \" Max dado: \"+row.DannoArma\n      }\n      if (row.HP) {\n        altroText += \" HP: \"+row.HP\n      }\n      if (row.Danno) {\n        altroText += \" Dam: \"+row.Danno\n      }\n      if (row.SP) {\n        altroText += \" SP: \"+row.SP\n      }\n      if (row.Mana) {\n        altroText += \" Mana: \"+row.Mana\n      }\n      return altroText\n    }\n    var peso = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Peso:</b> <span>\" + \"N/A\" + \"</span></div>\");\n    var valore = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Valore:</b> <span>\" + \"N/A\" + \"</span></div>\");\n    var rent = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Rent:</b> <span>\" + \"N/A\" + \"</span></div>\");\n    var nota = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Nota:</b> <span>\" + \"N/A\" + \"</span></div>\");\n    var altro = $(\"<div style='margin: 5px;'><b style='display:inline-block;position:relative;width:40px'>Tldr:</b> <span>\" + \"N/A\" + \"</span></div>\");\n\n    $(rightcolumn).append(peso);\n    $(rightcolumn).append(valore);\n    $(rightcolumn).append(rent);\n    $(rightcolumn).append(nota);\n    $(rightcolumn).append(altro);\n    function getAffecttext(row) {\n      let aff = \"\"\n      if ((row.Affect1Tipo||\"\").trim()) {\n        aff += \"<b style='text-align:right;display:inline-block;min-width:130px'>\" + row.Affect1Tipo + \"</b> : <b>\" + row.Affect1Valore + \"</b>\\n\"\n      }\n      if ((row.Affect2Tipo||\"\").trim()) {\n        aff += \"<b style='text-align:right;display:inline-block;min-width:130px'>\" + row.Affect2Tipo + \"</b> : <b>\" + row.Affect2Valore + \"</b>\\n\"\n      }\n      if ((row.Affect3Tipo||\"\").trim()) {\n        aff += \"<b style='text-align:right;display:inline-block;min-width:130px'>\" + row.Affect3Tipo + \"</b> : <b>\" + row.Affect3Valore + \"</b>\\n\"\n      }\n      if ((row.Affect4Tipo||\"\").trim()) {\n        aff += \"<b style='text-align:right;display:inline-block;min-width:130px'>\" + row.Affect4Tipo + \"</b> : <b>\" + row.Affect4Valore + \"</b>\\n\"\n      }\n      if ((row.Affect5Tipo||\"\").trim()) {\n        aff += \"<b style='text-align:right;display:inline-block;min-width:130px'>\" + row.Affect5Tipo + \"</b> : <b>\" + row.Affect5Valore + \"</b>\\n\"\n      }\n      return aff\n    }\n    var affectscontainer = $('<div style=\"white-space: pre; margin: 5px;text-wrap:wrap;\"><span>' + \"N/A\" + '</span></div>');\n    $(affects).append(affectscontainer);\n    var notescontainer = $('<div contenteditable style=\"font-family:monospace;font-weight:bold;white-space: pre; margin: 5px;text-wrap:wrap;\"><span>' + \"N/A\" + '</span></div>');\n    var applyIde = $('<button class=\"saveidentify\" title=\"Conferma e parsa\" style=\"display:none;background-color:yellowgreen;position:absolute;right:10px;top:10px;\">&check;</button>')\n    $(notes).append(notescontainer);\n    $(notes).append(applyIde);\n    function updateRowDetails(row) {\n      $(\"span\",tipo).text(row.Tipo + \" (\" + (row.PosizioneIndossabile||\"non indossabile\") + \")\")\n      $(\"span\",short).text(row.DescrizioneShort)\n      $(\"span\",long).text(row.DescrizioneLong)\n      $(\"span\",flags).text((row.Proprieta||\"-\"))\n      $(\"input\",prov).val((row.Provenienza))\n      $(\"span\",rent).text(row.Rent + \" \" + (row.Rare ? \"RARO\" :\"\" + \" \") + \" \" + (row.NoRent ? \"NORENT\" :\"\"))\n      $(\"span\",valore).text(row.Valore)\n      $(\"span\",peso).text(row.Peso)\n      $(\"span\",nota).text((row.Nota||\"-\"))\n      $(\"span\",altro).text(createTldr(row)||\"-\")\n      $(\"span\",affectscontainer).html(getAffecttext(row))\n      $(\"span\",notescontainer).text(row.Identify)\n      $(tabsdiv).jqxTabs(\"setTitleAt\",0,row.Oggetto)\n      row._refreshDetails = () => {\n        updateRowDetails(row)\n      }\n    }\n    updateRowDetails(row)\n    applyIde.click(ev => {\n      let newIde = notescontainer[0].textContent\n      let gridRow = gridUtil.updateRowField(row.ID.toString(), 'Identify', newIde)\n      updateRowDetails(gridRow)\n      if (gridRow.ParseError) {\n        notescontainer.css({ \"color\": \"red\"})\n      } else  {\n        notescontainer.css({ \"color\": \"\"})\n      }\n      $(applyIde, $(leftcolumn)).css({\"display\":\"none\"})\n    })\n    $(\".saveprovenienza\", $(leftcolumn)).click(ev => {\n      let newProv = ($(\".inputprovenienza\", $(leftcolumn)).val())\n      let gridRow = gridUtil.updateRowField(row.ID.toString(), 'Provenienza', newProv)\n      let rowIndex = source.localData.indexOf(gridRow)\n      $(\"#identDataTable\", $(win)).jqxDataTable('updateRow', rowIndex, gridRow)\n      updateRowDetails(gridRow)\n      $(\".saveprovenienza\", $(leftcolumn)).css({\"display\":\"none\"})\n    })\n    $(\".inputprovenienza\", $(leftcolumn)).on(\"input\", () => {\n      if ($(\".inputprovenienza\", $(leftcolumn)).val() != row.Provenienza) {\n        $(\".saveprovenienza\", $(leftcolumn)).css({\n          \"display\": \"inline-block\"\n        })\n      }\n    })\n    $(notescontainer).on(\"input\", () => {\n      if (notescontainer[0].textContent != row.Identify) {\n        $(applyIde).css({\n          \"display\": \"inline-block\"\n        })\n      }\n    })\n    $(tabsdiv).jqxTabs({\n      width: 700,\n      height: 260\n    });\n  }\n}\n\n\n$(\"#identDataTable\", $(win)).jqxDataTable({\n  pageable: true,\n  editable: false,\n  autoRowHeight: false,\n  pagerButtonsCount: 10,\n  showAggregates: true,\n  pageSizeOptions: ['10', '20', '30','100','250'],\n  pagerMode: 'advanced',\n  width: \"100%\",\n  height: \"100%\",\n  altRows: true,\n  filterable: true,\n  rowDetails: true,\n  sortable: true,\n  initRowDetails: initRowDetails,\n  columnsReorder: true,\n  columnsResize: true,\n  filterMode: 'advanced',\n  source: dataAdapter,\n  columns: columns,\n  localization: {\n    pagerGoToPageString: \"Pagina#:\",\n    pagerShowRowsString: \"Oggetti per pagina:\",\n    pagerRangeString: \" di \",\n    pagerPreviousButtonString: \"precedente\",\n    pagerNextButtonString: \"sucessivo\",\n    pagerFirstButtonsSring: \"primo\",\n    pagerLastButtonString:\"ultimo\",\n    emptyDataString: \"Nessun oggetto trovato\",\n    filterApplyString: \"Applica\",\n    filterCancelString: \"Nascondi\",\n    filterClearString: \"Rimuovi filtro\",\n    filterString: \"Filtro avanzato\",\n    filterSearchString: \"Cerca:\",\n    filterStringComparisonOperators: ['vuoto', 'non vuoto', 'contiene', 'contiene(match case)',\n       'non contiene', 'non contiene(match case)', 'inizia', 'inizia(match case)',\n       'finisce con', 'finisce con(match case)', 'uguale', 'uguale(match case)', 'nullo', 'non nullo'],\n    filterNumericComparisonOperators: ['uguale', 'diverso', 'minore', 'minore o uguale', 'maggiore', 'maggiore o uguale', 'nullo', 'non nullo'],\n    filterDateComparisonOperators: ['uguale', 'diverso', 'minore', 'minore o uguale', 'maggiore', 'maggiore o uguale', 'nullo', 'non nullo'],\n    filterBooleanComparisoOoperators: ['uguale', 'diverso'],\n    validationString: \"Valore non valido\",\n    emptyDataString: \"Dati non presenti\",\n    filterSelectString: \"Seleziona filtro\",\n  }\n});\n\n$(\"#identDataTable\", $(win)).on(\"keyup\", e => {\n  if (e.key == \"Delete\" &&\n      e.target.tagName != \"INPUT\" &&\n      e.target.contentEditable.toString() != \"true\") {\n    actions.deleteSelected()\n  }\n}) \nconst winSize = {w:0,h:0}\nwxWin.on(\"resize\", throttle(() => {\n  if ($(win).jqxWindow(\"width\")!=winSize.w || $(win).jqxWindow(\"height\")!=winSize.h) {\n    $(\"#identDataTable\", $(win)).jqxDataTable('render')\n  }\n  winSize.w = $(win).jqxWindow(\"width\")\n  winSize.h = $(win).jqxWindow(\"height\")\n},250))\n\n$(\"#selDb\", $(win)).jqxDropDownList({ source: databases, autoDropDownHeight:true, placeHolder: \"Seleziona Database\", width: 125})\n\n$(\"#selDb\", $(win)).on(\"select\", (event) => {\n  clearFilters()\n  gridUtil.setSource(dbUtil.loadDatabase(event.args.item.label));\n})\n\n$(\"#identDataTable\", $(win)).on('rowUnselect', function (event)\n{\n    $(\"#identDataTable\", $(win)).jqxDataTable('hideDetails', event.args.index);\n});\n\n$(\"#identDataTable\", $(win)).on('filter', function (event)\n{\n    menu_labels.mostraErroriEAvvertimenti.val = menu_labels.mostraAvvertimenti.val + menu_labels.mostraErrori.val \n});\n\n$(\"#identDataTable\", $(win)).on('rowSelect', function (event)\n{\n  let elem = $(\"#identDataTable\", $(win))\n  let sel = elem.jqxDataTable('getSelection')\n  if (sel.length>1 && sel.length<=10) {\n    let rows = elem.jqxDataTable('getRows')\n    sel.forEach(s => elem.jqxDataTable('hideDetails', rows.indexOf(s)))\n    return;\n  }\n  //elem.jqxDataTable('showDetails', event.args.index);\n});\n$(\"#identDataTable\", $(win)).on('rowDoubleClick', function (event)\n{\n\n  let elem = $(\"#identDataTable\", $(win))\n  let sel = elem.jqxDataTable('getSelection')\n\n  if (sel.length>1) {\n    let rows = elem.jqxDataTable('getRows')\n    sel.forEach(s => elem.jqxDataTable('hideDetails', rows.indexOf(s)))\n  }\n  setTimeout(()=>elem.jqxDataTable('showDetails', event.args.index),100);\n});\n\n$(\"#identDataTable\", $(win)).on('bindingComplete', function (event)\n{\n  let i = columns.findIndex(r => r.dataField == \"Identify\")\n  $(\".filtercolumns.jqx-dropdownlist\", $(win)).jqxDropDownList(\"selectIndex\",i)\n  let filter = $(\"input.jqx-input.jqx-input-group-addon\",$(\"#identDataTable\", $(win)))\n  setTimeout(()=>filter.focus(),250)\n});\n\nif (getvar(\"publicident\")==true) {\n  $(\"#selDb\", $(win)).jqxDropDownList('selectIndex', 0 );\n} else {\n  $(\"#selDb\", $(win)).jqxDropDownList('selectIndex', 1 );\n}",
      "shortcut": "",
      "script": null
    },
    {
      "class": "util",
      "enabled": true,
      "id": "",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^track (.+)",
      "regex": true,
      "value": "const mob = match[1];\nsetvar(\"trackmob\",mob,true);\nsend(\"~track \" + mob);\nif (this.isCapogruppo(this.TSPersonaggio)) return;\n\nlet gruppo = JSON.parse(this.Gruppo);\nlet k = Object.keys(gruppo).slice(2);\nlet capogruppo=k[0]\nif (gruppo[capogruppo]?.inroom!=1) return;\n\nsend(\"gtTrigger Cerco le tracce di: \" + mob);\ntoggleTrigger(\"track-cerca\",true);\ntoggleTrigger(\"track-fine\",true);       \n",
      "shortcut": "",
      "script": null
    },
    {
      "class": "where",
      "enabled": true,
      "id": "where",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^whe(?:r|re)? (.+)$",
      "regex": true,
      "value": "send(\"~where \" + match[1]);\ntoggleTrigger(\"wheretrg\",true)\ntoggleTrigger(\"whereend\", true)",
      "shortcut": "",
      "script": null
    },
    {
      "class": "util",
      "enabled": true,
      "id": "ripeti",
      "is_prompt": false,
      "is_script": true,
      "pattern": "^(\\d+)x(?: (.*))?$",
      "regex": true,
      "value": "const nvolte = match[1];\nif (nvolte>50) {\n  print(\"Numero troppo grande di ripetizioni richieste\");\n  return;\n}\n\nconst comando = match[2];\nif (!comando || (nvolte==0)) {\n  print(\"USO: NNx comando1|comando2|...|comando\")\n  print(\"         dove NN è un numero da 1 a 50\")\n  print(\"         eventuali # verranno convertiti nel numero della ripetizione\")\n  return;\n}\n\nlet result;\nfor (let i=1; i<=nvolte; i++) {\n\tresult = comando.replace(\"#\", i)\n  result = result.replace(\"|\", \";\")\n\tsend(result)\n}",
      "shortcut": "",
      "script": null
    }
  ],
  "classes": [
    [
      "cleric",
      {
        "name": "cleric",
        "enabled": false
      }
    ],
	[
      "util|staffe",
      {
        "name": "util|staffe",
        "enabled": false
      }
    ],
    [
      "druid",
      {
        "name": "druid",
        "enabled": false
      }
    ],
    [
      "mage",
      {
        "name": "mage",
        "enabled": false
      }
    ],
    [
      "fight",
      {
        "name": "fight",
        "enabled": true
      }
    ],
    [
      "autocleric",
      {
        "name": "autocleric",
        "enabled": false
      }
    ],
    [
      "autoassist",
      {
        "name": "autoassist",
        "enabled": false
      }
    ],
    [
      "autobash",
      {
        "name": "autobash",
        "enabled": false
      }
    ],
    [
      "autologin",
      {
        "name": "autologin",
        "enabled": false
      }
    ],
    [
      "autorescue",
      {
        "name": "autorescue",
        "enabled": false
      }
    ],
    [
      "autoarmi",
      {
        "name": "autoarmi",
        "enabled": false
      }
    ],
    [
      "antispalm",
      {
        "name": "antispalm",
        "enabled": false
      }
    ],
    [
      "debug",
      {
        "name": "debug",
        "enabled": false
      }
    ],
    [
      "autogroup",
      {
        "name": "autogroup",
        "enabled": false
      }
    ],
    [
      "autoloot",
      {
        "name": "autoloot",
        "enabled": false
      }
    ],
    [
      "gtalign",
      {
        "name": "gtalign",
        "enabled": false
      }
    ],
    [
      "fixxa",
      {
        "name": "fixxa",
        "enabled": false
      }
    ],
    [
      "autostab",
      {
        "name": "autostab",
        "enabled": false
      }
    ],
    [
      "indietro",
      {
        "name": "indietro",
        "enabled": false
      }
    ],
    [
      "autosanc",
      {
        "name": "autosanc",
        "enabled": false
      }
    ],
    [
      "memorize",
      {
        "name": "memorize",
        "enabled": false
      }
    ],
    [
      "automemorize",
      {
        "name": "automemorize",
        "enabled": true
      }
    ],
    [
      "psionic",
      {
        "name": "psionic",
        "enabled": false
      }
    ],
    [
      "sorcerer",
      {
        "name": "sorcerer",
        "enabled": false
      }
    ],
    [
      "selfsanc",
      {
        "name": "selfsanc",
        "enabled": false
      }
    ],
    [
      "selfshield",
      {
        "name": "selfshield",
        "enabled": false
      }
    ],
    [
      "login",
      {
        "name": "login",
        "enabled": true
      }
    ],
    [
      "bard",
      {
        "name": "bard",
        "enabled": false
      }
    ],
    [
      "autosong",
      {
        "name": "autosong",
        "enabled": false
      }
    ],
    [
      "autoinspire",
      {
        "name": "autoinspire",
        "enabled": false
      }
    ],
    [
      "util",
      {
        "name": "util",
        "enabled": true
      }
    ],
    [
      "thief",
      {
        "name": "thief",
        "enabled": false
      }
    ],
    [
      "autokill",
      {
        "name": "autokill",
        "enabled": false
      }
    ],
    [
      "afk",
      {
        "name": "afk",
        "enabled": false
      }
    ],
    [
      "immortal",
      {
        "name": "immortal",
        "enabled": false
      }
    ],
    [
      "Ident",
      {
        "name": "Ident",
        "enabled": false
      }
    ],
    [
      "IdentInit",
      {
        "name": "IdentInit",
        "enabled": true
      }
    ],
    [
      "cani",
      {
        "name": "cani",
        "enabled": true
      }
    ],
    [
      "mapper",
      {
        "name": "mapper",
        "enabled": true
      }
    ],
    [
      "config",
      {
        "name": "config",
        "enabled": true
      }
    ],
    [
      "help",
      {
        "name": "help",
        "enabled": true
      }
    ],
    [
      "zone:157",
      {
        "name": "zone:157",
        "enabled": false
      }
    ],
    [
      "questor",
      {
        "name": "questor",
        "enabled": false
      }
    ],
    [
      "monk",
      {
        "name": "monk",
        "enabled": false
      }
    ]
  ],
  "triggersEnabled": true,
  "aliasesEnabled": true,
  "soundsEnabled": true,
  "numpad": {
    "NumpadSubtract": "cambiascudo",
    "NumpadAdd": "cambiaarma",
    "NumpadMultiply": "",
    "NumpadDivide": "",
    "NumpadEnter": "",
    "NumpadDecimal": "porte",
    "Numpad0": "cura",
    "Numpad1": "casta",
    "Numpad2": "south",
    "Numpad3": "down",
    "Numpad4": "west",
    "Numpad5": "stoporfleeorlook",
    "Numpad6": "east",
    "Numpad7": "attack",
    "Numpad8": "north",
    "Numpad9": "up"
  }
}
