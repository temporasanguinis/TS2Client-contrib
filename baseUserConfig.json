{
  "version": 33,
  "versionMessage": "Il mapper ora dovrebbe mantenere la room a ingresso in gioco, printGrupo dovrebbe essere piu tollerante se non gli arriva json",
  "requiresClientMajor": 1,
  "requiresClientMinor": 4,
  "requiresClientRevision": 3,
  "text-color": "green-on-black",
  "wrap-lines": true,
  "utf8Enabled": false,
  "mxpEnabled": true,
  "enable-aliases": true,
  "enable-triggers": true,
  "font-size": "small-font",
  "font": "consolas",
  "colorsEnabled": true,
  "logTime": false,
  "debugScripts": false,
  "defaultAnsiFg": [
    "white",
    "low"
  ],
  "defaultAnsiBg": [
    "black",
    "low"
  ],
  "variables": [
    [
      "autoKillMobs",
      {
        "name": "autoKillMobs",
        "value": "guardia|armiere|statua golem|giardiniere|carceriere|brok capo carceriere|baltar capo cuoco|cuoco|grosso orso|strano giardiniere|falstaff incubo cavallo|pericoloso zombie|scheletro|taglialegna|grosso albero|cacciatore|commerciante assonnato guerriero|guardiaforestale|guardia forestale|orco scuro ladro|sailtril cuoco|guardiaforestale elfica|viandante viaggiatore|orso|elfo scuro addormentato guerriero|golem fulmini|welb monaco|serpente strisciante|fentig oscuro ranger|plint paladino|troll addormentato|angelo cacciatore|elementale fuoco grosso evocazione|panaj mastro druido|gnollo guerriero|salice piangente|efeliv druido elfo|seriev lizardman|fresius cacciatore|nikolaiv sacerdote|Desser titano guardiano|gigante colline|sinister titano guardiano|guardia geldor|spirito narhaeld|spirito midra|spirito alhart|spirito nithus|spirito erohar|spirito anisha|spirito runha|bandito banda|spirito nohel|essere non-morto|spirito bandito|spirito argha|spirito armidas|spirito eramos|spirito nathael|spirito narthas|spirito orothos|guardia villaggio cancello|guardia villaggio strade|abitante donna|abitante villaggio|forestiero viaggiatore|stalliere uomo|Igor sfregiato uomo|contadino uomo|vignaiolo|Baglio mugnaio|contadino donna|grappa cane capovillaggio|Garlos Manodiferro capovillaggio Toewin|vecchio portiere|guardia grigia|statua azzurra|anfitrione|blizzy|pontiere|comandante compagnia|albero marrone scuro|gigante tempeste|bart nano esploratore|monaco impazzito pericoloso|guardia scelta|eruvio magazziniere|kurt cuoco avamposto|Vertor capitanoavamposto|elfo scuro|poirot mercante|guardiaboschi|dron mercante|Eldrik taglialegna|ranger midia|custode magazziniere magazzino|faelin dei discendente|wegendel licantropo|keltor ranger elfo|albero antico morente|gigante nuvole generico|ertat elfo chierico|kevlar fabbro errante|angelo maggiore|angelo minore|Daff goodangel|enorme ciclope|golem roccia rossa|presenza malvagia|wight|drago bronzo|titano gigantesco|golem argento|matteo bardo|Falmer Elfo|Avventuriero|Gigante Colline|Guardia Whiterun|Guardia Riften|Guardia Windhelm|Guardia Winterhold|Guardia Dawnstar|Guardia Solitude|Guardia Markarth|Ragno-Skyrim|Nimhe|Guardia Falkreath|guardia lankar",
        "class": ""
      }
    ],
    [
      "dangerMobs",
      {
        "name": "dangerMobs",
        "value": "karoz barbaro errante",
        "class": ""
      }
    ],
    [
      "Mobs",
      {
        "name": "Mobs",
        "value": "",
        "class": ""
      }
    ],
    [
      "roundtime",
      {
        "name": "roundtime",
        "value": 4000,
        "class": ""
      }
    ],
    [
      "autokill",
      {
        "name": "autokill",
        "value": false,
        "class": ""
      }
    ],
    [
      "Immortal",
      {
        "name": "Immortal",
        "value": false,
        "class": ""
      }
    ],
    [
      "autofuryButton",
      {
        "name": "autofuryButton",
        "class": "",
        "value": "AutoFury"
      }
    ],
    [
      "renting",
      {
        "name": "renting",
        "class": "",
        "value": false
      }
    ],
    [
      "ImmortalTrigger",
      {
        "name": "ImmortalTrigger",
        "class": "",
        "value": false
      }
    ],
    [
      "initDone",
      {
        "name": "initDone",
        "class": "",
        "value": false
      }
    ]
  ],
  "script_events": [
    [
      "VariableChanged",
      [
        {
          "type": "VariableChanged",
          "condition": "Gruppo",
          "id": "printGruppo",
          "value": "send(\"printGruppo\");",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSTank",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSTankCond",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSMob",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSMobCond",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSSpells",
          "id": "",
          "value": "send(\"updateCombatStatus\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "Gruppo",
          "id": "checkAcl",
          "value": "if (classEnabled(\"autocleric\")) send(\"cura\");",
          "class": "autocleric",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSLag",
          "id": "checkAcl2",
          "value": "if (classEnabled(\"autocleric\")) send(\"cura\");",
          "class": "autocleric",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSGold,TSBank",
          "id": "",
          "value": "send(\"generaGold\");",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSTank,TSTankCond",
          "id": "checkAass",
          "value": "send(\"checkAssist\")",
          "class": "",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "Mobs,TSLag",
          "id": "",
          "value": "delay(\"mobchanged\", 20, ()=>{\n  if (this.Mobs && this.TSLag != \"+\") {\n      send(\"autokillcheck\")\n  }\n});",
          "class": "autokill",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSRoom",
          "id": "",
          "value": "print(\"Sei a: '\" + this.RoomName + \"', Vnum: \"+this.TSRoom);",
          "class": "debug",
          "enabled": true
        },
        {
          "type": "VariableChanged",
          "condition": "TSRoom",
          "id": "",
          "value": "this.pauseAutocleric = false;\nthis.preventAntispalm = false;\nif (this.temp_dice)\n  delete this.temp_dice;\ntoggleTrigger(\"dice\", false);\nsetTimeout(()=>send(\"onroomenter \" + this.TSRoom),0)\ndelay(\"aspettomapper\", 1, () => {\n  if (mapper.current) {\n      send(\"onroomenter \" + mapper.current.id)\n  }\n})",
          "class": "",
          "enabled": true
        }
      ]
    ],
    [
      "ConnectionState",
      [
        {
          "type": "ConnectionState",
          "condition": "telnet",
          "id": "",
          "value": "this.Mobs = \"\";\nsend(\"generaFunzioni\")",
          "class": "",
          "enabled": true
        }
      ]
    ]
  ],
  "triggers": [
    {
      "pattern": "^Tempora Sanguinis e l'Impero Celeste ti danno il benvenuto\\.|^Riconnessione in corso\\.",
      "id": "inizializzazione",
      "value": "if (line.indexOf(\"Riconnessione\")>-1) {\n  send(\"initialize\")\n}\ndelay(\"postinitialize\", 1000, () => this.postInit ? this.postInit() : false)\ntoggleClass(\"login\", false)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^   TUTTI GLI IMMORTALI|^Per avere una breve spiegazione dei comandi per Dei",
      "id": "",
      "value": "this.ImmortalTrigger = true;\nif (this.Immortal != true) {\n  this.Immortal = true\n  toggleClass(\"immortal\",true)\n  if (line.indexOf(\"Per avere\")>-1) {\n  \tthis.initDone = false\n    send(\"initialize\")\n    delay(\"postinitialize\", 1000, () => this.postInit ? this.postInit() : false)\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Connessione a \"Tempora Sanguinis",
      "id": "",
      "value": "send(\"preinit\")",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Sei a sedere! Non puoi farlo!|^Non sarebbe meglio che ti alzassi prima?",
      "id": "",
      "value": "this.seduto = true;\nif (!this.memorizing) {\n\tsend(\"stand\");\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ti alzi\\.|^Sei gia' in piedi\\.",
      "id": "",
      "value": "this.seduto = false;\nthis.alzando = false;\nif (this.memorizing) delete this.memorizing",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(\\([^)']+\\) )?(OT:)?\\[?([^\\]]+)?\\]?(?:Tu)? ?((?:ti )?[cC]hied[ei](?: a [^,]+)?,?|url[ai]|dic[ei] agli Eroi|(?:ti )?sussurr[ia](?: a [^,]+)?,?|dic[ei](?: a [^,]+,)?|dic[ei] al gruppo|(?:ti )?mand[ai] il pensiero(?: a [^,]+)?,|(?:ti )?mand[ai] il messaggio(?: a [^,]+)?,|ti dice) '(.*)'$",
      "id": "capSocial",
      "value": "function isMob(str) {\n  let mob = false;\n  if (str.toLowerCase().indexOf(\"strillone\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"dhethor\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"guardia \")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"matteo\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"elminster\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"eowarion\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"uno \")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"una \")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\"biff\")!=-1) mob = true;\n  if (str.toLowerCase().indexOf(\",\")!=-1) mob = true;\n  if (str.toLowerCase().startsWith(\"il \")) mob = true;\n  if (str.toLowerCase().startsWith(\"l'\")) mob = true;\n  if (str.toLowerCase().startsWith(\"la \")) mob = true;\n  if (str.toLowerCase().startsWith(\"lo \")) mob = true;\n  if (str.toLowerCase().startsWith(\"un \")) mob = true;\n  if (str.toLowerCase().startsWith(\"una \")) mob = true;\n  if (str.toLowerCase().startsWith(\"uno \")) mob = true;\n  return mob;\n}\nlet time=new Date().getHours()+\":\"+new Date().getMinutes();\nlet gtPg = (match[3]||\"Tu\").split(\"]\")[0];\nconst firstWord = gtPg.split(\"[\")[0].split(\" \")[0]\ngtPg = gtPg || \"Tu\";\nif (!isMob((match[3]||\"\")) &&\n  match[5].indexOf(\"(trigger)\")==-1 &&\n   match[0].indexOf(\"al gruppo\")==-1) {\n  //cap(\"Social\");\n  /*for (let i = 0; i < 6; i++) {\n    print(i + \":\" + match[i]);\n  }*/\n  let tipo = \"\";\n  gtPg = color(firstWord, \"lightgray\");\n  let textColor = \"yellow\"\n  if (match[2] && match[2]==\"OT:\") {\n    tipo=\"OT\"\n    textColor = \"yellowgreen\"\n  } else if (!match[3] && match[4].startsWith(\"Chiedi a \")) {\n    tipo=\"Ask\"\n    textColor=\"cyan\"\n    gtPg = \"Tu a \" + match[4].trim().replace(\"Chiedi a \",\"\").split(/[^a-z]/i)[0]\n    gtPg = color(gtPg, \"lightgray\");\n  } else if (match[1] && match[1].trim().startsWith(\"(\") && match[1].trim().endsWith(\")\")) {\n    tipo=\"Guild\"\n    textColor=\"#4eb2f9\"\n  } else if (match[4] && match[4].trim()==\"urli\" && match[3] && match[3].trim()==\"Tu\") {\n    tipo=\"Shout\"\n    textColor=\"red\"\n  } else if (match[4] && match[4].trim()==\"dici agli Eroi\" && match[3] && match[3].trim()==\"Tu\") {\n    tipo=\"Hero\"\n    textColor=\"yellow\"\n  } else if (match[4] && match[4].trim()==\"dici\" && match[3] && (match[3].trim()==\"Tu\" || match[3].trim()==\"Con i segni\")) {\n     if (match[3].trim().endsWith(\"i segni\")) {\n      \ttipo=\"Sign\"\n    \ttextColor=\"yellowgreen\"\n       gtPg = color(\"Tu\", \"lightgray\");\n    } else {\n    \ttipo=\"Gos\"\n    \ttextColor=\"yellow\"\n    }\n  } else if (match[4] && match[4].trim()==\"dice\" && match[3] && !match[3].trim().endsWith(\"ti\")) {\n    if (match[3].trim().endsWith(\"con i segni\")) {\n      \ttipo=\"Sign\"\n    \ttextColor=\"yellowgreen\"\n    } else {\n    \ttipo=\"Gos\"\n    \ttextColor=\"yellow\"\n    }\n  } else if (match[4] && match[4].trim()==\"ti chiede\") {\n    tipo=\"Ask\"\n    textColor=\"cyan\"\n  } else if (match[4] && match[4].trim()==\"dice agli Eroi\") {\n    tipo=\"Hero\"\n    textColor=\"yellow\"\n  } else if (match[4] && match[4].trim()==\"urla\") {\n    tipo=\"Shout\"\n    textColor=\"red\"\n  } else if (match[4] && match[4].trim()==\"ti manda il pensiero,\") {\n    tipo=\"Tele\"\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim()==\"ti manda il messaggio,\") {\n    tipo=\"Mess\"\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"ti dice\")) {\n    tipo=\"Tell\"\n    let tmp = match[3].trim().split(/[^a-z]/i)[0]\n    gtPg=color(tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"dici a \")) {\n    tipo=\"Tell\"\n    let tmp = match[4].trim().replace(\"dici a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"mandi il messaggio a \")) {\n    tipo=\"Mess\"\n    let tmp = match[4].trim().replace(\"mandi il messaggio a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"mandi il pensiero a \")) {\n    tipo=\"Tele\"\n    let tmp = match[4].trim().replace(\"mandi il pensiero a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"sussurri a \")) {\n    tipo=\"Suss\"\n    let tmp = match[4].trim().replace(\"sussurri a \",\"\").split(/[^a-z]/i)[0]\n    gtPg=color(\"Tu a \"+tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  } else if (match[4] && match[4].trim().startsWith(\"ti sussurra,\")) {\n    tipo=\"Suss\"\n    let tmp = match[3].trim().split(/[^a-z]/i)[0]\n    gtPg=color(tmp, \"lightgray\");\n    textColor=\"#8b00dd\"\n  }\n  if (match[5]==\"ping\" && gtPg.indexOf(\"Tu \")==-1) {\n    print(\"Ti sta cercando \" + gtPg + \"!\")\n    switch (tipo) {\n      case 'Tele':\n      case 'Mess':\n      case 'Tell':\n        playAudio(\"./sounds/disconnect.ogg\")\n        break;\n    }\n  }\n  tipo=color(tipo, \"lightgray\")\n  let detto = color(match[5], textColor);\n  if (this.afk) {\n    time=color(\"@\" +time,\"gray\");\n  } else {\n    time=\"\";\n  }\n  print(`[${tipo}]${time}:${gtPg}> ${detto}`,\"Social\")\n}\nif (!isMob((gtPg||\"\")) &&\n  match[5].indexOf(\"(trigger)\")==-1) {\n  if (match[0].indexOf(\"al gruppo\")!=-1) {\n    gtPg = color(firstWord+\":\", \"lightgray\");\n    let detto = color(\" \"+match[5], \"#6060FF\");\n    print(`${gtPg}`,\"Group Tell\")\n  \tprint(`${detto}`,\"Group Tell\")\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^([\\w\\- \\']+) inizia a seguirti",
      "id": "",
      "value": "  let pg = this.cleanupName(match[1]);\n  send(\"group \"+ pg)\n",
      "regex": true,
      "is_script": true,
      "class": "autogroup",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Hai fame.|Hai sete.)",
      "id": "",
      "value": "if (this.feastTimeout) {\n  clearTimeout(this.feastTimeout);\n}\n// il random e' in caso qualcun altro faccia feast nel frattempo\nthis.feastTimeout = setTimeout(()=> {\n  if (!this.feastFatto) {\n    if (this.healtype==\"C\" || this.canPlay) {\n      send(\"cast 'hero'\")\n    } else {\n      send(\"feast\");\n    }\n  }\n  this.feastFatto = false;\n}, (Math.round(Math.random()*10) * 1000));",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Prendi parte ad un magnifico banchetto preparato da",
      "id": "",
      "value": "this.feastFatto = true;",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(La campana benedetta della chiesa di Midia marca un'altra ora.|Un altro granello di sabbia scivola nella clessidra di Martinus.|La clessidra astrale viene capovolta nuovamente.|Ti accorgi che un'altra ora e' passata.|Un'altra pagina dell'eterna storia dell'Impero Celeste e' stata scritta.)",
      "id": "tickTrigger",
      "value": "send(\"tickProc\");",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ti perdi nei tuoi pensieri",
      "id": "",
      "value": "~afk",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^C'erano (\\d+) monete\\.",
      "id": "",
      "value": "if (this.pgInGruppo().length > 1) {\n\tsend(\"split \" + match[1])\n}",
      "regex": true,
      "is_script": true,
      "class": "autosplit",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.*) (si immerge nello stagno\\.|entra in un Portale Luminoso, e scompare!|chiude gli occhi e sparisce all'istante)",
      "id": "stagno_portale",
      "value": "if (this.Gruppo && this.Gruppo.length && this.autofollow) {\n  if (this.isCapogruppo(match[1].split(\" \")[0])) {\n    if (match[2].indexOf(\"stagno\")!=-1) {\n      send(\"es\");\n    } else if (match[2].indexOf(\"sparisce\")!=-1) {\n      if (this.healtype.indexOf(\"C\")>-1 || this.canPlay)\n        send(\"+word\");\n      else\n        send(\"rec rito\");\n    } else {\n      send(\"ep\");\n    }\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "autofollow",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.*) ti ordina '(.*)'",
      "id": "order",
      "value": "if (this.isCapogruppo(match[1]) && this.autoorder) {\n  this.parlaStato = true;\n    send(\"followorder \" + match[2]);\n  this.parlaStato = this.afk;\n}",
      "regex": true,
      "is_script": true,
      "class": "autoorder",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Smetti di seguire",
      "id": "",
      "value": "soloSettings",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Sei entrat(o|a) a far parte del gruppo di",
      "id": "",
      "value": "send(\"groupSettings\");\nthis.listaAutosanc = [];",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^\\[(.+)\\] dice al gruppo '(\\w+)\\:(.+)'",
      "id": "orderGt",
      "value": "if (this.autoorder && this.isCapogruppo(match[1]) &&\n    (match[2] == \"tutti\" || this.TSPersonaggio.toLowerCase().indexOf(match[2].toLowerCase())==0)) {\n  this.parlaStato = true;\n  send(\"followorder \"+match[3].trim());\n  this.parlaStato = this.afk;\n}",
      "regex": true,
      "is_script": true,
      "class": "order",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^L'aura rossa intorno al tuo corpo svanisce",
      "id": "",
      "value": "if (this.selfshield) {\n  setTimeout(()=>{\n  \tsend(\"fs\");\n  }, 2000);\n}",
      "regex": false,
      "is_script": true,
      "class": "selfshield",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(La Luce Divina smette di illuminarti|La Natura smette di proteggerti)",
      "id": "triggerSelfsanc",
      "value": "if (this.selfsanc && (this.healtype==\"C\" || this.TSSettore!=\"Chiuso\")) {\n   setTimeout(()=>{\n    if (this.TSSpells.toLowerCase().indexOf(\"s\") != -1) return;\n    if (this.healtype==\"C\" && (!this.casttype||this.casttype==\"C\") && !this.canBash && !this.canStab && this.pgInGruppo()?.length>1) {\n      send(\"pray gard\");\n    } else {\n  \t\tsend(\"sanc\");\n    }\n  }, 1000);\n}",
      "regex": true,
      "is_script": true,
      "class": "selfsanc",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(?:La Luce Divina smette di illuminare (?<nome>[^.]+)|L'aura di protezione attorno a (?<nome2>[^.]+) si dissolve|La Natura smette di proteggere (?<nome3>[^.]+))",
      "id": "triggerAutosanc",
      "value": "let pg = match.groups.nome || match.groups.nome2 || match.groups.nome3;\nlet druid = match.groups.nome2 || match.groups.nome3;\nif (druid && this.healtype==\"D\" ||\n    !druid && this.healtype==\"C\") {\n  pg = this.titleCase(pg.split(\" \")[0]);\n  if (this.listaAutosanc.indexOf(pg)!=-1) {\n      if (!this.nosanc) this.nosanc={};\n      if (this.nosanc[pg]) return;\n      this.nosanc[pg]=true\n      send(\"sanc \" + pg);\n      setTimeout(()=>{\n        delete this.nosanc[pg]\n      },10000);\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "autosanc",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Il tuo gruppo e' stato rimosso",
      "id": "",
      "value": "soloSettings",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Il tuo allineamento e'\\: \\w+ \\(([^\\)]+)\\)",
      "id": "",
      "value": "this.diciStatus(\"Align: \" + match[1]);\ntoggleClass(\"gtalign\", false)",
      "regex": true,
      "is_script": true,
      "class": "gtalign",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Spiacente, non c'e' spazio per entrare li'",
      "id": "",
      "value": "sayStatus Non c'e' spazio per entrare li'!",
      "regex": false,
      "is_script": false,
      "class": "indietro",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) (va|vola) verso",
      "id": "",
      "value": "if (this.preventCheckRimastoIndietro) {\n  this.preventCheckRimastoIndietro=false;\n  return;\n}\nif (this.isCapogruppo(match[1])) {\n  this.checkRimastoIndietro = true;\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Segui (.+)\\.",
      "id": "",
      "value": "if (this.isCapogruppo(match[1])) {\n  this.checkRimastoIndietro = false;\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Intravedi (.+) nel corpo di",
      "id": "lootRandomPop",
      "value": "print(color(\"&lt;&lt; -- INTRAVEDO LOOT !!! -- &gt;&gt;\",\"black\",\"yellow\",true, true, true));  \n/*if (this.pgInGruppo().length < 2 || this.isCapogruppo(this.TSPersonaggio)) {\n  let loot = \"\";\n  if (match[1].toLowerCase().indexOf(\"cristallo\")!=-1) loot = \"cristallo\";\n  if (match[1].toLowerCase().indexOf(\"gemma\")!=-1) loot = \"gemma\";\n  if (match[1].toLowerCase().indexOf(\"sangue\")!=-1) loot = \"goccia\";\n  if (match[1].toLowerCase().indexOf(\"ramo\")!=-1) loot = \"ramo\";\n  if (loot.length) {\n    send(`get ${loot} corpo`);\n    send(`get ${loot} ossa`);\n  }\n}*/",
      "regex": true,
      "is_script": true,
      "class": "autoloot|random",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Spiacente, quella locazione e' privata|Spiacente, non c'e' spazio per entrare li)",
      "id": "",
      "value": "if (this.grandezzaGruppo > 1) {\n  delay(\"privata\", 1000, () => send(\"gtTrigger Non c'e' spazio per seguire!\"));\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Ma se non sei alla tastiera, dove vuoi andare?",
      "id": "",
      "value": "~afk",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Con una rapida mossa della sua arma, (.+) colpisce con decisione il tuo braccio|(.+) esegue un rapido calcio, che va a colpire la tua mano con estrema precisione)",
      "id": "",
      "value": "if (this.ultimaArma == \"null\") {\n  this.ultimaArma = null;\n}\nif (!this.ultimaArma && this.armaPrimaria) {\n  const armi = [this.armaBlunt,this.armaSlash,this.armaPierce]\n  for (let arma of armi) {\n    print(arma)\n    if (arma && arma != this.armaPrimaria) send(\"~wie \" + arma)\n  }\n  send(\"wield \" + this.armaPrimaria)\n} else {\n  send(\"wie \" + this.ultimaArma);\n}",
      "regex": true,
      "is_script": true,
      "class": "combat",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^!?H:.*\\>",
      "id": "gagprompt",
      "value": "gag();",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": false,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^La Luce Divina che ti illumina inizia ad attenuarsi.",
      "id": "",
      "value": "if (window.sancTimeout) {\n  clearTimeout(window.sancTimeout);\n  window.sancTimeout = null;\n}\nwindow.sancTimeout = setTimeout(()=>{\n  this.scadenzaSanc = true;\n  window.sancTimeout = null;\n},100000);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^L'aura rossa intorno al tuo corpo inizia a sbiadire.",
      "id": "",
      "value": "if (window.scudoTimeout) {\n  clearTimeout(window.scudoTimeout);\n  window.scudoTimeout = null;\n}\nwindow.scudoTimeout = setTimeout(()=>{\n  this.scadenzaScudo = true;\n  window.scudoTimeout = null;\n},100000);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Chi\\?|Pugnalare chi\\?|Nessuno con quel nome qui)",
      "id": "",
      "value": "if (this.autokill)\n  send(\"look\");",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Ricevi|Ricevi la parte di esperienza di|La tua parte di esperienza e' di) ([^\\d]+)?(in )?(\\d+) punti",
      "id": "",
      "value": "let quantita = Number(match[4])\nthis.stat(\"XP\", quantita/1000000)\nif (isNaN(this._stat_xpsess)) this._stat_xpsess=0;\nthis._stat_xpsess+=quantita/1000000;",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Ricevi (\\d+) [Ss]igilli (?:del |dell' ?|della )?(\\w+)",
      "id": "",
      "value": "const tipo = match[2].toLowerCase()\nconst quantita = Number(match[1])\nswitch (tipo) {\n  case 'divini':\n    this.TSSigDivini = Number(this.TSSigDivini)+quantita;\n    this.stat(\"Divini\", quantita)\n    if (!this._stat_pqsess) this._stat_pqsess=0;\n    this._stat_pqsess+=quantita;\n    break;\n  case 'terra':\n    this.TSSigTerra = Number(this.TSSigTerra)+quantita;\n    this.stat(\"Terra\", quantita)\n    break;\n  case 'aria':\n    this.TSSigAria = Number(this.TSSigAria)+quantita;\n    this.stat(\"Aria\", quantita)\n    break;\n  case 'acqua':\n    this.TSSigAcqua = Number(this.TSSigAcqua)+quantita;\n    this.stat(\"Acqua\", quantita)\n    break;\n  case 'fuoco':\n    this.TSSigFuoco = Number(this.TSSigFuoco)+quantita;\n    this.stat(\"Fuoco\", quantita)\n    break;\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Hai smesso di combattere\\.$",
      "id": "",
      "value": "this.TSTank=\"\";\nthis.TSTankCond=\"\";\nthis.TSMob=\"\";",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Il freddo che (.+) emette ti congela!",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"ic\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) ti colpisce con la sua palla di fuoco! - OUCH",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"if\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Urli di dolore quando vieni colpit[oa] dall'elettricita' di",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"ie\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Non riesci ad evitare l'attacco acido di",
      "id": "",
      "value": "if (!this.preventAntispalm) {\n  send(\"ia\");\n  this.preventAntispalm=true\n}",
      "regex": true,
      "is_script": true,
      "class": "antispalm",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Fallisci il tuo tentativo di salvataggio",
      "id": "",
      "value": "this.TSTank=\"\"\nthis.TSMob=\"\"",
      "regex": false,
      "is_script": true,
      "class": "autorescue",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Manchi (.+)\\.",
      "id": "",
      "value": "if (!this.missARound) this.missARound = 0;\nif (!this.cambiArma) {\n  this.cambiArma = 0;\n  this.impugnatoArma=true;\n}\nthis.missARound++;\nif (this.cambiArma<2 && this.impugnatoArma==true) {\n  if (this.missARound>=Number(this.numeroAttacchi)) {\n    this.cambiArma++;\n    this.impugnatoArma = false;\n    rotazioneArmi()\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "autoarmi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^!?H:.*\\>",
      "id": "",
      "value": "this.missARound = 0;",
      "regex": true,
      "is_script": true,
      "class": "autoarmi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.*) e' morto|a! R\\.I\\.P\\.",
      "id": "",
      "value": "this.cambiArma = 0;\nthis.impugnatoArma=true;\nthis.Mobs = \"\";\nthis.returnRoom = null;\nthis.stabTarget = null;\nthis.preventAntispalm = false;\nthis.disableCheckAssist=false;\nthis.preventAutoassist=false;\nif (this.autokill) {\n\tdelay(\"aklook\", 1000, () => send(\"look\"));\n}\nif (this.armaPrimaria && this.autoarmi && (this.zoneDaNonRimettereArma||0).toString()!=\"0\") {\n  delay(\"rimettiArma\",1000,()=>{\n    if (this.inCombat()) return;\n    let nozone = (this.zoneDaNonRimettereArma||\"\").split(\",\")\n    for (let z of nozone) {\n      if (Math.floor(Number(this.TSRoom)/100)==Math.floor(Number(z)/100)) {\n        return;\n      }\n    }\n    if (this.ultimaArma != this.armaBlunt && this.armaPrimaria==\"blunt\") {\n      send(\"blunt\")\n    }\n    else if (this.ultimaArma != this.armaSlash && this.armaPrimaria==\"slash\") {\n      send(\"slash\")\n    }\n    else if (this.ultimaArma != this.armaSlash && this.armaPrimaria==\"pierce\") {\n      send(\"pierce\")\n    }\n  });\n}",
      "regex": true,
      "is_script": true,
      "class": "kill",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Impugni (.+)\\.",
      "id": "",
      "value": "this.impugnatoArma = true;",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Un'ENORME creatura esce fuori dal pozzo e spalanca le sue|Vhal il maledetto e' qui, in piedi)",
      "id": "",
      "value": "this.preventAntispalm=true;\nif (this.antispalm) {\n  if (!this.roomNoAntispalm)this.roomNoAntispalm=[];\n  if (this.roomNoAntispalm.indexOf(this.TSRoom)==-1) {\n    this.roomNoAntispalm.push(this.TSRoom);\n  }\n  send(\"ia\");\n}",
      "regex": true,
      "is_script": true,
      "class": "draghi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(L'enorme Leviathan e' qui, custode di antichi segreti|Un enorme drago bianco anziano si sta riposando qui|Un gigantesco wyrm bianco si sta riposando qui|L'Immensa Armeria)",
      "id": "",
      "value": "this.preventAntispalm=true;\nif (this.antispalm) {\n  if (!this.roomNoAntispalm)this.roomNoAntispalm=[];\n  if (this.roomNoAntispalm.indexOf(this.TSRoom)==-1) {\n    this.roomNoAntispalm.push(this.TSRoom);\n  }\n  send(\"ic\");\n}",
      "regex": true,
      "is_script": true,
      "class": "draghi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) improvvisamente se ne va, correndo piu' veloce che puo'!",
      "id": "",
      "value": "if (this.isCapogruppo(match[1])) {\n\tthis.preventCheckRimastoIndietro=true;\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^\\[( 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22)\\] .+\\((ottimo|molto buono|buono|a pezzi|discreto)\\)$",
      "id": "",
      "value": "if (!this.oggettiRovinati || !this.oggettiRovinati.push) {\n  this.oggettiRovinati = [];\n}\nthis.oggettiRovinati.push(match[1].trim())",
      "regex": true,
      "is_script": true,
      "class": "fixxa",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) evita con agilita' l'attacco.$",
      "id": "",
      "value": "this.missARound--;",
      "regex": true,
      "is_script": true,
      "class": "autoarmi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^In questo tick stai memorizzando (\\d+) incantesimi, di un totale di (\\d+)",
      "id": "",
      "value": "this.memorizeATick = Number(match[2])",
      "regex": true,
      "is_script": true,
      "class": "memorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Puoi memorizzare un incantesimo (\\d+) volte, per un totale di (\\d+) incantesimi",
      "id": "",
      "value": "this.memorizeMaxPerSpell=Number(match[1])\nthis.memorizeMaxLibro=Number(match[2])\ndelay(\"memo\",500,()=>{\n    toggleClass(\"memorize\",false)\n  });",
      "regex": true,
      "is_script": true,
      "class": "memorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Pronunci le parole, '([^']+)'\\.$",
      "id": "",
      "value": "if (!this.spellMemmati) return;\nlet spell=match[1].toLowerCase()\nspell = Object.keys(this.spellMemmati).find(k=>k==spell||spell.startsWith(k))\nif (!spell) {\n   return;\n}\nthis.spellMemmati[spell]--;\n\nif (this.spellMemmati[spell]==0) {\n  print(color(`Hai finito: '${spell}'`, \"black\", \"gray\", true, false, true))\n} else {\n  print(color(`Ti rimangono: ${this.spellMemmati[spell]} ${spell}`, \"yellow\", null, true, false, false))\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^\\[(.+)\\] (.+)  \\(Imparato\\) x(\\d+)",
      "id": "",
      "value": "if (!this.spellMemmati || this.spellMemmati.length) {\n  this.spellMemmati = {};\n}\n\nthis.spellMemmati[match[2]] = Number(match[3])\n",
      "regex": true,
      "is_script": true,
      "class": "memorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) e' stato ucciso da (.+) a (.+)\\.$",
      "id": "",
      "value": "cap(\"Social\");",
      "regex": true,
      "is_script": true,
      "class": "social",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.*) ti cade dalle mani$",
      "id": "",
      "value": "if (this.holdItem) send(`hold ${this.holdItem}`);\n",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^E ti casca anche (.*)!$",
      "id": "",
      "value": "if (this.ultimaArma) send(`wield ${this.ultimaArma}`);",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Apri il tuo libro e inizi a leggere e meditare",
      "id": "iniziomemorize",
      "value": "toggleTrigger(\"iniziomemorize\", false)\ndelay(\"iniziomemorize\",4000,()=>{\n  toggleTrigger(\"iniziomemorize\", classEnabled(\"automemorize\"))\n});\nlet now = new Date();\nvar dif = Math.round((now.getTime() - this.lastTickTime.getTime())/1000);\nif (dif < 10 && this.automemo) {\n  print(\"Sembra che automemorize sia andato a brutto fine. Synco il libro.\")\n  send(\"stand;mem\")\n}",
      "regex": false,
      "is_script": true,
      "class": "automemorize",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Devi usare 'recall' per questo incantesimo",
      "id": "",
      "value": "if (this.ultimoSpellCastato) {\n  if (!this.spellDaRecallare) this.spellDaRecallare=[];\n  this.spellDaRecallare.push(this.ultimoSpellCastato);\n  print(\"Segnato \" + this.ultimoSpellCastato + \" come spell da Sorcerer, lo recallo.\")\n  if (this.ultimoSpellCastato) {\n    send(`cast '${this.ultimoSpellCastato}' ${this.ultimoTargetSpell}`)\n  \tdelete this.ultimoSpellCastato;\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Doni parte della tua energia magica|(.+) esegue un complesso rituale ed invoca l'aiuto del dio)",
      "id": "",
      "value": "send(\"autosanc off\")",
      "regex": true,
      "is_script": true,
      "class": "autosanc",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) esegue un complesso rituale ed invoca l'aiuto del dio Nalith\\. La stanza si riempie di luce",
      "id": "",
      "value": "selfsanc off\nautosanc off",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ti allontani dalla tastiera",
      "id": "",
      "value": "~afk",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Ahi ahi, non puoi andare da quella parte|^.+ non si apre\\.|^Hai fallito a forzare la serratura\\.",
      "id": "",
      "value": "mapper.virtualCurrent = null;\nmapper.acknowledgingWalkStep = false;\nif (mapper.manualSteps&&mapper.manualSteps.length) {\n\tmapper.manualSteps = []\n}\nif (mapper.currentWalk) mapper.failWalk(\"Percorso fallito.\")",
      "regex": true,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Fuggi a tutta velocita'\\.|^Con abilita' ti ritiri dalla battaglia\\.",
      "id": "",
      "value": "if (!this.stabTarget) send(\"autoassist false\");",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[Dhethor il questor\\] dice 'Cerca nei paraggi di (.*?)\\.",
      "id": "",
      "value": "if (this.questorPg && this.TSPersonaggio &&\n   this.questorPg.toLowerCase() == this.TSPersonaggio.toLowerCase()) {\n  print(\"Room quest: \" + $1)\n  let res = mapper.searchRoomsByNameAndDesc($1)\n  res = res.filter(r => r.name === $1)\n  this.searchRooms = () => res\n  send(\"ricercaPrecedente\")\n} else {\n  toggleClass(\"questor\", false)\n}",
      "regex": true,
      "is_script": true,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Una (verga) carica di potere levita ad un palmo da terra\\.|^Una (spada) dalla lama formata da fiamme bianche giace qui\\.|^Una (mappa) arrotolata giace qui nella polvere\\.|^Una (bilancia) in equilibrio precario e' posata qui\\.|^Un'(ascia) con incisioni di draghi sulla lama e' piantata in terra\\.|^Un (ramo) d'alloro e' piantato a terra qui\\.|^un (medaglione) sacro ai cinque Dei creatori del mondo giace qui\\.|^Un (elmo) fatto di puro cristallo e' posato qui\\.|^Un (corno) da caccia in argento e' posato qui\\.|^Questa (pietra) e' tutto cio' che rimane della citta' di Lamwothor\\.|^Due (fedi) in oro sono qui posate su un cuscino\\.|^Un'antica moneta d'oro ti attira, ma hai un cattivo presentimento\\.",
      "id": "",
      "value": "let obj = null;\nfor (let i = 1; i<12; i++) {\n\tif (match[i]) {\n    \tobj = match[i]\n      \tbreak\n    }\n}\n\nobj = obj || \"doblone\"\nsend(\"get \"+obj)\nthis.questComplete=true\nsend(\"vai dhethor\")",
      "regex": true,
      "is_script": true,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(Dhethor, il questor, e' qui in attesa di volontari|Dichiari a Dhethor il questor di aver completato la tua missione)",
      "id": "",
      "value": "if (this.questComplete) {\n\tthis.questComplete = false\n  \tthis.searchRooms = null;\n\tsend(\"quest complete\")\n}\ntoggleClass(\"questor\", false);",
      "regex": true,
      "is_script": true,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[Dhethor il questor\\] dice 'e chiedono a te, (.+?), di recuperare",
      "id": "",
      "value": "this.questorPg = $1\nif (this.questorPg.toLowerCase() == $1.toLowerCase()) {\n\ttoggleClass(\"questor\",true)\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[Dhethor il questor\\] dice 'Vai a riposarti un po'",
      "id": "",
      "value": "quest time",
      "regex": true,
      "is_script": false,
      "class": "questor",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Senti una leggera vibrazione e il mondo intorno a te cambia",
      "id": "",
      "value": "look",
      "regex": false,
      "is_script": false,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(.+) ha perso il senso della realta'\\.",
      "id": "",
      "value": "if (!this.Immortal) send(\"emote dice: $c5115\" + $1.split(\" \")[0] + \"$c0015 ha perso la connessione!$c0007\")",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Vedi chiaramente (.+)!",
      "id": "",
      "value": "delay(\"aklook\", 500, () => send(\"look\"));",
      "regex": true,
      "is_script": true,
      "class": "autokill",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^Premi \\<Invio\\>\\:",
      "id": "",
      "value": "send(\" \", true)",
      "regex": true,
      "is_script": true,
      "class": "login",
      "enabled": true,
      "is_prompt": true,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^    Fai la tua scelta\\:",
      "id": "",
      "value": "send(\"i\")\nsend(\"initialize\")\ntoggleClass(\"login\", false)",
      "regex": true,
      "is_script": true,
      "class": "login",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Sogni di perdere l'abilita' '(.+)'",
      "id": "",
      "value": "send(\"gos Feeblato da Sauron! Addio a: '\" + $1 + \"'.\")",
      "regex": true,
      "is_script": true,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) usa il suo potere ipnotico su di te e tu ti addormenti",
      "id": "",
      "value": "wake\nstand",
      "regex": true,
      "is_script": false,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) evoca (.+) in suo aiuto",
      "id": "",
      "value": "gt $c0015Poppata OMBRA di Melkor$c0007!!",
      "regex": true,
      "is_script": false,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Vedi qualcosa luccicare tra le ceneri di Sauron",
      "id": "",
      "value": "gt Poppato PEZZONE DI MORDOR!!!",
      "regex": true,
      "is_script": false,
      "class": "mordor",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Cerchi di ispirarti, ma fallisci!|Ispirazione a ..%)",
      "id": "",
      "value": "const doInspire = () => {\n  delay(\"autoinspire\", 6000, () => {\n      if (this.TSLag==\"+\") {\n      \tdoInspire();\n      } else {\n      \tif (!this.renting) send(\"inspire\")\n      }\n  });\n};\ndoInspire();",
      "regex": true,
      "is_script": true,
      "class": "autoinspire",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Ti senti stanco e continui a suonare|Stai suonando troppo lentamente|Cominci a intonare alcune note di '(.+)'\\.|Continui a intonare la melodia portando l'armonia a ...?%)",
      "id": "",
      "value": "let playDelay = 5000\nif (line.indexOf(\"100%\")>-1) {\n    playDelay = 6000\n}\nif (line.indexOf(\"lentamente\")>-1) {\n    playDelay = 1000\n}\nif (line.indexOf(\"Cominci a intonare\")>-1) {\n  this.ultimaSong = $2\n  if (!this.autosong) return;\n  delay(\"playstart\", 2000, () => {if (this.autosong && !this.renting) send(\"play '\" + this.ultimaSong + \"'\")})\n  playDelay = 7000\n}\nif (!this.autosong) return;\ndelay(\"play\", playDelay, () => {if (this.autosong && !this.renting) send(\"play '\" + this.ultimaSong + \"'\")})",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Non riesci piu' a suonare, devi prendere fiato",
      "id": "",
      "value": "send(\"cast seco \" + this.TSPersonaggio)",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "E' finito il tuo collegamento con il mistico",
      "id": "",
      "value": "send(\"cast myst\")",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "La pratica musicale ti viene meno.",
      "id": "",
      "value": "send(\"cast music\")",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "La tua fiamma spirituale si spegne",
      "id": "",
      "value": "send(\"focus\")",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^.*mette da parte i tuoi oggetti",
      "id": "",
      "value": "this.renting = true",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Non hai abbastanza energia magica|Sei in una zona silenziosa, non puoi emettere suoni|La zona assorbe la tua magia|Questo incantesimo non ha effetto qui)",
      "id": "",
      "value": "if (classEnabled(\"autocleric\")) {\n  this.pauseAutocleric = true\n  print(\"Sei senza mana o in silence... pauso autocleric per 20 secondi.\")\n  delay(\"reset_acl\", 20000, () => {\n    this.pauseAutocleric = false\n    const lag = this.TSLag;\n    this.TSLag = \"\";\n    delay(\"reset_acl2\", 100, ()=>{ this.TSLag = lag; });\n  })\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+) (con destrezza si ritira dalla battaglia|e' preso dal panico, e cerca di fuggire)",
      "id": "",
      "value": "if (this.isCapogruppo(match[1])) {\nthis.preventCheckRimastoIndietro=true;\n}",
      "regex": true,
      "is_script": true,
      "class": "indietro",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Prendi un sacco",
      "id": "",
      "value": "send(\"get palanchino sacco;drop sacco\");",
      "regex": true,
      "is_script": true,
      "class": "zone:108",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "C'e' troppa gente! Non riesci ad avvicinarti!",
      "id": "",
      "value": "this.preventAutoassist = true;\nsetTimeout(() => {\n this.preventAutoassist = false;\n  send(\"checkAssist\")\n}, 3000)",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\*\\*\\* (.+)$",
      "id": "",
      "value": "print($1, \"Logs\")\ngag()",
      "regex": true,
      "is_script": true,
      "class": "immortal",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Un globo di energia appare dal nulla, inizia a mutare forma e si anima magicamente",
      "id": "",
      "value": "gt POPPATO NEGOZIANTE",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Smetti di memorizzare e chiudi il tuo libro degli incantesimi",
      "id": "",
      "value": "this.finito_memmare = true;",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[.\\d{1,2}\\] ([^([]+)( \\(|\\[\\d+\\]|)",
      "id": "ident_inv",
      "value": "var util = window.dbIdentUtil;\nlet descshort = match[1].trim();\nlet r = util.withshort(descshort);\nif (util.debug() && r.length>0) {console.log(\"Item trovato: nel trigget ident_inv:\" + match[1])}\nif (r.length>0) {\n  let firstword = $1;\n  const spaceIndex = firstword.indexOf(\" \");\n  if (spaceIndex>-1) {\n    firstword = firstword.substring(0, spaceIndex);\n  }\n\n  let testoident = ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]==\"\")) ?\n      color(\"[?]\",\"maroon\") : color(\"[?]\",\"green\");\n\n  //sub(firstword, link(testoident,()=>{print(out)},\"vedi identify\") + \" \" + firstword);\n  sub(firstword, link(testoident,()=>{\n    let out = util.getStringIdents(r);\n    print(out)\n  },\"vedi identify\") + \" \" + firstword);\n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.*)$",
      "id": "roomContent",
      "value": "//Normalmente NON abilitato.\n//Viene abilitato da altri trigger/alias\n\nif (match[0] == \"\" || \n    match[0] == \"-----------------\" || \n    match[0].search(/^H:\\[\\d+\\/\\d+\\] M:\\[\\d+\\/\\d+\\] V:\\[\\d+\\/\\d+\\]/)>-1) {\n\ttoggleTrigger(\"roomContent\",false);\n  toggleTrigger(\"infoquestContent\",false);\n} else {\n    var util = window.dbIdentUtil;\n    let desclong = match[1];\n  \t//se presente alla fine (condizioni) lo tolgo\n    let m = desclong.match(/([^(]+)(?=\\()/);\n\t  if (m != null) {desclong = m[1]};\n    //se pezzi multipli con [] a inizio e fine le tolgo\n\t  m = desclong.match(/^(?:\\[..\\] |)(.+?)(?:\\[\\d+\\]|)$/);\n    if (m != null) {desclong = m[1]}; \n    desclong = desclong.trim()\n    if (util.debug()) {console.log(\"Item trovato nel trigger roomContent:\" + desclong)}\n    if (desclong == \"\") return; //Mikko 231119 Bugfix per gli oggetti che hanno desclong vuota\n    let r = util.withlong(desclong);\n    if (r.length>0) {\n      //const start = performance.now(); //PROFILAZIONE      \n      let firstword = $1;\n      const spaceIndex = firstword.indexOf(\" \");\n      if (spaceIndex>-1) {\n      \tfirstword = firstword.substring(0, spaceIndex);\n      }\n      let testoident = ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]==\"\") ) ?\n          color(\"[?]\",\"maroon\") : color(\"[?]\",\"green\");\n      \n      sub(firstword, link(testoident,()=>{\n        let out = util.getStringIdents(r);\n        print(out)\n      },\"vedi identify\") + \" \" + firstword);\n      //const duration = performance.now() - start; //PROFILAZIONE\n      //print(\"Profilazione: \" + duration, \"Social\"); \n    }  \n}\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(.+)$",
      "id": "identContent",
      "value": "//Normalmente NON abilitato.\n//Viene abilitato da altri trigger/alias\n\nwindow.identText +=  match[0] + \"\\n\";\n//print(window.identText + \"\\n\\n\", \"Social\");",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Percepisci le informazioni:",
      "id": "",
      "value": "toggleTrigger(\"identContent\", true);\nwindow.identText = \"\";\nif (typeof window.dbIdentUtil === \"undefined\") {send(\"ident_init\");}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Non percepisci altre informazioni sull'oggetto.",
      "id": "",
      "value": "toggleTrigger(\"identContent\", false);\nlet identText = window.identText;\n\nvar util = window.dbIdentUtil;\nvar ultimoMobUcciso = window.ultimoMobUcciso;\n\n//tolgo l'ultima riga perchè contiene la scritta Non percepisci... che devo escludere dall'ident.\nidentText = identText.substr(0,identText.search(\"Non percepisci altre informazioni sull'oggetto\")-1);\nlet obj = util.parseident(identText);             \n           \n    \n                  \n//cerco se esiste già nel db\nlet found = util.find({\"Oggetto\":obj.Oggetto,\n           \"DescrizioneShort\":obj.DescrizioneShort,\n           \"DescrizioneLong\": obj.DescrizioneLong});\n\nlet hasprovenienza=false;\nutil.autoprovenienzaclear();\nutil.autoprovenienza.area = mapper.current?.zone_id ?? \"\";\n\nif (found != null) { //l'oggetto esiste\n  hasprovenienza = (found[10].length > 0);\n  obj.ID = found[util.db.fieldsPos.ID];\n  util.db.lastID = obj.ID;\n  \n  if (obj.Identify !== found[util.db.fieldsPos.Identify]) {\n    print(\"L'oggetto è già nel database. ID:\" + found[util.db.fieldsPos.ID] + \n          \" con un identify Diverso.  \" + link(\"Click per aggiungerlo\", ()=>{\n      util.add(obj);\n      //util.buildautoprovenienza();\n  \t})); \n  } else {\n    print(\"L'oggetto è già nel database. ID:\" + found[util.db.fieldsPos.ID]);  \n  }\n  \n  \n  if (hasprovenienza) {\n    print(\"L'oggetto nel database ha provenienza: \" + found[util.db.fieldsPos.Provenienza] + \"\\n\");\n  } else {\n    print(\"L'oggetto nel database non ha provenienza indicata.\\n\");  \t\n  }\n  //util.buildautoprovenienza();\n} else {\n  //L'oggetto non è nel DB\n  print(\"L'oggetto non esiste nel database. \" + link(\"Click per aggiungerlo\", ()=>{\n      util.add(obj);\n      //util.buildautoprovenienza();\n  }));\n\n}\n\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Uscite visibili: .*",
      "id": "usciteVisibili",
      "value": "//Normalmente NON abilitato.\n//Viene abilitato da altri trigger/alias\n\ntoggleTrigger(\"roomContent\", true);\ntoggleTrigger(\"usciteVisibili\",false);\n//delay(\"disable_roomContent\",300,()=>{toggleTrigger(\"roomContent\", false);})\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Il tuo sangue si raggela non appena senti il grido di morte di (.+)!$",
      "id": "",
      "value": "window.ultimoMobUcciso = match[1];\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^I tuoi livelli: (\\w\\w):\\d{1,2}(?: (\\w\\w):\\d{1,2})?(?: (\\w\\w):\\d{1,2})?",
      "id": "leggiclassi",
      "value": "let classi=[];\nfor (let i=1; i<=3; i++) {\n\tif (match[i]!=undefined) classi.push(match[i]);\n}\nthis.classi = classi;\ntoggleTrigger(\"leggiclassi\",false)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(OK\\.|Scocchi il proiettile\\.)$",
      "id": "",
      "value": "this.scoccato = true;",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Incocchi ([^.]+)\\.$",
      "id": "",
      "value": "this.scoccato = false",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(Guardando all|Stai trasportando)",
      "id": "",
      "value": "toggleTrigger(\"ident_inv\", true)\ndelay(\"ident_inv\", 500, () => {\n\ttoggleTrigger(\"ident_inv\", false)\n})",
      "regex": true,
      "is_script": true,
      "class": "IdentInit",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Il tuo sangue si raggela non appena senti il grido di morte di (.n paladino|.n arciere|.n'inquisitore|.no scudiero|.n mago|.'Arcangelo Remiel|.'Arcangelo Gabriel|.'Arcangelo Uriel|.'Arcangelo Raphael|.'Arcangelo Michael|.'Arcangelo Selaphiel|.'Arcangelo Remiel|.'Arcangelo Samuel)!",
      "id": "",
      "value": "let lab = window.lab;\nif (lab == undefined) {return;}\n\nlet incrementa = (mob,coeff) => {\n\tlab[mob] += 1;\n    if ((lab[mob]>coeff*2) && (lab.lab_multi<3)) {\n      send(\"setlab 3\");\n    } else if ((lab[mob]>coeff) && (lab.lab_multi<2)) {\n      send(\"setlab 2\");\n    }    \n    print(\"Lab kill: \" + match[1] + \" (\" + lab[mob] + \")\");\n}\n\nif (match[1].toLowerCase().search(\"arciere\")>-1) {incrementa(\"arcieri\", 30);}\nelse if (match[1].toLowerCase().search(\"scudiero\")>-1) {incrementa(\"scudieri\", 10);}\nelse if (match[1].toLowerCase().search(\"paladino\")>-1) {incrementa(\"paladini\", 5);}\nelse if (match[1].toLowerCase().search(\"inquisitore\")>-1) {incrementa(\"inquisitori\", 8);}\nelse if (match[1].toLowerCase().search(\"mago\")>-1) {incrementa(\"maghi\", 6);}\nelse if (match[1].toLowerCase().search(\"arcangelo\")>-1) {\n  incrementa(\"arcangeli\", 7);\n  if (this.isCapogruppo())\n    send(\"get chiave arcangelo\")\n}\n\n//console.log(lab);\n\n",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^\\[il guardiano del labirinto\\] dice 'Bene, ecco la chiave. Buona fortuna!'",
      "id": "",
      "value": "send(\"initlab\");",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Davanti a te c'e' una maestosa statua di pietra che raffigura (.+)\\. \\(luminoso\\)|^una (pietra) magica di grande potenza destinata a contenere lo spirito e' stata abbandonata alla sua sorte\\.",
      "id": "labroomcolor",
      "value": "const m = (match[1] || match[2])\ndelay(\"labtrigger\", 0, () => { // client riceve vnum\n  delay(\"labtrigger\", 0, () => { // mapper riceve vnum\n    let rm = mapper.getRoomByVnum(this.TSRoom)\n    if (!rm) return;\n    switch (m) {\n      case \"pietra\":\n      rm.color = \"rgb(0,255,255)\";\n        break;\n      case \"Dryden\":\n      rm.color = \"rgb(0,128,0)\";\n        break;\n      case \"Kiruna\":\n        rm.color = \"rgb(128,64,0)\";\n        break;\n      case \"Martinus\":\n        rm.color = \"rgb(0,0,0)\";\n        break;\n      case \"Dimitri\":\n        rm.color = \"rgb(255,0,0)\";\n        break;\n      case \"Phoenix\":\n        rm.color = \"rgb(255,255,128)\";\n        break;\n      case \"Tyrant\":\n        rm.color = \"rgb(0,0,255)\";\n        break;\n      case \"Nalith\":\n        rm.color = \"rgb(255,255,255)\";\n        break;\n    }\n  })\n})",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Guardi verso ",
      "id": "",
      "value": "toggleTrigger(\"labroomcolor\", false)\ndelay(\"labroomcolor\", 15, () => {\n  toggleTrigger(\"labroomcolor\", true)\n}) ",
      "regex": false,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(\\S+).* tira un dado a 100 facce\\.\\.\\.$",
      "id": "dice",
      "value": "if (!this.temp_dice) {\n  this.temp_dice = {\n  launcher: \"\",\n  results: {}\n  }\n};\nif (match[1] in this.temp_dice.results) {\n  //send(\"gt ATTENZIONE: \" + match[1] + \" ha gia' tirato\");\n  sub(\"dado a 100 facce...\",\"dado a 100 facce...\" + color(\" ( lancio multiplo scartato )\", \"darkgray\"))\n} else {\n  this.temp_dice.launcher = match[1];\n  toggleTrigger(\"dice-risultato\", true);\n}",
      "regex": true,
      "is_script": true,
      "class": "dice",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Il risultato e' (\\d+)\\.$",
      "id": "dice-risultato",
      "value": "this.temp_dice.results[this.temp_dice.launcher] = Number(match[1]);\n\nlet maxresult = 0;\nlet winner = \"\";\nfor (const [name, result] of Object.entries(temp_dice.results)) {\n  //print(name + \"=\" + result);\n  if (result > maxresult) {\n    maxresult = result;\n    winner = name;\n  } else if (result == maxresult) {\n    winner = winner + \",\" + name;\n  }\n}\n\nlet answ = \"\";\nif (winner.search(\",\")>-1) {\n  answ = color(\"Pareggio tra \", \"lightgray\")\n} else {\n  answ = color(\"Sta vincendo \", \"lightgray\")\n}\nansw +=  color(winner,\"lightblue\") + color(\" con \",\"lightgray\") + color(maxresult, \"yellow\");\n\nconst s = \"Il risultato e' \" + match[1] + \".\";\nsub(s, s + \"   < \" + color(answ,\"red\") + \" > \");\nNotification.Show(\"Vince: \" + color(winner,\"lightgreen\") + \": \" + color(maxresult, \"yellow\"), false, true, 3000, true)\ntoggleTrigger(\"dice-risultato\", false);\n",
      "regex": true,
      "is_script": true,
      "class": "dice",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "\\[(\\S+).*\\] dice al gruppo \\'dad(?:a|ate|are|o|iamo)|(Tu) dici al gruppo \\'dad(?:a|ate|are|o|iamo)",
      "id": "",
      "value": "if ( (match[1] && this.isCapogruppo(match[1])) ||\n     (match[2]==\"Tu\" && this.isCapogruppo(this.TSPersonaggio)) ) {\n  this.temp_dice = {\n    launcher: \"\",\n    results: {}\n  }\n  toggleTrigger(\"dice\", true);\n  Notification.Show(color(\"Il capogruppo ha chiesto di tirare il dado!\",\"lightgreen\"), true, false, 3000, true, 1.0, true)\n}",
      "regex": true,
      "is_script": true,
      "class": "dice-init",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Un enorme Monolito che irradia potenza con dei segni",
      "id": "",
      "value": "push monolito",
      "regex": false,
      "is_script": false,
      "class": "zone:204",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Non riesci a reggere %1 che ti cade in terra.",
      "id": "",
      "value": "Notification.Show(\"Ti e' caduto \" + $1, false, false, 5000, false, 1.0, true)\nsend(\"get ed\" + TSPersonaggio)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Fine identify EQ",
      "id": "fineidentifyeq",
      "value": "function downloadString(jsonstr, filename) {\n    let blob = new Blob([jsonstr], { type: \"octet/stream\" });\n    let url = window.URL.createObjectURL(blob);\n\n    let link = document.createElement(\"a\");\n    link.setAttribute(\"href\", url);\n    link.setAttribute(\"download\", filename);\n    link.style.visibility = \"hidden\";\n\n    document.body.appendChild(link);\n    link.click();\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(link);\n}\n\ntoggleTrigger(\"fineidentifyeq\", false)\noutputManager.outputWin.log=false\ndownloadString(localStorage.getItem(\"log\"),\"EQ \" + TSPersonaggio + \".log\")\n",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "Non puoi usare il comando 'cast' con '%1'",
      "id": "",
      "value": "this.ultimoSpellCastato=$1",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^Devi trovare:$",
      "id": "infoquest_start",
      "value": "toggleTrigger(\"infoquestContent\", true);",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^ - (.+)$",
      "id": "infoquestContent",
      "value": "var util = window.dbIdentUtil;\nlet descshort = match[1].trim();\nlet r = util.withshort(descshort);\nif (util.debug() && r.length>0) {console.log(\"Item trovato: nel trigget ident_inv:\" + match[1])}\nif (r.length>0) {\n  let firstword = $1;\n  const spaceIndex = firstword.indexOf(\" \");\n  if (spaceIndex>-1) {\n    firstword = firstword.substring(0, spaceIndex);\n  }\n\n  const testoident = ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]==\"\")) ?\n      color(\"[?]\",\"maroon\") : color(\"[?]\",\"green\");\n  const lnkident = link(testoident,()=>{\n    let out = util.getStringIdents(r);\n    print(out)\n  },\"vedi identify\")\n  \n  let newText = \" - \" + lnkident + \" \" + match[1].trim();\n  if ((r.length==1) && (r[0][util.db.fieldsPos.Provenienza]!=\"\")) {\n    newText += \" - \" + color(r[0][util.db.fieldsPos.Provenienza],\"orange\");\n  } else if (r.length>1) {\n    newText += \" - \" + color(r.length + \" oggetti con la stessa descrizione\",\"red\");\n  }\n  \n  sub(match[0],newText)\n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": false,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    }
  ],
  "aliases": [
    {
      "pattern": "initialize",
      "id": "",
      "value": "if (this.initDone) {\n\treturn;\n}\nconst wasImmortal = this.Immortal;\nthis.scriptVersion = 10\nthis.initDone = true;\nthis.disableCheckAssist = false;\nthis.preventAutoStop = false;\nthis.preventAutoRescue = false;\nthis.listaDivini = null;\nthis.listaTerra = null;\nthis.listaAcqua = null;\nthis.listaAria = null;\nthis.listaFuoco = null;\nthis.listaXP = null;\nthis._stat_pqsess = 0;\nthis._stat_pqh = 0;\nthis._stat_pq5m = 0;\nthis._stat_pq15m = 0;\nthis._stat_pq1h = 0;\nthis._stat_xpsess = 0;\nthis._stat_xph = 0;\nthis._stat_xp5m = 0;\nthis._stat_xp15m = 0;\nthis._stat_xp1h = 0;\nthis.usiBlunt = false;\nthis.usiSlash = false;\nthis.usiPierce = false;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = false;\nthis.usiImmuEle = false;\nthis.usiImmuFire = false;\nthis.usiExtra = false;\nlet ultimoScudo = null;\nlet ultimaArma = null;\nthis.ultimoScudo = null;\nthis.ultimaArma = null;\ntoggleClass(\"thief\", this.canStab);\n\nif (ultimaArma==this.armaBlunt) {\n  send(\"blunt\");\n}\nelse if (ultimaArma==this.armaSlash) {\n  send(\"slash\");\n}\nelse if (ultimaArma==this.armaPierce) {\n  send(\"pierce\");\n}\nelse if (ultimaArma==this.armaExtra) {\n  send(\"extra\");\n}\n\nif (ultimoScudo==this.scudoCold) {\n  send(\"ic\");\n}\nelse if (ultimoScudo==this.scudoAcid) {\n  send(\"ia\");\n}\nelse if (ultimoScudo==this.scudoEle) {\n  send(\"ie\");\n}\nelse if (ultimoScudo==this.scudoFire) {\n  send(\"if\");\n}\nif (this.mustMemorize) {\n  send(\"mem\");\n}\nvar room = this.TSRoom\n  \nthis.postInit = () => {\n  toggleClass(\"autoinspire\", this.autoinspire);\n  this.TSRoom = null;\n  setTimeout(() => {\n    if (mapper && this.TSRoom) \n      mapper.setRoomByVnum(this.TSRoom);\n    \n  \tsetTimeout(() => {\n      const current = (mapper?mapper.current:null);\n      this.TSRoom = ((current && current != room) ? current?.vnum : room) || null;\n    });\n  });\n  \n  if (this.ImmortalTrigger) {\n  \tthis.Immortal = true; \n  } else {\n  \tthis.Immortal = false;\n  }\n  setTimeout(() => {\n    toggleClass(\"immortal\",this.Immortal)\n    if (this.Immortal) {\n      send(\"prompt %gr%N!HP:%h/%H %m!%M!%v!%V!Room:%R Inv:<%iI> Stealth:<%iS> Snoop:<%iN>%l!%x!%X!%b!%g!%G!%a!%c!%C!%A!%S!%tk!%Tk!>\",true)\n    } else {\n      send(\"prompt %gr%p!%N!H:[$c4009%h$c0007/%H] M:[$c4014%m$c0007/%M] V:[$c0002%v$c0007/%V] G:$c0011%g$c0007 [%F%b] T:$c0015%tk$c0007(%c)/M:$c0009%Tk$c0007(%C) %l%x!%X!%b!%g!%G!%a!%c!%C!%A!%S!%tk!%Tk!>\",true)\n    }\n    if (this.enableident && this.publicident) {\n      \ttoggleClass(\"Ident\", true)\n     \tsend(\"identimport online\")\n    } else if (this.enableident) {\n      \ttoggleClass(\"Ident\", true)\n    \tsend(\"ident_init\")\n    }\n  }, 1000);\n  if (wasImmortal != this.Immortal) {\n    (this.Immortal ? print(\"Modalita' per Immortali del Client: ATTIVATA\") : print(\"Modalita' per Immortali del Client: DISABILITATA\"));\n  }\n  if (this.setupdone!=this.scriptVersion) {\n    setTimeout(()=>{\n      print(color(\"Serve fare il SETUP, scrivi setup e premi Invio!\", \"red\", \"white\", true, true, true));\n    }, 2000);\n  }\n  send(\"autoloot \" + ((!this.autoloot || this.Immortal) ? \"off\" : \"on\"))\n  if (this.is_touch_device() && this.usesTouch) {\n    print(color(\"Sembra che tu abbia il touchscreen. Per abilitare i controlli scrivi 'touch'.\", \"white\"))\n  }\n};\n\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "stop",
      "id": "",
      "value": "if (this.autoassist) send(\"autoassist false\");\nsend(\"~stop\");",
      "regex": false,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "script": null
    },
    {
      "pattern": "^autoassist ?(.*)?",
      "id": "autoassist",
      "value": "this.autoassist = !this.autoassist;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autoassist = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoassist\", this.autoassist);\nlet str = \"Autoassist: \"+ (this.autoassist ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);\n  this.TSTankCond=\"*\";\n  this.TSTank=\"*\";\n  send(\"checkAssist\");",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autobash ?(.*)?",
      "id": "autobash",
      "value": "this.autobash = !this.autobash;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autobash false)\n\tthis.autobash = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autobash\", this.autobash);\nconst autoWhat = this.canKick && !this.canBash ? \"AutoKick\" : \"AutoBash\";\nlet str = (autoWhat + \": \"+ (this.autobash ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "bash",
      "id": "",
      "value": "tales gigante $1",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "aa",
      "id": "",
      "value": "autoassist",
      "regex": false,
      "is_script": false,
      "class": "fight",
      "enabled": true,
      "script": null
    },
    {
      "pattern": "ab",
      "id": "",
      "value": "autobash",
      "regex": false,
      "is_script": false,
      "class": "fight",
      "enabled": true,
      "script": null
    },
    {
      "pattern": "^autocleric ?(?:(\\d+))?",
      "id": "autocleric",
      "value": "this.noncurare = [];\nlet acl = classEnabled(\"autocleric\");\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tacl = Number(match[1])>0;\n} else if (!match || !match[1]) {\n  acl = !acl;\n}\nthis.autocleric = acl;\nif (!acl) {\n  this.diciStatus(\"AutoCleric OFF\");\n  toggleClass(\"autocleric\", false);\n}\nelse {\n  this.aclMinimum = (match[1] ? Number(match[1]) : 70); // se non passato uso default\n  let str = (\"AutoCleric ON (\" + this.aclMinimum + \")\");\n  this.diciStatus(str);\n  toggleClass(\"autocleric\", true);\n  this.TSLag == \"+\";\n  this.Gruppo = \"{}\";\n  setTimeout(()=>send(\"\"),500);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "heal ?(?:(\\w+))?",
      "id": "heal",
      "value": "if (!this.canPlay && !this.healtype) {\n  send(\"sit;seco\");\n  return;\n}\nlet target = match[1] || this.TSPersonaggio\nif (this.canPlay) {\n\tsend(\"cast 'minor h' \" + target)\n  return;\n}\nif (this.healtype == \"D\") {\n  if (this.TSSettore == \"Chiuso\") {\n    send(\"cast 'minor h' \" + target)\n  } else {\n    send(\"cast 'natures c' \" + target)\n  }\n  this.TSLag = \"+\";\n} else if (this.healtype == \"C\") {\n  send(\"cast 'healing' \" + target)\n  this.TSLag = \"+\";\n}\nelse {\n  send(\"say Curare: \" + target)\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "h",
      "id": "",
      "value": "heal $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "acl",
      "id": "",
      "value": "autocleric $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "debug",
      "id": "",
      "value": "this.debug = !this.debug;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. debug false)\n\tthis.debug = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"debug\", this.debug);\nprint(\"Debug: \"+ (this.debug ? \"ABILITATO\" : \"DISABILITATO\"));",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "variables",
      "id": "",
      "value": "print(\"\\nVariabili acessibili alle script:\\n\");\nlet filtro = input.split(\" \")[1]\nfor (let x in this) {\n  if (filtro && x.toLowerCase().indexOf(filtro.toLowerCase())==-1) continue;\n  if (typeof this[x] == \"function\" || x == \"oldValues\") continue;\n if (this[x] && typeof this[x] == \"object\" && this[x].has) {\n   print(x + \": \" + JSON.stringify([...this[x]]));\n } else if (typeof this[x] == \"object\") {\n   print(x + \": \" + JSON.stringify(this[x]));\n } else {\n \tprint(x + \": \" + this[x]) ;\n }\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "preinit",
      "id": "",
      "value": "this.is_touch_device = () => {\n    if (\"ontouchstart\" in window || window.TouchEvent)\n        return true;\n\n    if (window.DocumentTouch && document instanceof DocumentTouch)\n        return true;\n\n    const prefixes = [\"\", \"-webkit-\", \"-moz-\", \"-o-\", \"-ms-\"];\n    const queries = prefixes.map(prefix => `(${prefix}touch-enabled)`);\n\n    return window.matchMedia(queries.join(\",\")).matches;\n};\n\nthis.autofuryEnabled = () => {\n\tif (this.canPlay) {\n      return this.autosong;\n    } else {\n      return this.autofury;\n    }\n};\n\nthis.autofuryToggle = () => {\n\tif (this.canPlay) {\n      send(\"autosong\");\n    } else {\n      send(\"autofury\");\n    }\n};\n\nif (this.canPlay) {\n  this.autofuryButton = \"AutoSong\"\n  scriptManager.linkEvent(\"autosong\", \"autofuryEnabled()\")\n} else {\n  this.autofuryButton = \"AutoFury\"\n  scriptManager.unlinkEvent(\"autosong\", \"autofuryEnabled()\")\n}\n\nthis.renting = false\nthis.ImmortalTrigger = false;\nthis.roundtime = 4000;\nthis.initDone = false;\ndelete this.postInit;\ntoggleClass(\"autologin\", true);\ntoggleClass(\"login\", true);\ntoggleClass(\"Ident\", false);\nthis.autokill = false;\nthis.stabTarget = null;\n\ndelay(\"preinit\", 1, () => {\n  toggleClass(\"fixxa\", false);\n  toggleClass(\"questor\", false);\n  toggleClass(\"cleric\", (this.healtype||\"\").indexOf(\"C\")!=-1);\n  toggleClass(\"druid\", (this.healtype||\"\").indexOf(\"D\")!=-1);\n  toggleClass(\"mage\", (this.casttype||\"\").indexOf(\"M\")!=-1);\n  toggleClass(\"psionic\", (this.casttype||\"\").indexOf(\"P\")!=-1);\n  toggleClass(\"sorcerer\", !!this.mustMemorize);\n  toggleClass(\"bard\", !!this.canPlay);\n  toggleClass(\"monk\", !!this.canKick && !!!this.canBash);\n  toggleClass(\"autosong\", false);\n  toggleClass(\"autoinspire\", false);\n  toggleClass(\"fight\", !!!this.Immortal);\n  toggleClass(\"util\", true);\n  toggleClass(\"autocleric\", !!this.autocleric>0 && !!!this.Immortal);\n  toggleClass(\"autoassist\", !!this.autoassist && !!!this.Immortal);\n  toggleClass(\"autobash\", !!this.autobash && !!!this.Immortal);\n  toggleClass(\"autorescue\", !!this.autorescue && !!!this.Immortal);\n  toggleClass(\"autoarmi\", !!this.autoarmi && !!!this.Immortal);\n  toggleClass(\"antispalm\", !!this.antispalm && !!!this.Immortal);\n  toggleClass(\"debug\", false);\n  toggleClass(\"autogroup\", !!this.autogroup && !!!this.Immortal);\n  toggleClass(\"autoloot\", !!this.autoloot && !!!this.Immortal);\n  toggleClass(\"autologin\", false);\n  toggleClass(\"login\", true);\n  toggleClass(\"memorize\", false);\n  toggleClass(\"automemorize\", this.automemo && !!!this.Immortal);\n  toggleClass(\"selfsanc\", !!this.selfsanc && !!!this.Immortal);\n  toggleClass(\"selfshield\", !!this.selfshield && !!!this.Immortal);\n  toggleClass(\"gtalign\", false);\n  toggleClass(\"thief\", false);\n  toggleClass(\"autokill\", false);\n  toggleClass(\"afk\", !!this.afk);\n\n});\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "cura",
      "id": "",
      "value": "if (!this.healtype && !this.canPlay) return;\nif (!this.pauseAutocleric && this.TSLag == \"-\") {\n  const grp = JSON.parse(this.Gruppo);\n  let mincura = this.aclMinimum || 70;\n  var minhp = 100;\n  var minpg = \"\";\n  var minMov = 100;\n  var minMovPg = \"\";\n  for (let nome in grp) {\n    if (nome == \"tank\" || nome == \"mob\") continue;\n    // non in room o non curabile\n    if (grp[nome].hide || !grp[nome].inroom || grp[nome].pkill) {\n      continue;\n    }\n    if (grp[nome].hp < mincura && grp[nome].hp<minhp) {\n      minhp = grp[nome].hp;\n      minpg = nome;\n    }\n    if (grp[nome].mv < 25 && grp[nome].mv<minMov) {\n      minMov = grp[nome].mv;\n      minMovPg = nome;\n    }\n  }\n\n  if (minpg) {\n    this.pgdacurare = minpg;\n    print(\"Curo: \" + minpg + \" (\" + minhp + \"% < \" + mincura + \"%)\");\n    send(\"heal \" + minpg);\n    this.pauseAutocleric = true;\n    delay(\"reset_acl\", 2000, ()=>{\n      this.pauseAutocleric = false;\n      const lag = this.TSLag;\n      if (lag == \"-\") {\n      \tthis.TSLag = \"\";\n      \tdelay(\"reset_acl2\", 100, ()=>{ this.TSLag = lag; });\n      }\n    });\n  }\n  if (minMovPg) {\n    print(\"Refresh: \" + minMovPg + \" (\" + minMov + \"% < \" + 25 + \"%)\");\n    send(\"refresh \" + minMovPg);\n    this.pauseAutocleric = true;\n    delay(\"reset_acl\", 2000, ()=>{\n      this.pauseAutocleric = false;\n      const lag = this.TSLag;\n      if (lag == \"-\") {\n      \tthis.TSLag = \"\";\n      \tdelay(\"reset_acl2\", 100, ()=>{ this.TSLag = lag; });\n      }\n    });\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "stand",
      "id": "",
      "value": "if (!this.alzando) {\n\tthis.alzando = true;\n\tsend(\"~stand\");\n}\nthis.alzando=false",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "flee",
      "id": "",
      "value": "if (this.seduto) {\n  send(\"stand\");\n}\nsend(\"~flee\");",
      "regex": false,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "checkAssist",
      "id": "",
      "value": "if (this.disableCheckAssist == true || this.preventAutoassist == true) \n{\n  //this.preventAutoassist = false\n  if (this.autobash) {\n    delay(\"checkAssist\", (this.autocleric ? 2000 : 0 + 2000), () => {send(\"checkAssist\")})\n  }\n  return;\n}\nthis.disableCheckAssist = true;\nsetTimeout(()=>{this.disableCheckAssist=false}, 200);\n\nconst newTank = this.TSTank;\nconst tankState = this.TSTankCond;\n\nlet cleanCastingTimeout = () => {\n  if (this.castTimeout) clearTimeout(this.castTimeout);\n  this.castTimeout = 0;\n}\nif (this.autostop && tankState && tankState != \"*\" && !this.preventAutoStop && !this.isTank()) {\n  this.preventAutoStop = true;\n  this.preventAutoassist = true;\n  if (this.TSPosizione!=\"In piedi\") {\n    send(\"stand\");\n  }\n  send(\"~stop\");\n  delay(\"autostop1\", 4000, () => {\n    this.preventAutoassist = false\n    send(\"checkAssist\")\n  })\n  delay(\"autostop2\", 8250, () => {\n    this.preventAutoStop = false\n    send(\"checkAssist\")\n  })\n}\nlet rescuato = false;\nif (this.autorescue && newTank != \"*\" && newTank!=this.TSPersonaggio && !this.preventAutoRescue) {\n  this.preventAutoRescue = true;\n  if (this.TSPosizione!=\"In piedi\") {\n    send(\"stand\");\n  }\n  send(\"rescue \" + newTank);\n  rescuato = true;\n  setTimeout(() => {this.preventAutoRescue = false}, 4000)\n}\nif (newTank != \"*\" && tankState == \"*\") {\n  if ((classEnabled(\"autoassist\")||(this.autostab))) {\n    this.preventAutoassist = true\n    setTimeout(() => {\n      this.TSTankCond=\"\"\n      this.preventAutoassist = false\n    }, 3000)\n    if (this.autostab) {\n      if (this.usiPierce != this.canPlay) {\n        send(`${this.canPlay?\"slam\":\"backstab\"} ${this.TSMob.split(\" \")[0]}`)\n        if (!this.canPlay && this.afk && !this.autobash) {\n          send(\"~stop\")\n        }\n        return;\n      }\n    }\n    if (!classEnabled(\"autoassist\")) {\n    \treturn;\n    }\n    if (this.autofury) {\n      send(`fury ${this.TSMob.split(\" \")[0]}`)\n    } else {\n      if (!rescuato && this.cleanupName(newTank).toLowerCase() != this.TSPersonaggio.toLowerCase()) send(\"assist \" + this.cleanupName(newTank));\n    }\n    if ((this.canBash||this.canKick) && this.autobash) {\n      setTimeout(()=>{if (this.inCombat()) send(\"bash\")},200);\n    }\n    if (newTank==this.TSPersonaggio) return;\n  }\n  if (this.autocast && this.TSMob!=\"*\" && this.spellOffensivo) {\n    cleanCastingTimeout();\n    const comando = this.mustMemorize ? \"recall\" : \"cast\";\n    let casta = () => {\n      if (this.TSMob==\"*\" || !this.autocast) {\n        cleanCastingTimeout();\n        return;\n      }\n      if (this.TSLag==\"-\") {\n      \tsend(`${comando} '${this.spellOffensivo}' ${this.TSMob.split(\" \")[0]}`)\n      }\n      let lag = Math.floor(this.roundtime*1.5);\n      if (this.autocleric) lag += 3000;\n      this.castTimeout = setTimeout(() => {casta()}, lag)\n    }\n    this.castTimeout = setTimeout(() => {casta()}, 0)\n  }\n} else if (newTank != \"*\" && tankState != \"*\") {\n  if (this.autobash && this.TSLag != \"+\" && this.inCombat()) {\n    delay(\"checkAssist\", (this.autocleric ? 2000 : 0 + 2000),() => {send(\"checkAssist\")})\n    if (this.TSPosizione != \"In piedi\" && (!this.canBash && this.canKick)) {\n      send(\"springleap\");\n      return;\n    }\n    else if (this.TSPosizione != \"In piedi\" && (this.canBash)) {\n      send(\"stand\");\n    }\n    send(\"bash\");    \n  } else if (this.autobash && this.inCombat()) {\n    delay(\"checkAssist\", (this.autocleric ? 2000 : 0 + 2000),() => {send(\"checkAssist\")})\n  }\n} else if (newTank == \"*\") {\n  cleanCastingTimeout();\n}\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "ass",
      "id": "",
      "value": "send(\"assist \" + (input.split(\" \")[1] || this.TSTank.split(\" \")[0]))",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autogroup ?(.*)?",
      "id": "autogroup",
      "value": "this.autogroup = !this.autogroup;\n\nif (match && match[1] != undefined) {\n\tthis.autogroup = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autogroup\", this.autogroup);\nlet str = (\"Autogroup: \"+ (this.autogroup ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "setup",
      "id": "",
      "value": "const setClasses = async (v) => {\n  toggleClass(\"mage\",v && this.casttype.indexOf(\"M\")!=-1)\n  toggleClass(\"cleric\",v && this.casttype.indexOf(\"C\")!=-1)\n  toggleClass(\"druid\",v && this.casttype.indexOf(\"D\")!=-1)\n  toggleClass(\"psionic\",v && this.casttype.indexOf(\"P\")!=-1)\n  toggleClass(\"sorcerer\",v && this.mustMemorize)\n  toggleClass(\"bard\",v && this.canPlay)\n  this.mustMind = this.casttype.indexOf(\"P\")!=-1;\n  this.healtype = this.casttype.indexOf(\"C\")!=-1 ? \"C\" : this.casttype.indexOf(\"D\")!=-1 ? \"D\" : \"\";\n};\n\nconst resetSettings = () => {\n  setClasses(false);\n  delete this.strumentoPercussione;\n  delete this.strumentoCorde;\n  delete this.strumentoFiato;\n  delete this.strumentoSlam;\n  delete this.autocleric;\n  delete this.mustMind\n  delete this.canPlay\n  delete this.healtype\n  delete this.mustMind\n  delete this.mustMemorize;\n  delete this.spellOffensivo;\n  delete this.armaBlunt\n  delete this.armaSlash\n  delete this.armaPierce\n  delete this.numeroAttacchi\n  delete this.ordineArmi\n  delete this.armaPrimaria\n  delete this.armaExtra\n  delete this.zoneDaNonRimettereArma\n  delete this.scudoCold\n  delete this.scudoAcid\n  delete this.scudoEle\n  delete this.scudoFire\n  delete this.usaLuce\n  delete this.borsa\n  delete this.borsaArmi\n  delete this.throwObject\n  delete this.holdItem\n  delete this.oggettoTrueSight\n  delete this.armaDigCut\n  delete this.pgTitle\n  delete this.colori\n  delete this.setupdone;\n  delete this.ImmortalTrigger\n  delete this.Immortal\n  delete this.canBash\n  delete this.canKick\n  delete this.enableident\n  delete this.publicident\n  delete this.arco\n  delete this.freccia\n}; \n\nif ($1==\"reset\") {\n  print(\"Cancello la configurazione pg / setup.\")\n  resetSettings()\n  this.initDone = false;\n  send(\"initialize\");\n  delay(\"postinitialize\", 100, () => this.postInit ? this.postInit() : false)\n  return\n}\n\nconst askColori = async () => {\n  let colori = (this.colori instanceof Array) ? this.colori.join(\",\") : (this.colori || \"$c0009\");\n\n  const results = (await Messagebox.ShowMultiInput(\"Personale\",\n                   [\"Il tuo title\",\"Colori con i quali parli separati da virgola\", \"Vuoi giocare in modalita' compatta (no prompt)\"],\n                   [this.pgTitle ? this.pgTitle : \".\",\n                    colori || \"$c0009\",\n                   triggerEnabled(\"gagprompt\")])).results;\n\n  this.pgTitle = results[0]\n  this.colori = results[1].split(\",\")\n  const wantsCompact = toggleTrigger(\"gagprompt\",!!results[2])||triggerEnabled(\"gagprompt\")\n  \n  send(`compact ${ wantsCompact ? \"enable\" : \"disable\"}`)\n  return results\n};\n\nconst askIdentify = async () => {\n  const results = (await Messagebox.ShowMultiInput(\"Identify\",\n                   [\"Vuoi usare le funzonalita' del DB identify?\",\"Vuoi usare il db oggetti pubblico?\"],\n                   [!!this.enableident,!!this.publicident])).results;\n\n  return results\n};\n\nconst answer = (await Messagebox.Question(\n  \"Presuppongo che sei un personaggio Mortale?\\nRispondi No solamente se stai creando il profilo per un Immortale o Dio.\\n\\nPremi 'Si' per proseguire con il setup.\"\n)).result;\n\nconst correct = (condition) => {\n  return (true === (this.Immortal = this.ImmortalTrigger = !!condition));\n};\n\nif ((this.Immortal = correct(answer != \"Si\"))) {\n  const col = this.colori\n  const title = this.pgTitle\n  resetSettings()\n  this.colori = col\n  this.pgTitle = title\n  this.casttype = \"CDMP\"\n  this.healtype=\"C\"\n  this.spellOffensivo = 'disint';\n  this.zoneDaNonRimettereArma = 0\n  this.usaLuce = false\n  this.borsa = (await Messagebox.ShowInput(\"La tua borsa\",\"Che keyword usi per la tua borsa?\", this.borsa || \"borsa-ed\"+this.TSPersonaggio)).result\n  await setClasses(true);\n  this.mustMind = this.mustMemorize = false;\n  await askColori();\n  this.setupdone = this.scriptVersion;\n  this.Immortal = true;\n  this.autocleric = false;\n  this.ImmortalTrigger = true;\n  this.initDone = false;\n  send(\"initialize\");\n  delay(\"postinitialize\", 100, () => this.postInit ? this.postInit() : false)\n  \n  return;\n}\n\nthis.ImmortalTrigger = false;\nthis.Immortal = false;\n\nconst resClassi = (await Messagebox.ShowMultiInput(\"Configurazione Classi\",\n                 [\"Puoi Bashare?\",\"Puoi Stabbare?\",\"Puoi Suonare?\",\"Puoi Calciare?\", \"[C]l, [D]r, [M]u, [P]s (o comb)\",\"Spell offensivo\",\"Devi memmare?\"],\n                 [!!this.canBash,\n                  !!this.canStab,\n                  !!this.canPlay,\n                  !!this.canKick,\n                 this.casttype,\n                 this.spellOffensivo||\"meteor swarm\",\n                 !!this.mustMemorize])).results\n             \nthis.canBash = resClassi[0];\nthis.canStab = resClassi[1]\nthis.canPlay = resClassi[2]\nthis.canKick = resClassi[3]\nthis.casttype = resClassi[4].toUpperCase()\nthis.spellOffensivo = resClassi[5]\nthis.mustMemorize = resClassi[6]\n\nawait setClasses(true);\n\nconst resArmi = (await Messagebox.ShowMultiInput(\"Configurazione armi\",\n                 [\"Key dell'arma blunt\",\"Key dell'arma slash\", \"Key dell'arma pierce\",\"Key arma extra\",\"Key dell'arco\",\"Num. attacchi primario\",\"Ordine cambio: 1=BPS, 2=BSP\",\"Arma Primaria (blunt/pierce/slash)\",\"Key freccia preferita\",\"ID zone dove non rimetti arma prim. (0=tutte)\"],\n                 [this.armaBlunt != undefined ? this.armaBlunt : \"blunt-ed\"+this.TSPersonaggio,\n                  this.armaSlash != undefined  ? this.armaSlash : \"slash-ed\"+this.TSPersonaggio,\n                 this.armaPierce != undefined  ? this.armaPierce : \"pierce-ed\"+this.TSPersonaggio,\n                 this.armaExtra != undefined  ? this.armaExtra : \"scintilla-ed\"+this.TSPersonaggio,\n                 this.arco != undefined  ? this.arco : \"arco-ed\"+this.TSPersonaggio,\n                 this.numeroAttacchi!=undefined ? this.numeroAttacchi : \"4\",\n                 this.ordineArmi!=undefined ? this.ordineArmi : \"2\",\n                 this.armaPrimaria!=undefined ? this.armaPrimaria : \"blunt\",\n                 this.freccia != undefined  ? this.freccia : \"\",\n                 this.zoneDaNonRimettereArma!=undefined ? this.zoneDaNonRimettereArma : \"\"])).results\n                 \nthis.armaBlunt = resArmi[0];\nthis.armaSlash = resArmi[1];\nthis.armaPierce = resArmi[2];\nthis.numeroAttacchi = resArmi[5];\nthis.ordineArmi = resArmi[6];\nthis.armaPrimaria = resArmi[7];\nthis.armaExtra = resArmi[3];\nthis.arco = resArmi[4];\nthis.freccia = resArmi[8];\nthis.zoneDaNonRimettereArma = resArmi[9];\n\nif (this.canPlay) {\n  const domandaStrumenti = (await Messagebox.ShowMultiInput(\"Configurazione Strumenti\",\n                   [\"Strumento a percussione\",\"Strumento a corde\", \"Strumento a fiato\",\"Slammi con sturmento percussione?\"],\n                   [this.strumentoPercussione!=undefined ? this.strumentoPercussione : \"tamburo-ed\"+this.TSPersonaggio,\n                   this.strumentoCorde!=undefined ? this.strumentoCorde : \"arpa-ed\"+this.TSPersonaggio,\n                   this.strumentoFiato!=undefined ? this.strumentoFiato : \"flauto-ed\"+this.TSPersonaggio,\n                   this.strumentoSlam!=undefined ? this.strumentoSlam == this.strumentoPercussione : true])).results\n\n  this.strumentoPercussione = domandaStrumenti[0]\n  this.strumentoCorde =  domandaStrumenti[1]\n  this.strumentoFiato =  domandaStrumenti[2]\n  this.strumentoSlam =  domandaStrumenti[3] ? this.strumentoPercussione : this.strumentoCorde\n}\n\nconst resScudi = (await Messagebox.ShowMultiInput(\"Configurazione Scudi\",\n                 [\"Keyword Scudo Ghiaccio\",\"Keyword Scudo Acido\", \"Keyword Scudo Elettrico\",\"Keyword Scudo Fuoco\"],\n                 [this.scudoCold!=undefined ? this.scudoCold : \"scudo-cold-ed\"+this.TSPersonaggio,\n                  this.scudoAcid!=undefined ? this.scudoAcid : \"scudo-acid-ed\"+this.TSPersonaggio,\n                 this.scudoEle!=undefined ? this.scudoEle : \"scudo-ele-ed\"+this.TSPersonaggio,\n                 this.scudoFire!=undefined ? this.scudoFire : \"scudo-fire-ed\"+this.TSPersonaggio])).results\n\nthis.scudoCold = resScudi[0]\nthis.scudoAcid =  resScudi[1]\nthis.scudoEle =  resScudi[2]\nthis.scudoFire =  resScudi[3]\n\nconst resUtil = (await Messagebox.ShowMultiInput(\"Utilitarie\",\n                 [\"Usi una luce come hold?\",\"Keyword della borsa\",\"Keyword della borsa per armi/scudi\",\"Keyword dell'oggetto shuriken\", \"Keyword dell'oggetto che tieni in mano\",\"Keyword dell'oggetto ti da' True Sight\",\"Key dell'dell'arma che usi per Dig e Cut\"],\n                 [this.usaLuce!=undefined ? this.usaLuce : false,\n  \t\t\t\t\t      this.borsa!=undefined ? this.borsa : \"borsa-ed\"+this.TSPersonaggio,\n                  this.borsaArmi!=undefined ? this.borsaArmi : \"\",\n                  this.throwObject!=undefined ? this.throwObject : \"shuriken\",\n                 this.holdItem!=undefined ? this.holdItem : \"sigillo-ed\"+this.TSPersonaggio,\n                 this.oggettoTrueSight!=undefined ? this.oggettoTrueSight : \"maschera-ed\"+this.TSPersonaggio,\n                 this.armaDigCut!=undefined ? this.armaDigCut : \"pugnale-ed\"+this.TSPersonaggio])).results\n\nthis.usaLuce = resUtil[0]\nthis.borsa = resUtil[1]\nthis.borsaArmi = resUtil[2]\nthis.throwObject = resUtil[3]\nthis.holdItem = resUtil[4]\nthis.oggettoTrueSight = resUtil[5]\nthis.armaDigCut = resUtil[6]\n\nawait askColori();\n  \nconst responseIdent = await askIdentify()\nthis.enableident = responseIdent[0]\nthis.publicident = responseIdent[1]\n//if (this.enableident) send(`ident_init`)\n//if (this.publicident) send(`identimport online`)\n  \nthis.setupdone = this.scriptVersion;\nif (this.mustMemorize) {\n  print(\"Per impostare l'Automemorize usa l'alias 'libro'.\")\n}\nthis.initDone = false;\nsend(\"initialize\");\ndelay(\"postinitialize\", 100, () => this.postInit ? this.postInit() : false)\ntoggleTrigger(\"leggiclassi\",true)\nsend(\"score\")\n",
      "regex": false,
      "is_script": true,
      "class": "setup",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "tickProc",
      "id": "",
      "value": "this.feastFatto = false;\nsend(\"calcoloPerHour\");\nif (this.memorizing) {\n  send(\"finememorize\")\n}\nlet tickInScadenza = () => {\n  print(color(\"[Tick in 10 secondi!]\",\"yellow\",null,true,false,false));\n  if (this.mustMemorize) delay(\"automemo\", 2000, () => { send(\"automemma\"); });\n};\nif (this.debug) {\n\tprint(color(\"[Tick \" + this.TickRemaining + \"]\",null,null,false,false,true));\n} else {\n\tprint(color(\"[Tick]\",\"black\",\"gray\",true,false,false));\n}\nif (this.autoinspire) {\n\tdelay(\"autoinspire\", 2000, () => send(\"inspire\"))\n}\n\nif (this.afkProcTimout) clearTimeout(this.afkProcTimout);\n\nthis.afkProcTimout = setTimeout(() => {\n  if (classEnabled(\"afk\")) {\n    send(\"afkProc\")\n  } else {\n    send(\"nonAfkProc\")\n  }\n}, 20000);\n\nif (!this.lastTickTime || typeof this.lastTickTime == \"string\") {\n  this.lastTickTime = new Date();\n}\nlet now = new Date();\nvar dif = Math.round((now.getTime() - this.lastTickTime.getTime())/1000);\nthis.TickDuration = dif;\nthis.lastTickTime = new Date();\nif (this.TickDuration > 75) {\n  this.ticksToLongTick = 8\n} else {\n  if (this.ticksToLongTick) this.ticksToLongTick--;\n}\nif (this.ticksToLongTick == 0) {\n  this.currentTickLenght = 80;\n} else {\n  this.currentTickLenght = 65;\n}\nvar tickLen = this.currentTickLenght;\nthis.TickRemaining = tickLen;\nif (this.tickInterval) {\n  clearTimeout(this.tickInterval);\n}\nlet tickFunc = (tickLen, id) => {\n  if (id != this.tickInterval) return;\n  tickLen--;\n  if (tickLen==10) {\n    tickInScadenza();\n  }\n  this.TickRemaining = tickLen;\n  if (tickLen>0) {\n    setTimeout(() => {\n      tickFunc(tickLen,id);\n    }, 1000);\n  }\n}\nthis.tickInterval = setTimeout(() => {\n  if (this.tickInterval) tickFunc(tickLen,this.tickInterval);\n}, 1000);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autoloot ?(.*)?",
      "id": "autoloot",
      "value": "const oldVal = this.autoloot;\n\nthis.autoloot = !this.autoloot;\n\nif (match && match[1] != undefined) {\n\tthis.autoloot = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoloot\", this.autoloot);\nlet str = (\"Autoloot: \"+ (this.autoloot ? \"ABILITATO\" : \"DISABILITATO\"));\nif (oldVal != this.autoloot) {\n  this.diciStatus(str);\n  if (!this.Immortal) {\n    if (this.autoloot) {\n        send(\"fischia\")\n    } else {\n      send(\"addio famiglio\"+this.TSPersonaggio)\n    }\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "es",
      "id": "",
      "value": "enter stagno",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ep",
      "id": "",
      "value": "enter portale",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "astral",
      "id": "",
      "value": "let comando = \"cast\"\nlet spell = \"astral\"\nif (this.mustMemorize && this.casttype.length==1 && this.casttype==\"M\") comando = \"recall\"\nif (this.casttype==\"M\") {\n  spell=\"teleport-w-e\"\n}\nif (this.mustMind) {\n  comando = \"mind\"\n  spell=\"probability\"\n}\nsend(`${comando} ${spell}`);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^fs( forced)?$",
      "id": "",
      "value": "let comando = \"cast\"\nlet spell = \"fires\"\nif (this.mustMemorize && this.casttype.length==1 && this.casttype==\"M\") comando = \"recall\"\nif (this.mustMind) {\n  comando = \"flames\"\n  spell=\"\"\n}\nif (!this.inCombat()||(match && match[1]==\" forced\")) send(`${comando} ${spell}`);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^dispe?l?(.+)?",
      "id": "",
      "value": "cast 'dispel m' $1",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ia",
      "id": "",
      "value": "if (!this.scudoAcid || this.ultimoScudo==this.scudoAcid) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoAcid) send(`get ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n      send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoCold) send(`rem ${this.scudoCold}`);\n  if (this.scudoEle) send(`rem ${this.scudoEle}`);\n  if (this.scudoFire) send(`rem ${this.scudoFire}`);\n}\nsend(`wear ${this.scudoAcid}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoCold) send(`put ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoEle) send(`put ${this.scudoEle} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = false;\nthis.usiImmuAcid = true;\nthis.usiImmuCold = false;\nthis.usiImmuFire = false;\nthis.Immu = \"ACID\";\nthis.ultimoScudo = this.scudoAcid;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ic",
      "id": "",
      "value": "if (!this.scudoCold || this.ultimoScudo==this.scudoCold) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoCold) send(`get ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n      send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoAcid) send(`rem ${this.scudoAcid}`);\n  if (this.scudoEle) send(`rem ${this.scudoEle}`);\n  if (this.scudoFire) send(`rem ${this.scudoFire}`);\n}\nsend(`wear ${this.scudoCold}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoAcid) send(`put ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoEle) send(`put ${this.scudoEle} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = false;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = true;\nthis.usiImmuFire = false;\nthis.Immu = \"COLD\";\nthis.ultimoScudo = this.scudoCold;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ie",
      "id": "",
      "value": "if (!this.scudoEle || this.ultimoScudo==this.scudoEle) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoEle) send(`get ${this.scudoEle} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n        send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoCold) send(`rem ${this.scudoCold}`);\n  if (this.scudoAcid) send(`rem ${this.scudoAcid}`);\n  if (this.scudoFire) send(`rem ${this.scudoFire}`);\n}\nsend(`wear ${this.scudoEle}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoCold) send(`put ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoAcid) send(`put ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = true;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = false;\nthis.usiImmuFire = false;\nthis.Immu = \"ELE\";\nthis.ultimoScudo = this.scudoEle;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "k",
      "id": "",
      "value": "kill $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autofollow ?(.*)?",
      "id": "autofollow",
      "value": "const oldVal = this.autofollow;\n\nthis.autofollow = !this.autofollow;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autofollow = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autofollow\", this.autofollow);\nif (oldVal != this.autofollow) {\n  let str = (\"Autofollow: \"+ (this.autofollow ? \"ABILITATO\" : \"DISABILITATO\"));\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autoorder ?(.*)?",
      "id": "autoorder",
      "value": "const oldVal = this.autoorder;\n\nthis.autoorder = !this.autoorder;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autoorder = (match[1] == \"true\" || match[1] == \"on\");\n}\n\nif (this.Immortal) this.autoorder = false;\n\ntoggleClass(\"autoorder\", this.autoorder);\nif (oldVal != this.autoorder) {\n  let str = (\"Autoorder: \"+ (this.autoorder ? \"ABILITATO\" : \"DISABILITATO\"));\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "tick",
      "id": "",
      "value": "send(\"emote dice: $c0010Tick in $c0009\" + this.TickRemaining + \"$c0015 sec.\");",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^afk( [^ ]+)?$",
      "id": "",
      "value": "const oldVal = this.afk;\nthis.afk = !this.afk;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.afk = (match[1].trim() == \"true\" || match[1].trim() == \"on\");\n}\nif (this.afkProcTimout) clearTimeout(this.afkProcTimout);\ntoggleClass(\"afk\", this.afk);\n\nif (oldVal != this.afk) {\n  if (this.afk) {\n    if (this.pgTitle) send(\"title \" + this.pgTitle + \" $c0008[AFK]$c0007\")\n  } else {\n    if (this.pgTitle) send(\"title \" + this.pgTitle)\n  }\n  let str = \"AFK: \"+ (this.afk ? \"ABILITATO\" : \"DISABILITATO\");\n  this.parlaStato = true\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "soloSettings",
      "id": "",
      "value": "if (this.Immortal) {\n  send(\"alloff\");\n  return;\n} else \ndelay(\"grouping\",2000,()=>{\n  send(\"autosanc off\");\n  send(\"autoassist off\");\n  send(\"autobash off\");\n  send(\"autorescue off\");\n  send(\"autostab off\");\n  if (this.canPlay) send(\"autosong off\");\n  send(\"autoloot on\");\n  send(\"autocast off\");\n  send(\"autostop off\");\n  if (this.healtype || this.canPlay) {\n    if (this.afk) {\n      send(\"autocleric 70\");\n    }\n  } else {\n    send(\"autocleric 0\");\n  }\n  toggleClass(\"indietro\", false)\n});",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "groupSettings",
      "id": "",
      "value": "if (this.Immortal) {\n  send(\"alloff\")\n  return;\n} else\ndelay(\"grouping\",2000,()=>{\n  send(\"autoassist \" + ((this.afk && (this.canBash || this.canStab))?\"on\":\"off\"));\n  if (this.canBash) send(\"autobash \" + ((this.afk && (this.canBash))?\"on\":\"off\"));\n  if (this.canStab || (this.canPlay && this.holdItem != this.strumentoFiato)) {\n    send(\"autostab \" + ((this.afk)?\"on\":\"off\"));\n    send(\"autoarmi off\");\n  \tif (this.afk) send(\"autostop on\");\n  }\n  if (this.canPlay) {\n  \tif (this.afk) {\n      send(\"autosong on\");\n      send(\"war\");\n    }\n  }\n  if (this.canBash) send(\"autorescue \" + ((this.afk && (!this.casttype))?\"on\":\"off\"));\n  send(\"autoloot off\");\n  if (this.afk && (this.healtype || this.canPlay)) send(\"autocleric 70\");\n  toggleClass(\"indietro\", true)\n  if (this.afk && !this.canStab && !this.canBash && (this.autocastSpell||this.spellOffensivo)) {\n    if (!this.canPlay)\n      send(\"autocast \" + (this.autocastSpell||this.spellOffensivo));\n  \telse send(\"autocast off\");\n  } else {\n  \tsend(\"autocast off\");\n  }\n});",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "printGruppo",
      "id": "",
      "value": "if (!this.Gruppo || this.Gruppo[0] != \"{\") { return; }if (!getWindow(\"Gruppo\")) {\n   const data = {\n    name: \"Gruppo\",\n    visible:true,\n    anchorWidth:320\n\t}\n   createWindow(\"Gruppo\",data)\n}\ncls(\"Gruppo\")\nconst grp = JSON.parse(this.Gruppo);\nlet grStr = \"\";\nlet cnt = 1;\nprint(color(` #          PG  ${color(\"HP\",\"red\")}  ${color(\"MN\",\"lightblue\")}  ${color(\"MV\",\"green\")}   SANC DO QUI`,\"gray\"), \"Gruppo\")\nif (!this.colorizeHp) return;\nthis.grandezzaGruppo = 0;\nlet capogruppoInRoom = false;\nfor (let nome in grp) {\n  if (typeof grp[nome] == \"string\") {\n    continue;\n  }\n  this.grandezzaGruppo++;\n  if (this.grandezzaGruppo == 1) {\n    capogruppoInRoom = grp[nome].inroom;\n  }\n  const numero = cnt.toString().padStart(2)+\".\";\n  const pg = this.colorizeHp(grp[nome].hp, nome.substr(0, 10).padStart(10));\n  const hp = this.colorizeHp(grp[nome].hp, grp[nome].hp.toString().padStart(3));\n  const mana = this.colorizeMana(grp[nome].mn, grp[nome].mn.toString().padStart(3));\n  const mov = this.colorizeMov(grp[nome].mv,grp[nome].mv.toString().padStart(3));\n  const sanc = this.colorizeBool(grp[nome].sanc||(this.TSSettore!=\"Chiuso\" && grp[nome].verde), ((grp[nome].sanc>1||(this.TSSettore!=\"Chiuso\" && grp[nome].verde>1)) ? \"+\" : ((grp[nome].sanc==1||(this.TSSettore!=\"Chiuso\" && grp[nome].verde==1))?\"!\":\"-\")).padStart(3));\n  const detect = this.colorizeBool(grp[nome].do, (grp[nome].do ? \"+\" : (grp[nome].do==1?\"!\":\"-\")).padStart(3));\n  const qui = this.colorizeBool(grp[nome].inroom, (grp[nome].inroom ? \"+\" : \"-\").padStart(3));\n  const hide = (grp[nome].hide ? \"+\" : \"-\").padStart(3);\n  const linea = color(`${numero} ${pg}: ${hp} ${mana} ${mov}  ${sanc} ${detect} ${qui}\\n`, \"lightgray\");\n  cnt++;\n  grStr += linea;\n}\nprint(grStr, \"Gruppo\")\nif(this.checkRimastoIndietro) {\n  this.checkRimastoIndietro = false;\n  if (!capogruppoInRoom && this.grandezzaGruppo > 1) {\n    send(\"gtTrigger $c5009Sono $c5009rimasto $c5009indietro!\");\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^bark (.*)|^bark$",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nsend(\"cast 'bark' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^anim (.*)|^anim",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nsend(\"cast 'animal a' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^do (.+)$|^do$",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nsend(\"cast 'detect o' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^sanc( .+)$|^sanc$",
      "id": "",
      "value": "if (!this.healtype) {\n  send(\"~sanc\");\n  return;\n}\nlet target = match[1] || this.TSPersonaggio\nlet spell = (this.healtype == \"C\" ? \"sanc\" : \"natures pro\");\nif (this.isTank()) {\n  print(\"Sanc mentre stai tankando!??\")\n  return;\n}\nif (this.TSPosizione!=\"In piedi\") {\n  send(\"stand\")\n}\nif (this.inCombat()) {\n  send(\"~stop\")\n}\nsend(\"~cast '\" + spell + \"' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^chain( .+)$|^chain$",
      "id": "",
      "value": "let comando = \"cast\"\nif (this.mustMemorize) comando = \"recall\"\nlet target = match[1] || this.TSPersonaggio\nsend(`${comando} 'chain l' `+target);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(storm|sblinka)",
      "id": "",
      "value": "send(\"cast 'firesto'\");",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "blunt",
      "id": "",
      "value": "if (!this.armaBlunt || this.ultimaArma == this.armaBlunt) return;\n//send(`rem ${this.borsa}`);\nsend(`get ${this.armaBlunt} ${this.borsaArmi||this.borsa}`);\nif (this.ultimaArma) {\n  send(`rem ${this.ultimaArma}`);\n} else {\n  if (this.armaSlash) send(`rem ${this.armaSlash}`);\n  if (this.armaExtra) send(`rem ${this.armaExtra}`);\n  if (this.armaPierce) send(`rem ${this.armaPierce}`);\n  if (this.arco) send(`rem ${this.arco}`);\n}\nsend(`~wield ${this.armaBlunt}`);\nif (this.ultimaArma) {\n  send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.armaExtra) send(`put ${this.armaExtra} ${this.borsaArmi||this.borsa}`);\n  if (this.armaPierce) send(`put ${this.armaPierce} ${this.borsaArmi||this.borsa}`);\n  if (this.armaSlash) send(`put ${this.armaSlash} ${this.borsaArmi||this.borsa}`);\n  if (this.arco) send(`put ${this.arco} ${this.borsaArmi||this.borsa}`);\n}\nif (this.usiArco) {\n  send(`put faretra ${this.borsaArmi||this.borsa}`);\n  if (this.freccia) send(`put ${this.freccia} ${this.borsaArmi||this.borsa}`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiSlash = false;\nthis.usiBlunt = true;\nthis.usiPierce = false;\nthis.usiExtra = false;\nthis.usiArco = false;\nthis.ultimaArma = this.armaBlunt;",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "pierce",
      "id": "",
      "value": "if (!this.armaPierce || this.ultimaArma == this.armaPierce) return;\n//send(`rem ${this.borsa}`);\nsend(`get ${this.armaPierce} ${this.borsaArmi||this.borsa}`);\nif (this.ultimaArma) {\n  send(`rem ${this.ultimaArma}`);\n} else {\n  if (this.armaSlash) send(`rem ${this.armaSlash}`);\n  if (this.armaExtra) send(`rem ${this.armaExtra}`);\n  if (this.armaBlunt) send(`rem ${this.armaBlunt}`);\n  if (this.arco) send(`rem ${this.arco}`);\n}\nsend(`~wield ${this.armaPierce}`);\nif (this.ultimaArma) {\n  send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.armaExtra) send(`put ${this.armaExtra} ${this.borsaArmi||this.borsa}`);\n  if (this.armaBlunt) send(`put ${this.armaBlunt} ${this.borsaArmi||this.borsa}`);\n  if (this.armaSlash) send(`put ${this.armaSlash} ${this.borsaArmi||this.borsa}`);\n  if (this.arco) send(`put ${this.arco} ${this.borsaArmi||this.borsa}`);\n}\n//send(`wear ${this.borsa}`);\nif (this.usiArco) {\n  send(`put faretra ${this.borsaArmi||this.borsa}`);\n  if (this.freccia) send(`put ${this.freccia} ${this.borsaArmi||this.borsa}`)\n}\nthis.usiSlash = false;\nthis.usiBlunt = false;\nthis.usiPierce = true;\nthis.usiExtra = false;\nthis.ultimaArma = this.armaPierce;",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "slash",
      "id": "",
      "value": "if (!this.armaSlash || this.ultimaArma == this.armaSlash) return;\n//send(`rem ${this.borsa}`);\nsend(`get ${this.armaSlash} ${this.borsaArmi||this.borsa}`);\nif (this.ultimaArma) {\n  send(`rem ${this.ultimaArma}`);\n} else {\n  if (this.armaPierce) send(`rem ${this.armaPierce}`);\n  if (this.armaExtra) send(`rem ${this.armaExtra}`);\n  if (this.armaBlunt) send(`rem ${this.armaBlunt}`);\n  if (this.arco) send(`rem ${this.arco}`);\n}\nsend(`~wield ${this.armaSlash}`);\nif (this.ultimaArma) {\n  send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.armaExtra) send(`put ${this.armaExtra} ${this.borsaArmi||this.borsa}`);\n  if (this.armaBlunt) send(`put ${this.armaBlunt} ${this.borsaArmi||this.borsa}`);\n  if (this.armaPierce) send(`put ${this.armaPierce} ${this.borsaArmi||this.borsa}`);\n  if (this.arco) send(`put ${this.arco} ${this.borsaArmi||this.borsa}`);\n}\n//send(`wear ${this.borsa}`);\nif (this.usiArco) {\n  send(`put faretra ${this.borsaArmi||this.borsa}`);\n  if (this.freccia) send(`put ${this.freccia} ${this.borsaArmi||this.borsa}`)\n}\nthis.usiSlash = true;\nthis.usiBlunt = false;\nthis.usiPierce = false;\nthis.usiExtra = false;\nthis.usiArco = false;\nthis.ultimaArma = this.armaSlash;",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "pb (.*)",
      "id": "",
      "value": "//send(`rem ${this.borsa}`);\nsend(`put ${match[1]} ${this.borsa}`);\n//send(`wear ${this.borsa}`);",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "gb (.*)",
      "id": "",
      "value": "//send(`rem ${this.borsa}`);\nsend(`get ${match[1]} ${this.borsa}`);\n//send(`wear ${this.borsa}`);",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^hum (.+)|^hum",
      "id": "",
      "value": "let target = match[1] || this.TSPersonaggio\nif (this.TSSettore == \"Chiuso\") {\n\tsend(\"cast 'bloom'\");\n}\nsend(\"cast 'humanoid g' \" + target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^bloom",
      "id": "",
      "value": "cast 'bloom'",
      "regex": true,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "generaFunzioni",
      "id": "",
      "value": "this.autoKillMobs = this.autoKillMobs || \"\"\nthis.dangerMobs = this.dangerMobs || \"karoz barbaro errante\"\n\nthis.getAutokillMobs = () => {\nreturn (this.autoKillMobs||\"\").split(\"|\").filter(v => v)\n}\n\nthis.isDangerousMob = m => {\n  return (this.dangerMobs||\"\").split(\"|\").filter(v => v).indexOf(m)>-1\n}\n\nconst evList = {}\nthis.roomEnterEvents = () => evList; \n\nthis.onRoomEnter = (r,f) => {\n  this.roomEnterEvents()[r] = f\n}\n\nthis.getAutoKillTarget = () => {\n  const mobsInRoom = (this.Mobs||\"\").split(\"|\").filter(v => v)\n  let target = null;\n  for (let m of mobsInRoom) {\n    if (this.isDangerousMob(m)) {\n      print(\"Ci sono mob pericolosi!\");\n      return null;\n    } else if (this.getAutokillMobs().indexOf(m)>-1) {\n      target = m;\n    }\n  }\n  //if (target) print(\"Target: \" + target)\n  return target;\n}\n\nthis.setupAutoKillList = () => {\n  let toKill = this.getAutokillMobs();\n  const mobsInRoom = (this.Mobs||\"\").split(\"|\").filter(v => v)\n  for (let m of mobsInRoom) {\n    const toKillindex = toKill.indexOf(m);\n    if (toKillindex>-1) {\n    \tprint(link(\"Rimuovi \" + m + \" da AutoKill\", () => {\n          toKill.splice(toKillindex, 1)\n          toKill = [...new Set(toKill)]; // unique\n          print(\"Rimosso \" + m+ \" da AutoKill\");\n          this.autoKillMobs = toKill.join(\"|\")\n        }))\n    } else {\n        print(link(\"Aggiungi \" + m + \" a AutoKill\", () => {\n          toKill.push(m)\n          toKill = [...new Set(toKill)]; // unique\n          print(\"Aggiungo \" + m + \" a AutoKill\");\n          this.autoKillMobs = toKill.join(\"|\")\n        }))\n    }\n  }\n}\nthis.pgInGruppo = function(x) {\n  if (!this.Gruppo) return [this.TSPersonaggio];\n  let gruppo = JSON.parse(this.Gruppo);\n  let k = Object.keys(gruppo).slice(2);\n  if (x) {\n    let found = (k.find((v) => v.toLowerCase().startsWith(x.toLowerCase())));\n    if (found) return [...found]; else return [];\n  }\n  else \n  {\n    return k;\n  }\n}\nthis.digCut = function(command, key) {\n  if (!this.ultimaArma) {\n    if (!this.armaPrimaria || (this.usiLuce && this.holdItem)) {\n    \tthis.ultimaArma = this.holdItem;\n    } else {\n  \t\tsend(this.armaPrimaria)\n    }\n  }\n  const cambiaArma = (this.ultimaArma!=this.armaDigCut)\n  if (cambiaArma) {\n    send(`rem ${this.ultimaArma}`)\n    send(`gb ${this.armaDigCut}`)\n    send(`~wield ${this.armaDigCut}`)\n  }\n  send(`~${command} ${key}`)\n  if (cambiaArma) {\n    send(`rem ${this.armaDigCut}`)\n    send(`~${this.ultimaArma == this.holdItem ? \"hold\" : \"wield\"} ${this.ultimaArma}`)\n    send(`pb ${this.armaDigCut}`)\n  }\n}\nthis.isCapogruppo = function(x) {\n  if (!this.Gruppo) return false;\n  let gruppo = JSON.parse(this.Gruppo);\n  let k = Object.keys(gruppo).slice(2);\n  if (!x) {\n    x = this.TSPersonaggio;\n  } else {\n    x = x.split(\" \")[0];\n  }\n  if (k && k[0]) {\n    return k[0].toLowerCase().startsWith(x.toLowerCase())\n  }\n  return false;\n}\n\nthis.diciStatus = function (str) {\n  print(str);\n  if (this.pgInGruppo().length > 1 && (this.afk || this.parlaStato)) {\n    send(\"gtTrigger \" + str);\n  }\n  this.parlaStato = false;\n}\nthis.colorizeHp = function(num, str) {\n  if (num > 95) {\n    return color(str, \"lightgray\");\n  } else if (num > 90) {\n    return color(str, \"green\");\n  } else if (num > 70) {\n    return color(str, \"lightgreen\");\n  } else if (num > 40) {\n    return color(str, \"yellow\", null, true, false, false);\n  } else if (num > 20) {\n    return color(str, \"orange\", null, true, true, false);\n  } else {\n    return color(str, \"red\", null, true, true, true);\n  }\n}\n\nthis.colorizeMana = function(num, str) {\n  if (num > 90) {\n    return color(str, \"lightgray\");\n  } else if (num > 70) {\n    return color(str, \"blue\");\n  } else if (num > 40) {\n    return color(str, \"lightblue\", null, true, false, false);\n  } else if (num > 20) {\n    return color(str, \"lightblue\", null, true, true, false);\n  } else {\n    return color(str, \"lightblue\", null, true, true, true);\n  }\n}\n\nthis.colorizeMov = function(num, str) {\n  if (num > 90) {\n    return color(str, \"lightgray\");\n  } else if (num > 70) {\n    return color(str, \"gray\");\n  } else if (num > 40) {\n    return color(str, \"gray\", null, false, false, false);\n  } else if (num > 20) {\n    return color(str, \"lightgray\", null, true, false, false);\n  } else {\n    return color(str, \"lightgray\", null, true, false, true);\n  }\n}\nthis.colorizeBool = function(v, str) {\n  if (!v) {\n    return color(str, \"yellow\", null, true, false, true);\n  } else {\n    return color(str, \"white\", null, true, false, false);\n  }\n}\nthis.isTank = (pg) => {\n  if (!pg) pg = this.TSPersonaggio;\n  return this.TSTank.toLowerCase()==pg.split()[0].toLowerCase();\n}\n\nthis.inCombat = () => {\n  return this.TSMobCond!=\"*\";\n}\nthis.coloraComunicazione = (str) => {\n  let words = str.split(\" \");\n  let colori = this.colori ? (typeof this.colori == 'string' ? [this.colori] : this.colori) : [\"$c0009\"];\n  for (let i = 0; i < Math.min(words.length,colori.length); i++) {\n    words[i] = colori[i]+words[i];\n  }\n  return words.join(\" \");  \n}\nthis.titleCase = function(txt) {\n  if (!txt) return \"\";\n  return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n}\nthis.cleanupName = (tank) => {\n  // per i monsum / charm\n  return tank.replace(/^(un'|l'|il |lo |un |una |uno |la |the )/gi, \"\")\n    .trim()\n    .split(' ')[0];\n}\nthis.limitaLista = (lista) => {\n  if (!lista) return;\n  if (lista.size) {\n    const surplus = lista.size - 600;\n    for (let i = 0; i < surplus; i++) {\n      lista.delete(lista.keys().next)\n    }\n  } else if (lista.length) {\n    const surplus = lista.length - 600;\n    for (let i = 0; i < surplus; i++) {\n      lista.splice(0, 1)\n    }\n  }\n}\nthis.stat = (tipo, quantita) => {\n  if (!this[\"lista\"+tipo] || !this[\"lista\"+tipo].set) {\n    this[\"lista\"+tipo] = new Map();\n  }\n  const lista = this[\"lista\"+tipo];\n  lista.set(new Date(), quantita);\n  this.limitaLista(lista);\n}\n\nconst tfunc = () => {\n  window.removeEventListener(\"touchstart\", tfunc);\n  const prev = this.usesTouch;\n  this.usesTouch = true;\n  if (this.usesTouch && !prev) {\n    print(\"Touchscreen rilevato\");\n  }\n};\nwindow.addEventListener('touchstart', tfunc);\n\nthis.rotazioneArmi = () => {\n  if (this.usiBlunt) {\n    if (this.ordineArmi == \"1\") {\n      send(\"pierce\")\n    } else if (this.ordineArmi == \"2\") {\n      send(\"slash\")\n    }\n  }\n  else if (this.usiSlash) {\n    if (this.ordineArmi == \"1\") {\n      send(\"blunt\")\n    } else if (this.ordineArmi == \"2\") {\n      send(\"pierce\")\n    }\n  }\n  else if (this.usiPierce) {\n    if (this.ordineArmi == \"1\") {\n      send(\"slash\")\n    } else if (this.ordineArmi == \"2\") {\n      send(\"blunt\")\n    }\n  }\n  else {\n    if (this.armaPrimaria) send(this.armaPrimaria)\n  }\n}\n\nconst printPageWrap = (pageFunc, window, title, pageIndex, pageSize) => {\n  cls(window)\n  if (this.debug) print(`Mostro pagina ${pageIndex} di ` + window)\n  print(color(title,\"lighgreen\")+ \"\\n\",window)\n  \n  const numPages = Math.ceil(pageFunc(pageIndex, pageSize) / pageSize)\n  const prevPage = Math.max(pageIndex - 1, 0)\n  const nextPage = Math.min(pageIndex + 1, numPages - 1)\n  \n  const footer = (pageIndex > 0 ? link(\"<== \", () => printPageWrap(pageFunc, window, title, prevPage, pageSize)) : \"<== \") +\n        \" Pag.\" + (pageIndex+1)  + \"/\" + numPages + \" \" +\n        (pageIndex < numPages - 1 ? link(\" ==>\", () => printPageWrap(pageFunc, window, title, nextPage, pageSize)) : \" ==>\")\n  \n  print(\"\\n\" + footer,window);\n}\n\nthis.pageContent = async (window, pageFunc, title = \"\", pageIndex = 0, pageSize = 20, w, h, x, y) => {\n\n  let wnd = getWindow(window)\n  if (wnd?.data?.collapsed) {\n    // se c'e' ed era colassata serve tweakare e ricreare con i wnd.data\n    deleteWindow(window,true)\n    wnd.data.collapsed = false;\n    wnd.initialized = true; // prevent docking\n    wnd = createWindow(window, wnd.data)\n  }\n  \n  if (!wnd) {\n    // se non esiste questi sono i default\n    const data = {\n      w: w || 400,\n      h: h || 450,\n      x: x || 300,\n      y: y || 300,\n      visible: false,\n      collapsed: false,\n      docked:false\n    }\n  \twnd = createWindow(window, data)\n    wnd.initialized = true; // prevent docking\n  }\n  \n  let tmpdata = null;\n  \n  if (wnd) {\n    // se esiste ed era chiusa serve tweakarla\n    wnd.initialized = true;    // no docking\n    tmpdata = wnd.data;\n    \n    if (tmpdata) { // togli la roba fatta dall user\n      if (w) tmpdata.w = w;\n      if (h) tmpdata.h = h;\n      if (x) tmpdata.x = x;\n      if (y) tmpdata.y = y;\n    \ttmpdata.visible = true;\n      \ttmpdata.collapsed = false;\n      \ttmpdata.docked = false;\n    }\n    // la cancello cosi la ricrea con i tmpdata\n    await outputManager.getWindowManager().destroyWindow(window,true)\n  }\n  wnd = createWindow(window, tmpdata)\n  if (wnd) wnd.initialized = true; // non si sa mai, prevent docking\n\n  printPageWrap(pageFunc, window, title, pageIndex, pageSize)\n  \n}",
      "regex": false,
      "is_script": true,
      "class": "config",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^selfshield(.*)",
      "id": "",
      "value": "this.selfshield = !this.selfshield;\n\nif (match && match[1] != undefined && match[1].trim().length) {\n\tthis.selfshield = (match[1].trim() == \"true\" || match[1].trim() == \"on\");\n}\n\ntoggleClass(\"selfshield\", this.selfshield);\nlet str = \"Selfshield: \"+ (this.selfshield ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^selfsanc(.*)",
      "id": "",
      "value": "const orig = this.selfsanc;\nthis.selfsanc = !this.selfsanc;\n\nif (match && match[1] != undefined && match[1].trim().length) {\n\tthis.selfsanc = (match[1].trim() == \"true\" || match[1].trim() == \"on\");\n}\n\ntoggleClass(\"selfsanc\", this.selfsanc);\nlet tipoSanc = \"Selfsanc\"\nif (this.healtype==\"C\" && (!this.casttype||this.casttype==\"C\") && !this.canBash && !this.canStab && this.pgInGruppo()?.length>1) {\n  tipoSanc = \"AutoGard\";\n}\nlet str = tipoSanc + \": \"+ (this.selfsanc ? \"ABILITATO\" : \"DISABILITATO\");\nif (orig != this.selfsanc) this.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "immuacid",
      "id": "",
      "value": "ia",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immucold",
      "id": "",
      "value": "ic",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immuele",
      "id": "",
      "value": "ie",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(gui|guild|gt|ot|sh|t \\w+|tell \\w+|hg|herog|shout|suss \\w+|gos|goss|gossip|grida|say|send \\w+|telep \\w+|mess \\w+) (.*)$",
      "id": "",
      "value": "const comunicazioni = {\n  gui: \"guildt\",\n  guild: \"guildt\",\n  gt: \"gte\",\n  ot: \"ot\",\n  sh: \"shout\",\n  t: \"tell\",\n  tell: \"tell\",\n  hg: \"herog\",\n  herog: \"herog\",\n  shout: \"shout\",\n  suss: \"suss\",\n  gos: \"gossip\",\n  goss: \"gossip\",\n  gossip: \"gossip\",\n  grida: \"shout\",\n  say: \"say\",\n  send: \"send\",\n  telep: \"telep\",\n  mess: \"mess\"\n}\nconst comm = match[1].split(\" \")[0];\nconst destinatario = match[1].split(\" \")[1] || \"\";\nsend(\"~\" + comunicazioni[comm] + \" \" + destinatario + \" \"+ this.coloraComunicazione(match[2]) + \"$c0007\");",
      "regex": true,
      "is_script": true,
      "class": "comunicazione",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "gtTrigger",
      "id": "",
      "value": "gt (trigger) $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "status",
      "id": "",
      "value": "let status = \"\";\nstatus+=`AASS:${this.autoassist?\"ON\":\"OFF\"} `;\nif (this.canBash) status+=`ABASH:${this.autobash?\"ON\":\"OFF\"} `;\nif (this.canStab) status+=`ASTAB:${this.autostab?\"ON\":\"OFF\"} `;\nif (this.spellOffensivo) status+=`ACAST:${this.autocast?\"ON\":\"OFF\"} `;\nstatus+=`ACL:${classEnabled(\"autocleric\")?this.aclMinimum+\"%\":\"OFF\"} `;\nstatus+=`ASANC:${classEnabled(\"autosanc\")?\"(\" + this.listaAutosanc.join(\",\") + \")\":\"OFF\"} `;\nif (this.healtype) status+=`SELFSANC:${this.selfsanc?\"ON\":\"OFF\"} `;\nif (this.spellOffensivo||this.healtype) status+=`SELFSHIELD:${this.selfshield?\"ON\":\"OFF\"} `;\nif (this.autokill) status+=`AKILL:(Krall,Stabh,Daemion,Grigie,Toewin,Geldor) `;\nthis.parlaStato = true;\nthis.diciStatus(status);\nthis.parlaStato = false;",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "autosanc",
      "id": "",
      "value": "asanc $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^asanc ?(.+)?$",
      "id": "",
      "value": "let orig = this.autosanc;\nthis.autosanc = !(this.autosanc||false);\nlet pg = (match[1]||\"\").trim();\nif (pg == \"off\" || pg == \"false\") {\n  this.autosanc = false;\n  this.listaAutosanc = [];\n  toggleClass(\"autosanc\", this.autosanc);\n  if (orig != this.autosanc) this.diciStatus(\"Autosanc: \" + (this.autosanc ? (this.listaAutosanc.length ? this.listaAutosanc : [\"[Nessuno]\"]).join(\",\") : \"DISABILITATO\"))\n  return;\n}\nif (pg) {\n  pg = this.titleCase(pg);\n  this.autosanc = true;\n  orig = null;\n}\nthis.listaAutosanc = this.listaAutosanc || [];\nif (pg) {\n  let index = this.listaAutosanc.indexOf(pg);\n  if (index>-1) {\n    this.listaAutosanc.splice(index,1);\n  } else {\n    this.listaAutosanc.push(pg);\n  }\n}\ntoggleClass(\"autosanc\", this.autosanc);\nlet str = \"Autosanc: \" + (this.autosanc ? (this.listaAutosanc.length ? this.listaAutosanc : [\"[Nessuno]\"]).join(\",\") : \"DISABILITATO\");\nif (orig != this.autosanc) this.diciStatus(str)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "afkProc",
      "id": "",
      "value": "if (this.Immortal) return;\nif (!this.inCombat()) {\n  if (this.TSSpells.toLowerCase().indexOf(\"o\")==-1 && this.healtype==\"D\") {\n    if (classEnabled(\"druid\")) send(\"do\");\n  }\n  if (this.TSSpells.toLowerCase().indexOf(\"f\")==-1 && this.selfshield) {\n    send(\"fs\");\n  }\n  if (this.TSSpells.toLowerCase().indexOf(\"s\")==-1 && this.healtype==\"C\" && this.selfsanc) {\n    send(\"sanc\");\n  } else if (this.TSSpells.toLowerCase().indexOf(\"n\")==-1 && this.healtype==\"D\" && this.selfsanc) {\n    if (this.TSSettore != \"Chiuso\" && this.TSSpells.toLowerCase().indexOf(\"s\")==-1) send(\"sanc\");\n  }\n  \n  if (this.afk && this.TSSpells.toLowerCase().indexOf(\"g\")==-1 && this.healtype==\"D\") {\n    if (this.TSSettore != \"Chiuso\" && classEnabled(\"druid\")) send(\"hum\");\n  }\n}\nsend(\"sancaAutosanc\")",
      "regex": false,
      "is_script": true,
      "class": "afk",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "align",
      "id": "",
      "value": "toggleClass(\"gtalign\",true);\nsend(\"score\");",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^sayStatus (.+)$",
      "id": "",
      "value": "this.diciStatus(match[1].trim())",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "manca",
      "id": "",
      "value": "var grp = JSON.parse(this.Gruppo)\nconst mancanti = [];\nfor (let nome in grp) {\n  \tif (typeof grp[nome] == 'string') continue;\n    if (!grp[nome].inroom) {\n      mancanti.push(nome);\n    }\n}\nif (mancanti.length) {\n  send(\"gtTrigger Manca\" + (mancanti.length>1 ? \"no\" : \"\") + \": \" + mancanti.join(\",\"));\n} else {\n  send(\"gtTrigger Ci siamo tutti!\");\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "grow",
      "id": "",
      "value": "hum",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "fog",
      "id": "",
      "value": "cast 'reveal'",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^rescue( .*)?$",
      "id": "",
      "value": "let target = input.split(\" \")[1] || this.TSTank;\nsend(\"~rescue \" + target);",
      "regex": true,
      "is_script": true,
      "class": "combat",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "r",
      "id": "",
      "value": "rescue $1",
      "regex": false,
      "is_script": false,
      "class": "combat",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "pola (.+)",
      "id": "",
      "value": "if (!match[1].trim()) {\n  print(\"Polare senza creatura specificata non va...\");\n}\nlet spell = \"poly\";\nlet comando = \"cast\"\nif (this.healtype == \"D\") {\n  spell = \"change f\"\n}\nif (this.mustMemorize) {\n  comando = \"recall\"\n}\n\nsend(`${comando} '${spell}' ${match[1].trim()}`);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immuice",
      "id": "",
      "value": "immucold $1",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "portal ?(.+)",
      "id": "",
      "value": "if (!match[1]) {\n  print(\"Si ma su di chi??\");\n}\nlet spell = \"portal\"\nsend(`cast '${spell}' ${match[1]}`)",
      "regex": true,
      "is_script": true,
      "class": "mage",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^gfly$",
      "id": "",
      "value": "let comando = \"cast\";\nif (this.mustMemorize) {\n  comando = \"recall\";\n}\nsend(`${comando} 'group f'`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^fly( .+)$|^fly$",
      "id": "",
      "value": "let comando = \"cast\"\nif (this.mustMemorize && !this.healtype) comando = \"recall\"\nlet target = match[1] || this.TSPersonaggio\nsend(`${comando} 'fly' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^ts( .+)$|^ts$",
      "id": "",
      "value": "let comando = \"cast\"\nlet target = match[1] || this.TSPersonaggio\nsend(`${comando} 'true s' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^flo( .+)$|^flo$",
      "id": "",
      "value": "let comando = \"cast\"\nlet target = match[1] || this.TSMob\nsend(`${comando} 'floating l' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^heat( .+)$|^heat$",
      "id": "",
      "value": "let comando = \"cast\"\nlet target = match[1] || this.TSMob\nsend(`${comando} 'heat st' ${target}`)",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^shuri( .+)$|^shuri$",
      "id": "",
      "value": "send(`gb ${this.throwObject}`)\nif (match[1])\n  send(`throw ${this.throwObject} ${match[1]}`)",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(rece|casa)$",
      "id": "",
      "value": "if (this.healtype == \"D\") {\n  if (this.TSSettore==\"Chiuso\") {\n    send(\"bloom\")\n  }\n  send(\"tran vertus\");\n  send(\".13eneu\")\n} else if (this.healtype==\"C\" || this.canPlay) {\n  send(\"cast 'word'\")\n} else {\n  send(\"gb scrigno-ritorno\")\n  send(\"get ritorno scrigno-ritorno\")\n  send(\"pb scrigno-ritorno\")\n  send(\"rec rito\")\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "updateCombatStatus",
      "id": "",
      "value": "function getPercent(str) {\n  switch (str) {\n  case \"eccellente\":\n\treturn 100;\n  case \"graffiato\":\n\treturn 95;\n  case \"tagliato\":\n\treturn 85;\n  case \"ferito\":\n\treturn 65;\n  case \"sanguinante\":\n\treturn 40;\n  case \"squarciato\":\n\treturn 25;\n  case \"devastato\":\n\treturn 10;\n  case \"morente\":\n\treturn 1;\n\t}\n  return 100;\n}\nthis.tankMax = 100;\nthis.tankPercent = getPercent(this.TSTankCond)\nthis.tankKey = (this.TSTank||\"*\").split(\" \")[0]\nthis.tankKey = [this.tankKey[0].toUpperCase(),...this.tankKey.slice(1)].join(\"\")\nthis.mobMax = 100;\nthis.mobPercent = getPercent(this.TSMobCond)\nthis.mobKey = (this.TSMob||\"*\").split(\" \")[0]\nthis.mobKey = [this.mobKey[0].toUpperCase(),...this.mobKey.slice(1)].join(\"\")\nlet spells = this.TSSpells;\nthis.spells=\"\";\nfor (let i=0;i<spells.length;i++) {\n  switch (spells[i]) {\n    case 'F':\n    case 'f':\n      {\n        switch (spells[i+1]) {\n          case '2':\n            this.spells += color(spells[i],\"lightblue\", null, true)\n            i++;\n            break;\n          case '3':\n            this.spells += color(spells[i],\"blue\", null, true)\n            i++;\n            break;\n          case '4':\n            this.spells += color(spells[i],\"yellowgreen\", null, true)\n            i++;\n            break;\n          case '3':\n            this.spells += color(spells[i],\"yellow\", null, true)\n            i++;\n            break;\n          default:\n            this.spells += color(spells[i],\"red\", null, true)\n        }\n      }\n      break;\n    case 'S':\n    case 's':\n      this.spells += color(spells[i],\"white\", null, true)\n      break;\n    case 'N':\n    case 'n':\n      this.spells += color(spells[i],\"green\", null, true)\n      break;\n    case 'A':\n    case 'a':\n      this.spells += color(spells[i],\"blue\", null, true)\n      break;\n    case 'I':\n    case 'i':\n      this.spells += color(spells[i],\"cyan\", null, true)\n      break;\n    case 'D':\n    case 'd':\n      this.spells += color(spells[i],\"gray\", null, true)\n      break;\n    case 'G':\n    case 'g':\n      this.spells += color(spells[i],\"maroon\", null, true)\n      break;\n    default:\n      this.spells += spells[i]\n  }\n}\nif (this.TSSpells.toLowerCase().indexOf(\"s\")==-1) {\n  this.sancato = false;\n  this.scadenzaSanc = false;\n  if (window.sancTimeout) {\n      clearTimeout(window.sancTimeout);\n      window.sancTimeout = null;\n    }\n} else {\n  this.sancato = true;\n}\nif (this.TSSpells.toLowerCase().indexOf(\"f\")==-1) {\n  this.scudato = false;\n  this.scadenzaScudo = false;\n  if (window.scudoTimeout) {\n      clearTimeout(window.scudoTimeout);\n      window.scudoTimeout = null;\n    }\n} else {\n  this.scudato = true;\n}\nthis.spells+=color(\"B:\"+this.TSBlink,\"magenta\",null,true)",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "sr",
      "id": "",
      "value": "if (this.healtype==\"C\") {\n  send(\"cast 'shield r'\")\n} else {\n\tsend(\"gb scrigno-libro\")\n\tsend(\"get libro scrigno\")\n\tsend(\"pb scrigno-libro\")\n\tsend(\"rec libro\")\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "attack ?(.+)?",
      "id": "",
      "value": "if (!match[1] && (!this.Mobs || !this.Mobs.length)) {\n\treturn;\n}\nlet mob = this.Mobs ? this.Mobs.split(\"|\").filter(m => {\n\treturn m.indexOf(\"famiglio\")<0;\n}) : [];\nlet victim = match[1] || (mob[0] ? mob[0] : \"\");\nif (!victim) return;\n\nvictim = victim.replace(/ /g, \"-\")\nif (this.canStab) {\n  send(\"backstab \" + victim);\n}\nelse if (this.canPlay) {\n  send(\"slam \" + victim);\n}\nelse if (this.canBash) {\n  send(\"bash \" + victim);\n}\nelse if (this.canKick) {\n  send(\"kick \" + victim);\n}else {\n  if (this.spellOffensivo) {\n    send(\"casta \" + victim);\n  } else {\n\tsend(\"hit \" + victim);\n  }\n}\nthis.onetimeLook = true;",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^rp (.+)",
      "id": "",
      "value": "cast 'remove pa' $1",
      "regex": true,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "extra",
      "id": "",
      "value": "if (!this.armaExtra || this.ultimaArma == this.armaExtra) return;\n//send(`rem ${this.borsa}`);\nsend(`get ${this.armaExtra} ${this.borsaArmi||this.borsa}`);\nif (this.ultimaArma) {\n  send(`rem ${this.ultimaArma}`);\n} else {\n  if (this.armaPierce) send(`rem ${this.armaPierce}`);\n  if (this.armaSlash) send(`rem ${this.armaSlash}`);\n  if (this.armaBlunt) send(`rem ${this.armaBlunt}`);\n  if (this.arco) send(`rem ${this.arco}`);\n}\nsend(`~wield ${this.armaExtra}`);\nif (this.ultimaArma) {\n  send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.armaSlash) send(`put ${this.armaSlash} ${this.borsaArmi||this.borsa}`);\n  if (this.armaBlunt) send(`put ${this.armaBlunt} ${this.borsaArmi||this.borsa}`);\n  if (this.armaPierce) send(`put ${this.armaPierce} ${this.borsaArmi||this.borsa}`);\n  if (this.arco) send(`put ${this.arco} ${this.borsaArmi||this.borsa}`);\n}\n//send(`wear ${this.borsa}`);\nif (this.usiArco) {\n  send(`put faretra ${this.borsaArmi||this.borsa}`);\n  if (this.freccia) send(`put ${this.freccia} ${this.borsaArmi||this.borsa}`)\n}\nthis.usiSlash = false;\nthis.usiBlunt = false;\nthis.usiPierce = false;\nthis.usiExtra = true;\nthis.usiArco = false;\nthis.ultimaArma = this.armaExtra;",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autocast ?(?:(.+))?",
      "id": "autocast",
      "value": "let oldVal = this.autocast;\n\nlet aca = classEnabled(\"autocast\");\nif (match && match[1] != undefined && match[1]==\"off\") {\n  aca = false;\n} else if (match && match[1] != undefined && match[1]==\"on\") {\n  aca = this.spellOffensivo || \"meteor swarm\"\n}\nelse if (match && match[1] != undefined) {\n  \toldVal = null;\n\taca = match[1];\n} else if (!match || !match[1]) {\n  aca = !aca;\n}\nthis.autocast = aca != false;\nif (!aca) {\n  if (oldVal != this.autocast) this.diciStatus(\"AutoCast OFF\");\n  toggleClass(\"autocast\", false);\n}\nelse {\n  if (aca == true) {\n    aca = this.spellOffensivo || \"meteor swarm\";\n  }\n  this.spellOffensivo = aca;\n  let str = (\"AutoCast ON (\" + this.spellOffensivo + \")\");\n  toggleClass(\"autocast\", true);\n  if (oldVal != this.autocast) {\n    this.diciStatus(str);\n  \tthis.TSTankCond=\"*\";\n    this.TSTank=\"*\";\n    send(\"checkAssist\");\n  }\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autorescue ?(.*)?",
      "id": "autorescue",
      "value": "const oldVal = this.autorescue;\nthis.autorescue = !this.autorescue;\n\nif (match && match[1] != undefined) {\n\tthis.autorescue = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autorescue\", this.autorescue);\nif (oldVal != this.autorescue) {\n\tlet str = \"AutoRescue: \"+ (this.autorescue ? \"ABILITATO\" : \"DISABILITATO\");\n\tthis.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autostop ?(.*)?",
      "id": "autostop",
      "value": "const oldVal = this.autostop;\n\nthis.autostop = !this.autostop;\n\nif (match && match[1] != undefined) {\n\tthis.autostop = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autostop\", this.autostop);\nlet str = \"AutoStop: \"+ (this.autostop ? \"ABILITATO\" : \"DISABILITATO\");\nif (oldVal != this.autostab) {\n  this.diciStatus(str);\n}\nif (!this.autostop) {\n  this.TSTankCond=\"*\";\n  this.TSTank=\"*\";\n  send(\"checkAssist\");\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^autoarmi ?(.*)?",
      "id": "autoarmi",
      "value": "const oldVal = this.autoarmi;\n\nthis.autoarmi = !this.autoarmi;\n\nif (match && match[1] != undefined) {\n\tthis.autoarmi = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoarmi\", this.autoarmi);\nlet str = \"AutoArmi: \"+ (this.autoarmi ? \"ABILITATO\" : \"DISABILITATO\");\nthis.cambiArma = 0;\nthis.missARound = 0;\nthis.impugnatoArma=true;\nif (oldVal != this.autoarmi) {\n\tthis.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^antispalm ?(.*)?",
      "id": "antispalm",
      "value": "this.antispalm = !this.antispalm;\n\nif (match && match[1] != undefined) {\n\tthis.antispalm = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"antispalm\", this.antispalm);\nlet str = \"AntiSpalm: \"+ (this.antispalm ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^casta ?(.+)?$",
      "id": "",
      "value": "if (this.healtype) send(\"cura\");\nlet comando = this.mustMemorize ? \"recall\" : this.mustMind ? \"mind\" : \"cast\";\nlet spell = this.spellOffensivo;\nif (!spell) return;\nlet vittima = null;\nif (match[1]) {\n  vittima = match[1];\n}\nelse if (this.TSMob != \"*\") {\n  vittima = this.TSMob.replace(/ /g,\"-\");\n  this.onetimeLook=true;\n} else if (this.Mobs && this.Mobs.length) {\n  vittima = this.Mobs.split(\"|\")[0].replace(/ /g,\"-\");\n  this.onetimeLook=true;\n}\nif (vittima) send(`${comando} '${spell}' ${vittima}`);\n",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "stoporfleeorlook",
      "id": "",
      "value": "if (this.inCombat()) {\n  if (this.TSTank.toLowerCase() == this.TSPersonaggio.toLowerCase()) {\n    send(\"stand;flee\")\n  } else {\n    send(\"stand;stop\")\n  }\n} else {\n  send(\"look\")\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "terra",
      "id": "",
      "value": "cast 'earth se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "aria",
      "id": "",
      "value": "cast 'wind se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "acqua",
      "id": "",
      "value": "cast 'water se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "fuoco",
      "id": "",
      "value": "cast 'fire se'",
      "regex": false,
      "is_script": false,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "calcoloPerHour",
      "id": "",
      "value": "function addMinutes(date, minutes) {\n    return new Date(date.getTime() + minutes*60000);\n}\nlet sumLista = (lista) => {\n  let ret = {\n    \"ph\":0,\n    \"p5m\":0,\n    \"p15m\":0,\n    \"p1h\":0\n  }\n  const _1h = addMinutes(new Date(), -60);\n  const _15m = addMinutes(new Date(), -15);\n  const _5m = addMinutes(new Date(), -5);\n  lista.forEach((value,key) => {\n    value = Number(value)\n    if (key > _1h) {\n      ret.p1h += value\n    }\n    if (key > _15m) {\n      ret.p15m += value\n    }\n    if (key > _5m) {\n      ret.p5m += value\n    }\n  });\n  ret.ph = (0.42*ret.p5m*12 + 0.33*ret.p15m*4 + 0.25*ret.p1h);\n  return ret;\n}\n\nif (this.listaDivini && this.listaDivini.has) {\n  const ret = sumLista(this.listaDivini)\n  this._stat_pqh = Math.ceil(ret.ph);\n  this._stat_pq5m = ret.p5m;\n  this._stat_pq15m = ret.p15m;\n  this._stat_pq1h = ret.p1h;\n}\n\nif (this.listaXP && this.listaXP.has) {\n  const ret = sumLista(this.listaXP)\n  this._stat_xph = Math.ceil(ret.ph);\n  this._stat_xp5m = ret.p5m;\n  this._stat_xp15m = ret.p15m;\n  this._stat_xp1h = ret.p1h;\n}\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "if",
      "id": "",
      "value": "if (!this.scudoFire || this.ultimoScudo==this.scudoFire) return;\n//send(`rem ${this.borsa}`);\nif (this.scudoFire) send(`get ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\nif (this.ultimoScudo) {\n  send(`rem ${this.ultimoScudo}`);\n} else {\n    send(`rem `+(this.usaLuce?\"12\":\"11\"))\n  if (this.scudoCold) send(`rem ${this.scudoCold}`);\n  if (this.scudoAcid) send(`rem ${this.scudoAcid}`);\n  if (this.scudoEle) send(`rem ${this.scudoEle}`);\n}\nsend(`wear ${this.scudoFire}`);\nif (this.ultimoScudo) {\n  send(`put ${this.ultimoScudo} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.scudoCold) send(`put ${this.scudoCold} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoAcid) send(`put ${this.scudoAcid} ${this.borsaArmi||this.borsa}`);\n  if (this.scudoFire) send(`put ${this.scudoFire} ${this.borsaArmi||this.borsa}`);\n  send(`wear all`)\n}\n//send(`wear ${this.borsa}`);\nthis.usiImmuEle = false;\nthis.usiImmuAcid = false;\nthis.usiImmuCold = false;\nthis.usiImmuFire = true;\nthis.Immu = \"FIRE\";\nthis.ultimoScudo = this.scudoFire;",
      "regex": false,
      "is_script": true,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "immufire",
      "id": "",
      "value": "if $1",
      "regex": false,
      "is_script": false,
      "class": "scudi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^wi(e|el|eld)? (.+)$|^imp(u|ug|ugn|ugna)? (.+)$",
      "id": "",
      "value": "const arma = match[2] || match[4];\nsend(\"~wield \" + arma);\nthis.ultimaArma = arma",
      "regex": true,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^auto(stab|slam) ?(.*)?",
      "id": "autostab",
      "value": "const oldVal = this.autostab;\n\nthis.autostab = !this.autostab;\n\nif (match && match[2] != undefined) {\n\tthis.autostab = (match[2] == \"true\" || match[2] == \"on\");\n}\n\ntoggleClass(\"autostab\", this.autostab);\nif (oldVal != this.autostab) {\n    const tipoStab = this.canPlay ? \"Slam\" : \"Stab\";\n\tlet str = \"Auto\" + tipoStab + \": \"+ (this.autostab ? \"ABILITATO\" : \"DISABILITATO\");\n\tthis.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autofury ?(.*)?",
      "id": "autofury",
      "value": "const oldVal = this.autofury;\n\nthis.autofury = !this.autofury;\n\nif (match && match[1] != undefined) {\n\tthis.autofury = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autofury\", this.autofury);\nif (oldVal != this.autofury) {\n  let str = \"AutoFury: \"+ (this.autofury ? \"ABILITATO\" : \"DISABILITATO\");\n  this.diciStatus(str);\n}",
      "regex": true,
      "is_script": true,
      "class": "fight",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ac",
      "id": "",
      "value": "autocast",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "af",
      "id": "",
      "value": "autofury",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "as",
      "id": "",
      "value": "autostab",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "of",
      "id": "",
      "value": "order followers $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^sil[ea] (.+)",
      "id": "",
      "value": "cast 'silence' $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^(storm|sblinka)",
      "id": "",
      "value": "cast 'ince'",
      "regex": true,
      "is_script": false,
      "class": "mage",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^enta (.+)$|^enta$",
      "id": "",
      "value": "let target = match[1] || this.TSMob.split(\" \")[0]\nsend(\"cast 'entangle' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^snare (.+)$|^snare$",
      "id": "",
      "value": "let target = match[1] || this.TSMob.split(\" \")[0]\nsend(\"cast 'snare' \"+target);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "generaGold",
      "id": "",
      "value": "let g = Number(this.TSGold);\nlet b = Number(this.TSBank);\nlet divg = \"\";\nlet divb = \"\";\nif (g > 1000) {\n  divg = \"K\";\n  g /= 1000;\n}\nif (g > 1000) {\n  divg = \"M\";\n  g /= 1000;\n}\nif (b > 1000) {\n  divb = \"K\";\n  b /= 1000;\n}\nif (b > 1000) {\n  divb = \"M\";\n  b /= 1000;\n}\nb = b.toString().substr(0,5);\ng = g.toString().substr(0,5);\nif (g[g.length-1]==\".\") {\n  g = g.substr(0,g.length-1);\n}\nif (b[b.length-1]==\".\") {\n  b = b.substr(0,b.length-1);\n}\nthis.TSGoldK = g+divg;\nthis.TSBankK = b+divb;",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ar",
      "id": "",
      "value": "autorescue",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "touch",
      "id": "",
      "value": "this.ClickControls = !this.ClickControls",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ordinaborsa",
      "id": "",
      "value": "let func = (instash) => {\n  // gemme\n  send(\"gb all.gemma\")\n  send(\"pb all.gemma-scrigno\")\n  send(`${instash?\"unstash\":\"gb\"} sacca-alchimisti`)\n  for(let i = 0; i < 10; i++) {\n    send(\"put gemma sacca-alchimisti\");\n  }\n  send(`${instash?\"stash\":\"pb\"} sacca-alchimisti`)\n\n  // gocce\n  send(\"pb all.goccia\")\n  send(`${instash?\"unstash\":\"gb\"} scrigno-goccia`)\n  send(\"gb all.goccia\")\n  for(let i = 0; i < 6; i++) {\n    send(\"put goccia scrigno-goccia\");\n  }\n  send(`${instash?\"stash\":\"pb\"} scrigno-goccia`)\n  \n  // rami\n  send(\"gb all.ramo\")\n  send(`${instash?\"unstash\":\"gb\"} cesto-foglie`)\n  send(\"put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto;put ramo cesto\")\n  send(`${instash?\"stash\":\"pb\"} cesto-foglie`)\n\n  // cristalli\n  delay(\"ordina\",14000,()=>{\n    send(\"pb all.cristallo\")\n    let cristalli = \"forza|vita|difesa|concentrazione|spirito|salvezza|rigenerazione|precisione|potere|salute|ispirazione\".split(\"|\")\n\n    let ordina = (array) => {\n      if (!array) return;\n      let cris = array[0];\n      if (!cris) {\n        send(\"echo $c4011Ordinamento borsa completato.$c0007\")\n        return;\n      }\n      send(`${instash?\"unstash\":\"gb\"} scrigno-cristallo-`+cris);\n      send(\"gb all.cristallo-\"+cris);\n      for(let i = 0; i < 10; i++) {\n        send(\"put cristallo-\"+cris+\" scrigno-cristallo-\"+cris);\n      }\n      send(`${instash?\"stash\":\"pb\"} scrigno-cristallo-`+cris);\n      array.splice(0,1)\n      delay(\"ordina\",5000,()=>ordina(array));\n    }\n\n    ordina(cristalli);\n  });\n}\nconst res = await Messagebox.ShowWithButtons(\"Ordina gemme, rami e cristalli\", \"Devi avere Scrigni per ogni cristallo, Cesto per rami e Sacca alchimisti.\\nTieni i contenitori in stash? (SI)\\nO in borsa? (NO)\", \"SI\", \"NO\")\nfunc(res.button == 1)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^fixxa ?(.+)?$",
      "id": "",
      "value": "if (match && match[1]) {\n  send(\"tell \"+match[1]+\" (trigger) Ti uso per aggiustarmi l'equipaggiamento :-)\")\n}\nlet watchLag = 0.5 //7\nsend(\"wear all\");\n\nif (false) { // non serve piu\nif (this.healtype) {\n  if (this.oggettoTrueSight) {send(\"rem \"+this.oggettoTrueSight)}\n  send(\"ts\");\n  if (this.oggettoTrueSight) {send(\"wear \"+this.oggettoTrueSight)}\n} else {\n  if (this.oggettoTrueSight) {send(\"rem \"+this.oggettoTrueSight)}\n  watchLag = 17\n  send(\"watch\");\n  if (this.oggettoTrueSight) {send(\"wear \"+this.oggettoTrueSight)}\n}\n}\n\ndelay(\"remeq\", watchLag*1000, ()=>{\n  toggleClass(\"fixxa\",true)\n  this.oggettiRovinati = [];\n  send(\"eq\");\n  delay(\"remeq\", 2000, ()=>{\n    toggleClass(\"fixxa\",false)\n  \tsend(\"oggettiRovinati \"+(match&&match[1]?match[1]:\"\"));\n  });\n});",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^oggettiRovinati ?(.+)?$",
      "id": "",
      "value": "let repairer = (match && match[1] ? match[1] : \"\").trim();\nthis.oggettiRovinati = this.oggettiRovinati.reverse();\n\nfor (let ogg of this.oggettiRovinati) {\n  if (!ogg) continue;\n  //send(\"rem \"+ogg);\n  if (!repairer) {\n    send(\"fix \"+ogg+ \".ed\" + this.TSPersonaggio);\n  }\n}\n\nif (repairer) {\n  send(\"tell \"+repairer+\" (trigger) Inizio a riparare, ti avverto quando ho finito...\");\n  for (let ogg of this.oggettiRovinati) {\n    if (!ogg) continue;\n    send(\"fix \"+ogg+ \".ed\"+this.TSPersonaggio + \" \" + repairer);\n    //send(\"wear ed\"+this.TSPersonaggio);\n  }\n}\nif (repairer) {\n  send(\"tell \"+repairer+\" (trigger) Finito. Grazie!\");\n}\n\n",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^memo? ?(\\d+)? ?( '?([^']+)'?)?$",
      "id": "",
      "value": "const numero = (match[1]||1)\nconst spell = (match[3]||'')\nlet getSpell = (sp) => {\n  if (!this.spellVoluti) return sp;\n  return Object.keys(this.spellVoluti).find(v=>v.startsWith(sp.toLowerCase()))||sp;\n}\nlet segnaMemorize=(sp)=> {\n  const spell = getSpell(sp);\n  if (!spell) return;\n  if (!this.memorizing) this.memorizing = {};\n  if (!this.memorizing[spell]) this.memorizing[spell]=0\n  this.memorizing[spell]++;\n}\nif (spell) {\n  if (this.TSPosizione != \"A terra\") send(\"sit\")\n  for (let i = 0;i<numero;i++) {\n    send(`~memo '${spell}'`)\n    segnaMemorize(spell)\n  }\n} else {\n  toggleClass(\"memorize\",true)\n  this.spellMemmati = {};\n  send(\"~mem\");\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^libro ?(assegna|aggiorna|cancella)?$",
      "id": "",
      "value": "let parametro = match[1]\nif (!parametro) {\n  print(\"USO: libro assegna/aggiorna/cancella\")\n  print(\" - assegna: legge il contenuto del tuo libro e lo usa come template per memmare\")\n  print(\" - aggiorna: simile ma se fai cambiamenti aggiorni il libro voluto\")\n  print(\" - cancella: cancella il libro voluto, e quindi automemorize non funziona piu'\")\n  return\n}\n\nif (parametro == \"aggiorna\" || parametro == \"assegna\") {\n  send(\"memo\")\n  delay(\"libro\",2000,()=>{\n  \tthis.spellVoluti = {};\n    this.spellVoluti = Object.assign(this.spellVoluti, this.spellMemmati);\n    print(\"Letto \" + Object.keys(this.spellVoluti).length + \" spell.\");\n    print(\"Automemorize pronto!\");\n  });\n} else if (parametro == \"cancella\") {\n  this.spellVoluti = null;\n}",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "mining",
      "id": "",
      "value": "if (!this.holdItem) {\n  print(\"Non hai configurato l'oggetto che hai tenuto. Rifai il setup.\");\n  return;\n}\nif (this.ultimaArma) {\n\tsend(`rem ${this.ultimaArma}`)\n} else {\n  send(this.armaPrimaria)\n}\nsend(`rem ${this.holdItem}\ngb piccone\n~hold piccone\n~wield piccone\nmine\nrem piccone\npb piccone\n~wield ${this.ultimaArma}\n~hold ${this.holdItem}`);",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fishing",
      "id": "",
      "value": "if (!this.holdItem) {\n  print(\"Non hai configurato l'oggetto che hai tenuto. Rifai il setup.\");\n  return;\n}\nif (!this.esca) {\n  print(\"Non so che esca usi. Metti l'esca una volta manualmente con 'esca xyz' e sarai a posto.\");\n  return;\n}\nsend(`rem ${this.holdItem}\ngb canna-pesca\ngb ${this.esca}\nhold canna-pesca\nbait ${this.esca}\nbait ${this.esca}\nbait ${this.esca}\nfish\nfish\nrem canna-pesca\npb canna-pesca\nhold ${this.holdItem}`);",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^esca (.+)$",
      "id": "",
      "value": "this.esca = match[1]\nsend(\"~\"+input)",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "memma",
      "id": "",
      "value": "if (this.inCombat() || this.TSLag!=\"-\") {\n  print(\"Impossibile memmare in combat o da laggati\")\n  return;\n}\nif (!this.spellVoluti) {\n  print(\"Devi prima configurare il libro con alias libro\")\n  return;\n}\n\nlet spells = Object.keys(this.spellVoluti)\nlet daMemmare = {}\nlet countDaMemmare = 0;\nconst countMemmati = Object.keys(this.spellMemmati)\n\t\t.map(v => this.spellMemmati[v])\n\t\t\t.reduce((acc, cV) => acc + cV)\nfor\t(let s of spells) {\n  let voluto = this.spellVoluti[s]\n  let diff = voluto - (this.spellMemmati[s] || 0)\n  if (this.debug) print(`Sp ${s} vol ${voluto} dif ${diff}`)\n  if (diff>0) {\n  \tdaMemmare[s] = diff;\n    countDaMemmare += diff;\n  }\n}\nprint(`${countDaMemmare} spell da memmare.`)\nif (countDaMemmare) {\n  this.memorizing = {};\n  send(\"sit\");\n  let cnt = this.memorizeATick\n  let memmato = true;\n  while (memmato && cnt>0) {\n    memmato=false;\n    for (let s of Object.keys(daMemmare)) {\n      if (daMemmare[s]>0) {\n        memmato = true;\n        send(`~memo '${s}'`)\n        if (!this.memorizing[s]) this.memorizing[s]=0;\n        this.memorizing[s]++;\n        daMemmare[s]--;\n        cnt--;\n        if (cnt <= 0) break;\n      }\n    }\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "automemma",
      "id": "",
      "value": "if (!this.automemo || this.inCombat() || this.TSLag!=\"-\") return;\nif (!this.spellVoluti || this.memorizing) return;\n\nlet spells = Object.keys(this.spellVoluti)\nlet daMemmare = {}\nlet countDaMemmare = 0;\nconst countMemmati = Object.keys(this.spellMemmati)\n\t\t.map(v => this.spellMemmati[v])\n\t\t\t.reduce((acc, cV) => acc + cV)\nlet spellAZero = false;\nfor\t(let s of spells) {\n  let voluti = this.spellVoluti[s]\n  let avuti = (this.spellMemmati[s] || 0)\n  if (avuti == 0) spellAZero = true;\n  let diff = voluti - avuti\n  if (this.debug) print(`Sp ${s} vol ${voluti} dif ${diff}`)\n  if (diff>0) {\n  \tdaMemmare[s] = diff;\n    countDaMemmare += diff;\n  }\n}\nlet room = this.TSRoom;\nthis.spellDaMemmare = null;\nif ((countDaMemmare >= this.memorizeATick || spellAZero) &&\n   countDaMemmare + countMemmati < this.memorizeMaxLibro) {\n  let tempoMem = 6500 - (Math.min(this.memorizeATick, countDaMemmare)*250 + 250);\n  this.spellDaMemmare = daMemmare\n  send(\"emote $c4115MEMMA$c0015 tra \" + Math.floor(tempoMem/1000) + \" secondi.\");\n  delay(\"automem\", tempoMem, () => {\n    if (this.TSRoom == room) send(\"memma\")\n  })\n}",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "finememorize",
      "id": "",
      "value": "if (this.TSPosizione!=\"In piedi\" && this.finito_memmare == true) \n{\n  send(\"stand\")\n}\nthis.finito_memmare = false;\nif (!this.memorizing) return;\nif (this.spellMemmati) {\n  for\t(let s of Object.keys(this.memorizing)) {\n    if (!this.spellMemmati[s]) this.spellMemmati[s]=0;\n    this.spellMemmati[s] += this.memorizing[s];\n  }\n}\nthis.memorizing=null;",
      "regex": false,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^automemo? ?(true|on|off|false)?",
      "id": "",
      "value": "this.automemo = !this.automemo;\n\nif (match && match[1] != undefined) {\n\tthis.automemo = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"automemorize\", this.automemo);\nlet str = \"AutoMem: \"+ (this.automemo ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^cast '(.+)' ?(.+)?$",
      "id": "",
      "value": "const spell = match[1].toLocaleLowerCase();\nconst target = match[2]||'';\n\nlet spellDaNonRecallare = {\n  \"portal\":this.casttype==\"M\" && !this.canBash && !this.canStab && !this.healtype,\n  \"sanctuary\":true,\n  \"blink\": this.casttype==\"M\" && !this.canBash && !this.canStab && !this.healtype,\n  \"fly\": !this.healtype,\n  \"mana shield\": this.casttype==\"M\" && !this.canBash && !this.canStab && !this.healtype,\n}\n\nlet comando = \"cast\"\nif (this.mustMemorize && this.spellDaRecallare && \n   this.spellDaRecallare.indexOf(spell)>-1) {\n  comando=\"recall\"\n}\nif (comando==\"recall\" && Object.keys(spellDaNonRecallare).find(k=>k.startsWith(spell))) {\n  comando=spellDaNonRecallare[spell]?\"cast\":\"recall\";\n}\nif (comando!=\"recall\" && this.casttype && this.casttype == \"P\") {\n  comando=\"mind\"\n}\nthis.ultimoSpellCastato=spell\nthis.ultimoTargetSpell=target\nsend(`~${comando} '${spell}' ${target}`);",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^forge?t? '?([^']+)'?$",
      "id": "",
      "value": "if (!this.seduto) send(\"sit\");\nsend(`~forget '${match[1]}'`);\nconst sp = Object.keys(this.spellMemmati||{}).find(v=>v.startsWith(match[1].toLowerCase()))\nif (sp) {\n  this.spellMemmati[sp]--;\n}\nsend(\"stand\")",
      "regex": true,
      "is_script": true,
      "class": "sorcerer",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "^wat(c|ch)?$",
      "id": "",
      "value": "if (this.oggettoTrueSight) send(\"rem \" + this.oggettoTrueSight)\nsend(\"~watch\");\nif (this.oggettoTrueSight) send(\"wear \" + this.oggettoTrueSight)",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "po",
      "id": "",
      "value": "portal $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "nonAfkProc",
      "id": "",
      "value": "if (this.Immortal||!this.TSSpells) return;\nsend(\"sancaAutosanc\")\nif (this.TSSpells.toLowerCase().indexOf(\"f\")==-1 && this.selfshield) {\n    send(\"fs\");\n}\nif (this.TSSpells.toLowerCase().indexOf(\"s\")==-1 && this.healtype==\"C\" && this.selfsanc) {\n  send(\"sanc\");\n} else if (this.TSSpells.toLowerCase().indexOf(\"n\")==-1 && this.healtype==\"D\" && this.selfsanc) {\n  if (this.TSSettore != \"Chiuso\" && this.TSSpells.toLowerCase().indexOf(\"s\")==-1) send(\"sanc\");\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "sancaAutosanc",
      "id": "",
      "value": "if (this.Immortal) return;\nlet daSancare = [];\nlet nonSancati = [];\nlet sancati = 0;\nconst grp=JSON.parse(this.Gruppo||\"{}\")\nfor (let nome in grp) {\n    if (nome == \"tank\" || nome == \"mob\") continue;\n    // non in room o non curabile\n    if (grp[nome].hide || !grp[nome].inroom || grp[nome].pkill) {\n      continue;\n    }\n    if (!grp[nome].sanc && (this.listaAutosanc||[]).indexOf(nome)>-1) {\n      daSancare.push(nome)\n    } else if (!grp[nome].sanc) {\n     nonSancati.push(nome)\n    } else if (grp[nome].sanc) {\n      sancati++;\n    }\n  }\nif (daSancare.length) for (let nome of daSancare) {\n  send(\"sanc \" + nome)\n}\n\nif (this.afk && this.grandezzaGruppo>4 && sancati && nonSancati.length && sancati > 3) {\n  send(\"gt Alcuni in gruppo non sono sancati: \" + nonSancati.join(\",\"))\n}\n",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "vai",
      "id": "",
      "value": "console.log(\"vai \" + $1)\ndeleteWindow(\"Ricerca locazioni\");\nif (!$1 && !this.searchRooms) {\n  const showVai = () => {\n    for (const v of [...mapper.shortNameToRoom].sort((a,b)=>{\n      const nameA = a[0].toUpperCase(); // ignore upper and lowercase\n      const nameB = b[0].toUpperCase(); // ignore upper and lowercase\n      if (nameA < nameB) {\n        return -1;\n      }\n      if (nameA > nameB) {\n        return 1;\n      }\n\n      // names must be equal\n      return 0;\n    })) {\n      let key = v[0]\n    \tprint(link(color(key,\"yellow\", null, true, true), () => { send(\"vai \"+key) }) + \" -> (\" + v[1].id + \") \" + color(v[1].name,\"lightgray\"))\n    }\n  };\n  print(\"Non hai ricerche precedenti. Il comando vai senza parametri scorre tra le room dell'ultima ricerca.\")\n  print(\"Se vuoi vedere tutte le key disponibili al comando VAI premi \"+link(\"QUI\",showVai)+\".\")\n  print(\"Puoi usare anche VAI numero.\")\n  return\n}\n  if ($1 && !isNaN($1)) {\n    //Mikko 2300902 - Aggiunta controllo se la room di destinazione è una DT\n    //--start--\n    const destroom = mapper.idToRoom.get(Number($1));\n    if (destroom===undefined) {\n      print(\"Non esiste una stanza con questo id\");\n      return;\n    }\n    if (destroom?.type==8) {\n      print(\"La stanza \" + $1 + \" e' una DT\");\n      return;\n    }\n    //--stop--\n    mapper.walkToId($1);\n    this.walkingToId = $1\n  }\n  else if (!$1 && this.searchRooms) {\n    if (typeof this.searchRooms !=\"function\" || !this.searchRooms().length) {\n      print(\"Non c'e' nessuna altra room del 'cerca' da visitare.\")\n      this.searchRooms = null;\n      return;\n    }\n    let rNext = this.searchRooms()[0]\n    if (rNext.id == mapper.current?.id) {\n        this.searchRooms().splice(0,1)\n        rNext = this.searchRooms()[0]\n    }\n    if (rNext) {\n      print(\"Continuo alla prossima room dell'ultimo cerca: '\"+rNext.name+\"'.\")\n      this.searchRooms().splice(0,1)\n      send(\"vai \"+rNext.id)\n    }\n  }\n  else if (!!$1) {\n    mapper.walkToRoomShortName($1);\n  }\n//})",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "teleport",
      "id": "",
      "value": "print(\"Aspetto teleport: \"+$1)",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "dig",
      "id": "",
      "value": "this.digCut(\"dig\", $1)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "cut",
      "id": "",
      "value": "this.digCut(\"cut\", $1)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "room",
      "id": "",
      "value": "var room = null;\nif ($1) {\nroom = mapper.getRoomById($1)  \n} else\nroom = mapper.getSelected()\n\nif (room) {\n  if (this.debug) {\n  \tprint(JSON.stringify(room, null, 2))\n  } else {\n  \tprint(\"Ti trovi in #\" + room.id + \": \" + room.name)\n  }\n} else {\nprint(\"Nessuna room selezionata sul mapper.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "cerca",
      "id": "",
      "value": "if ($1) {\n  \tconst res = mapper.searchRooms($1)\n\tthis.searchRooms = () => res\n  \tsend(\"ricercaPrecedente \"+$1)\n} else if (this.searchRooms) {\n  send(\"ricercaPrecedente\")\n} else {\n  print(\"Si, ok, cerca, ma quale stanza? Non hai ancora eseguito nessuna ricerca precedente da mostrare.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "roomedit",
      "id": "",
      "value": "var room = null;\nif ($1) {\nroom = mapper.getRoomById($1)  \n} else\nroom = mapper.getSelected()\n\nif (room) {\n  const r = await Messagebox.ShowInput(\"Edit Room\",\"Modifica la room\", JSON.stringify(room, null, 2), true);\n  print((r.result))\n  if (r.button == 1 && r.result) {\n    const newRoom = JSON.parse(r.result)\n    mapper.setRoomData(room.id, newRoom)\n  }\n}",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "porte",
      "id": "",
      "value": "let room = mapper.getSelected()\nif (room) {\n  const dirs = [\"n\",\"ne\",\"e\",\"se\",\"s\",\"sw\",\"w\",\"nw\",\"u\",\"d\"]\n  let trovatoPorta = false\n  for (let dir of dirs) {\n    const commands = []\n    if (room.exits[dir]) {\n      mapper.handlePossibleDoor({dir: dir, exit: room.exits[dir]}, false, commands)\n      for (let c of commands) {\n          if (c.type!=0) {\n            trovatoPorta = true\n            send(c.command)\n          }\n      }\n    }\n  }\n  if (!trovatoPorta) {\n    print(\"Non trovo porte da aprire qui'.\")\n  }\n} else {\n  print(\"Nessuna room selezionata sul mapper.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "qr",
      "id": "",
      "value": "quest request",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "qc",
      "id": "",
      "value": "quest complete",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "ricercaPrecedente",
      "id": "",
      "value": "pageContent(\"Ricerca locazioni\", (pageIndex, pageSize) => {\n  let total = 0\n  if (this.searchRooms && (total = this.searchRooms().length))\n  {\n    for (let i = pageIndex * pageSize; i < (pageIndex+1) * pageSize && i < total; i++) {\n      const r = this.searchRooms()[i]\n      let rid = r.id;\n      let zname = mapper.getRoomZone(r.id).name\n      zname = zname.replace(/\\ ?\\((by|trad)\\.? [^\\)]+\\)/i,\"\")\n      let rnd = Math.floor(Math.random()*10000)\n      let line = `<span><a id=\"walk${rid+\"-\"+rnd}\" class=\"underline clickable\" title=\"Vai a room ${r.id}\"><span style=\"color:yellow\">${r.id}</span></a> <span style=\"color:white\">${r.name}</span> <span style=\"color:gray\">(${zname})</span></span>`\n      print(line, \"Ricerca locazioni\")\n      setTimeout(() => {\n        const link = $(\"#walk\"+rid+\"-\"+rnd)\n        link.click(()=>{\n            print(\"Vado a room \"+rid + \"( \" + r.name + \" )\")\n            mapper.walkToId(rid)\n        })\n       }, 0)\n  \t}\n  } else {\n  \tprint(color(\" Nessuna :(\",\"red\"), \"Ricerca locazioni\")\n  }\n  delay(\"focuscommand\", 250, () => $(\"#cmdInput\").focus())\n  return total;\n}, \"Room trovate: \"+color(($1||\" \"),\"yellow\"), 0, 20, 750, 405)",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "onroomenter",
      "id": "",
      "value": "const room = mapper.current\n\nif (room && this.prev_room != room) {\n  \n  const prev_zone = (this.prev_room || room).zone_id\n  const current_zone = room.zone_id\n  \n  if (prev_zone != current_zone) {\n    if (prev_zone == 157 && mapper.mapmode) {\n    \tmapper.mapmode = false\n      print(\"Modalita' mappaggio spenta.\")\n    }\n  \ttoggleClass(\"zone:\"+prev_zone, false)\n    toggleClass(\"zone:\"+current_zone, true)\n  }\n  \n  this.prev_room = room\n}\n\nconst id = parseInt($1)\n\nif (!id) return;\n\nif (typeof this.roomEnterEvents != 'function') {\n\tsend(\"generafunzioni\")\n}\n\nconst destinazione = this.destinazione\n\nif (destinazione && destinazione.id == id) {\n  // cancello la variabile in modo che non scatti di nuovo\n  delete this.destinazione\n}\n      \nif (this.roomEnterEvents && this.roomEnterEvents() && this.roomEnterEvents()[id]) {\n  this.roomEnterEvents()[id]();\n  delete this.roomEnterEvents()[id]\n}\n\n//if (room) print(room.id + \"/\" + room.vnum)\nif (room && this.searchRooms && this.walkingToId == room.id) {\n\tvar rooms = this.searchRooms()\n    let removeIndex = rooms.findIndex(r => r.id == room.id)\n    if (removeIndex>-1) {\n      rooms.splice(removeIndex, 1)\n      if (rooms.length) {\n         this.searchRooms = () => rooms;\n      } else {\n      \t this.searchRooms = null;\n      }\n    }\n}\n\n\nif (room && this.returnRoom) {\n  let backId = this.returnRoom;\n  this.returnRoom = null;\n  \n  const exdirs =    ['n','e','s','w','u','d'];\n  //const exdirsRev = ['s','w','n','e','d','u'];\n  \n  for (let i=0; i<exdirs.length;i++) {\n    let dir = exdirs[i]\n  \tif (room.exits[dir] && room.exits[dir].to_room == backId) {\n   \t  send(exdirs[i])\n      if (this.stabTarget) {\n        send(\"backstab \"+ this.stabTarget)\n      \tthis.stabTarget = null;\n      }\n      return;\n    }\n  }\n}\n",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "restab",
      "id": "",
      "value": "if (this.mobKey==\"*\") {\n\tprint(\"Restab solo in combat\")\n  return;\n}\nthis.returnRoom = mapper.roomId\n\nif (this.TSPosizione != \"In piedi\") {\n\tsend(\"stand\")\n}\nthis.stabTarget = this.mobKey\nsend(\"flee\")",
      "regex": false,
      "is_script": true,
      "class": "thief",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "rs",
      "id": "",
      "value": "restab",
      "regex": false,
      "is_script": false,
      "class": "thief",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "autokill",
      "id": "",
      "value": "if (match && match[1] != undefined && match[1]!=\"\") {\n  if (match[1] == \"mobs\") {\n    if (this.setupAutoKillList) {\n      this.setupAutoKillList()\n      return;\n    }\n  } else if ([\"on\",\"off\",\"true\",\"false\"].indexOf(match[1])>-1) {\n\t// se passato parametro esso comanda (e.g. autobash false)\n\tthis.autokill = (match[1] == \"true\" || match[1] == \"on\");\n  }\n } else {\n\tthis.autokill = !this.autokill;\n}\n\ntoggleClass(\"autokill\", this.autokill);\nlet str = (\"AutoKill: \"+ (this.autokill ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "ak",
      "id": "",
      "value": "autokill $1",
      "regex": false,
      "is_script": false,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "autokillcheck",
      "id": "",
      "value": "delay(\"autokill\", 1000, () => {\n  if (!classEnabled(\"autokill\")) return;\n  let t = null;\n  if (!this.inCombat() && this.getAutoKillTarget && (t = this.getAutoKillTarget())) {\n\tprint(\"Autokill\");\n    this.Mobs = \"\";\n    send(\"attack \"+ t);\n  }\n});",
      "regex": false,
      "is_script": true,
      "class": "autokill",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "salta",
      "id": "",
      "value": "if (this.searchRooms) {\n\tvar rooms = this.searchRooms()\n    if (!rooms || !rooms.length) return;\n  \n    let removeIndex = !($1) ? 0 : rooms.findIndex(r => r.id == Number($1))\n    if (removeIndex>-1) {\n      print(\"Salto: \" + rooms[removeIndex].id + \" - \" + rooms[removeIndex].name)\n      rooms.splice(removeIndex, 1)\n      if (rooms.length) {\n         this.searchRooms = () => rooms;\n      } else {\n      \t this.searchRooms = null;\n      }\n    }\n}\n",
      "regex": false,
      "is_script": true,
      "class": "mapper",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "alloff",
      "id": "",
      "value": "const oldFight = classEnabled(\"fight\")\nconst oldSorc = classEnabled(\"sorcerer\")\n\nsend(\"autosanc off\");\nsend(\"automem off\");\n\ntoggleClass(\"fight\", true)\ntoggleClass(\"sorcerer\", true)\n\nsend(\"autoassist off\");\nsend(\"autobash off\");\nsend(\"autorescue off\");\nsend(\"autostab off\");\nsend(\"autofury off\");\nsend(\"autocast off\");\n\ntoggleClass(\"fight\", oldFight)\ntoggleClass(\"sorcerer\", oldSorc)\n\nsend(\"autoloot off\");\n\nsend(\"autostop off\");\nsend(\"autocleric off\");\ntoggleClass(\"indietro\", false)",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "restring",
      "id": "",
      "value": "if (!$1) {\n  print(\"Dai la key dell'oggetto come parametro\");\n  return;\n}\nconst objKey = $1;\n\nconst results = (await Messagebox.ShowMultiInput(\"Restring\",\n                                                 [\"Nuova key\",\"Short desc\", \"Long desc\"],\n                                                 [\"\",\n                                                  \"\",\n                                                  \"\"])).results;\nif (!results) return;\nif (results.every(v => !!v)) {\n  send(`ostring ${objKey} ${results[0]}|${results[1]}|${results[2]}`, true)\n}\n",
      "regex": false,
      "is_script": true,
      "class": "immortal",
      "enabled": true,
      "is_prompt": false,
      "script": null
    },
    {
      "pattern": "tesor(o|i)",
      "id": "",
      "value": "const tesori = [\n  { room: 11151, key: \"Corno Tozzo\", comandi: \"get tesoro\" },\n  { room: 8844, key: \"Aryhann\", comandi: \"get scrign\" },\n  { room: 4242, key: \"Dasen Omir\", comandi: \"get monet forziere\" },\n  { room: 5970, key: \"Vena Argento\", comandi: \"get all\" },\n  { room: 268, key: \"Drago Fire\", comandi: \"get all\" },\n  { room: 10192, key: \"Toewin\", comandi: \"get monete\" },\n  { room: 12261, key: \"Midia Sud\", comandi: \"get all.monet\" },\n  { room: 11416, key: \"Tempio Midia\", comandi: \"get all\" },\n];\n\nif (!this.onRoomEnter) {\n\tsend(\"generafunzioni\");\n}\n\nconst getTesoro = (t) => {\n  this.onRoomEnter(t.room, () => { send(t.comandi) })\n  send(\"vai \"+ t.room)\n}\n\nfor (var t of tesori) {\n\tif (t.key.toLowerCase() == $1.toLowerCase()) {\n\t\tgetTesoro(t)\n      return\n    }\n}\n\nprint(\"Che tesoro vuoi prendere?\\n\")\n\nfor (let t of tesori) {\n  print(\"  \" + color(link(t.key, () => getTesoro(t), \"vai \" + t.room), \"yellow\"))\n}\n\nprint(\"\\nCe ne sono molti altri in giro per l'Impero Celeste.\\nForse dovresti cercarli per diventare piu' ricco di Stellos.\\n\");",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(portal|tran|transport) ?(.*)$",
      "id": "",
      "value": "const spell = match[1] == \"portal\" ? \"portal-v-p\" : \"tran-v-p\";\nconst parametro = (match[2] || null)\nconst comandi = {\n    1: () => send(\"cast \" + spell + \" Vertus\"),\n\t2: () => send(\"cast \" + spell + \" Schill\"),\n\t3: () => send(\"cast \" + spell + \" Reddie\"),\n\t4: () => send(\"cast \" + spell + \" Ghimm\"),\n\t5: () => send(\"cast \" + spell + \" Ciuffofoglio\"),\n\t6: () => send(\"cast \" + spell + \" Mythris\"),\n\t7: () => send(\"cast \" + spell + \" Odliw\"),\n\t8: () => send(\"cast \" + spell + \" Arion\"),\t\n\t9: () => send(\"cast \" + spell + \" Lorina\"),\n\t10: () => send(\"cast \" + spell + \" Andrew\"),\n\t11: () => send(\"cast \" + spell + \" Errimir\"),\n\t12: () => send(\"cast \" + spell + \" Hansi\"),\n\t13: () => send(\"cast \" + spell + \" Limoni\"),\n\t14: () => send(\"cast \" + spell + \" Eloise\"),\n\t15: () => send(\"cast \" + spell + \" Bambo\"),\n\t16: () => send(\"cast \" + spell + \" Radix\"),\n\t17: () => send(\"cast \" + spell + \" Melluyn\"),\n\t18: () => send(\"cast \" + spell + \" Sagi\"),\n\t19: () => send(\"cast \" + spell + \" Udiek\"),\n\t20: () => send(\"cast \" + spell + \" Wit\"),\t\n\t21: () => send(\"cast \" + spell + \" Lis\"),\n\t22: () => send(\"cast \" + spell + \" Brian\"),\n\t23: () => send(\"cast \" + spell + \" Verdorato\"),\n\t24: () => send(\"cast \" + spell + \" Kum\"),\n\t25: () => send(\"cast \" + spell + \" Lawandino\"),\n}\n\nif (parametro) { \n  \n  const comando = parseInt(parametro)\n  if (comando > 0 && comandi[comando]) {\n    // abbiamo il numero come parametro, esegui comando associato\n    comandi[comando]()\n  } else if (comando > 0 && !comandi[comando]) {\n    print(\"Non esiste quel numero di albero!\")\n  } else {\n    send(\"cast \" + spell + \" \" + parametro)\n  }\n  return // non ci serve la lista sotto se diamo parametro\n}\n\nprint(color(\"Portal/Transport via alberi druidici\", \"green\"))\nprint(\"Usa portal numero, oppure portal albero o click sul link.\\n\")\n\nprint(color(\"  1. Foresta di Haon D'Or: \", \"yellow\") + color(link(\"Vertus\", () => comandi[1]()),\"green\") )\nprint(color(\"  2. Foresta di Krall: \", \"yellow\") + color(link(\"Schill\", () => comandi[2]()),\"green\") )\nprint(color(\"  3. Foresta di Rhowyn: \", \"yellow\") + color(link(\"Reddie\", () => comandi[3]()),\"green\") )\nprint(color(\"  4. Foresta di Mirkwood: \", \"yellow\") + color(link(\"Ghimm\", () => comandi[4]()),\"green\") )\nprint(color(\"  5. Foresta di Isengard: \", \"yellow\") + color(link(\"Ciuffofoglio\", () => comandi[5]()),\"green\") )\nprint(color(\"  6. Foresta di Avalon: \", \"yellow\") + color(link(\"Mythris\", () => comandi[6]()),\"green\") )\nprint(color(\"  7. Foresta di Uhmea: \", \"yellow\") + color(link(\"Odliw\", () => comandi[7]()),\"green\") )\nprint(color(\"  8. Foresta di Darkenwood: \", \"yellow\") + color(link(\"Arion\", () => comandi[8]()),\"green\") )\nprint(color(\"  9. Bosco dei Druidi: \", \"yellow\") + color(link(\"Lorina\", () => comandi[9]()),\"green\") )\nprint(color(\" 10. Scacchiera: \", \"yellow\") + color(link(\"Andrew\", () => comandi[10]()),\"green\") )\nprint(color(\" 11. Montagne Orientali: \", \"yellow\") + color(link(\"Errimir\", () => comandi[11]()),\"green\") )\nprint(color(\" 12. Ninja: \", \"yellow\") + color(link(\"Hansi\", () => comandi[12]()),\"green\") )\nprint(color(\" 13. Camelot: \", \"yellow\") + color(link(\"Limoni\", () => comandi[13]()),\"green\") )\nprint(color(\" 14. Roo (mondo capovolto): \", \"yellow\") + color(link(\"Eloise\", () => comandi[14]()),\"green\") )\nprint(color(\" 15. Oasi nel Deserto: \", \"yellow\") + color(link(\"Bambo\", () => comandi[15]()),\"green\") )\nprint(color(\" 16. Castello di Tricksty: \", \"yellow\") + color(link(\"Radix\", () => comandi[16]()),\"green\") )\nprint(color(\" 17. Gallarcity: \", \"yellow\") + color(link(\"Melluyn\", () => comandi[17]()),\"green\") )\nprint(color(\" 18. Mordilnia: \", \"yellow\") + color(link(\"Sagi\", () => comandi[18]()),\"green\") )\nprint(color(\" 19. Skexie: \", \"yellow\") + color(link(\"Udiek\", () => comandi[19]()),\"green\") )\nprint(color(\" 20. Comp: \", \"yellow\") + color(link(\"Wit\", () => comandi[20]()),\"green\") )\nprint(color(\" 21. Albero di Lis: \", \"yellow\") + color(link(\"Lis\", () => comandi[21]()),\"green\") )\nprint(color(\" 22. Valle dei Maghi: \", \"yellow\") + color(link(\"Brian\", () => comandi[22]()),\"green\") )\nprint(color(\" 23. Skyrim: \", \"yellow\") + color(link(\"Verdorato\", () => comandi[23]()),\"green\") )\nprint(color(\" 24. Gilda degli Eroi: \", \"yellow\") + color(link(\"Kum\", () => comandi[24]()),\"green\") )\nprint(color(\" 25. Gilda Dark: \", \"yellow\") + color(link(\"Lawandino\", () => comandi[25]()),\"green\") )\n\nprint(\"\\n\")",
      "regex": true,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "portal ?(.+)",
      "id": "",
      "value": "if (!match[1]) {\n  print(\"Si ma su di chi??\");\n} else {\n\tsend(\"~portal ${match[1]}`);\n}",
      "regex": true,
      "is_script": true,
      "class": "psionic",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autoinspire ?(.*)?",
      "id": "",
      "value": "this.autoinspire = !this.autoinspire;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autoassist false)\n\tthis.autoinspire = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autoinspire\", this.autoinspire);\nlet str = \"AutoInspire: \"+ (this.autoinspire ? \"ABILITATO\" : \"DISABILITATO\");\nthis.diciStatus(str);\nif (this.autoinspire) {\n\tsend(\"inspire\")\n}\n",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(hold?|maneg) (.+)",
      "id": "",
      "value": "this.holdItem = $2\nsend(\"~hold \" + $2)\nif (this.usiLuce && classEnabled(\"monk\")) {\n     this.ultimaArma = null; \n}",
      "regex": true,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "play",
      "id": "",
      "value": "let song;\n\nif (!$1 && this.ultimaSong) {\n  song = this.ultimaSong\n  if (song.indexOf(\"'\") == -1 && song.indexOf(\"-\") == -1) {\n      song = \"'\" + song + \"'\"\n  }\n  send(\"~play \" + song);\n  return;\n}\n\nsong = $1.toLowerCase().replace(\"'\",\"\").replace(\"'\",\"\").replace(\"-\",\" \").replace(\"-\",\" \")\nthis.ultimaSong = song\n\nconst playInstruments = {\n  'song of w': this.strumentoPercussione,\n  'song of l': this.strumentoFiato,\n  'song of p': this.strumentoFiato,\n  'song of n': this.strumentoCorde,\n  'song of d': this.strumentoCorde,\n}\n\nfor (let k in playInstruments) {\n\tif (song && song.startsWith(k)) {\n    \tif (this.holdItem != playInstruments[k]) {\n      \t\tsend(\"rem \" + (this.holdItem || \"strumento\"))\n          \tsend(\"gb \" + playInstruments[k] + \"\\nhold \"+ playInstruments[k] + \"\\npb \" + this.holdItem)          \n\t\t\tbreak;\n        }      \n    }\n}\nsong = $1\nif ($1.indexOf(\"'\") == -1 && $1.indexOf(\"-\") == -1) {\n\tsong = \"'\" + song + \"'\"\n}\nsend(\"~play \" + song);",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^autosong ?(.*)?",
      "id": "",
      "value": "this.autosong = !this.autosong;\n\nif (match && match[1] != undefined) {\n\t// se passato parametro esso comanda (e.g. autobash false)\n\tthis.autosong = (match[1] == \"true\" || match[1] == \"on\");\n}\n\ntoggleClass(\"autosong\", this.autosong);\nlet str = (\"AutoSong: \"+ (this.autosong ? \"ABILITATO\" : \"DISABILITATO\"));\nthis.diciStatus(str);",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "focus",
      "id": "",
      "value": "delay(\"focus\", 2000, () => {\n  send(\"remove ed\" + this.TSPersonaggio)\n  send(\"cast spirit-focus ed\" + this.TSPersonaggio)\n  send(\"wear ed\" + this.TSPersonaggio)\n});",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(giga?|vend?|spir?|eroe?|drag?|fugg?|idio?) (.+)",
      "id": "",
      "value": "send(\"tale \" + $1 + \" \" + $2)",
      "regex": true,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "portal ?(.+)",
      "id": "",
      "value": "if (!match[1]) {\n  print(\"Si ma su di chi??\");\n}\nlet spell = \"portal\"\nsend(`cast '${spell}' ${match[1]}`)",
      "regex": true,
      "is_script": true,
      "class": "cleric",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "sessione",
      "id": "",
      "value": "send(`gt Divini in sessione: ${parseInt(this._stat_pqsess)}`)\nsend(`gt XP in sessione: ${parseInt(this._stat_xpsess)}M`)",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "refresh",
      "id": "",
      "value": "if (this.healtype || this.canPlay) {\n\tsend(\"cast 'seco' \" + $1);\n} else {\n  send(\"gtTrigger \" + $1 + \" ha Mov basso.\")\n}",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "poison",
      "id": "",
      "value": "rem @ultimaArma\nrem @holdItem\ncast 'poison' @ultimaArma\ncast 'poison' @holdItem\nwield @ultimaArma\nhold @holdItem\n",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "war",
      "id": "",
      "value": "play song of war",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "life",
      "id": "",
      "value": "play song of life",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "nat",
      "id": "",
      "value": "play song of nature",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "dumb",
      "id": "",
      "value": "play song of dumb",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "peace",
      "id": "",
      "value": "play song of peace",
      "regex": false,
      "is_script": false,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "slam",
      "id": "",
      "value": "if (this.holdItem != this.strumentoSlam && this.strumentoSlam) {\n\tsend(\n`rem ${this.holdItem}\ngb ${this.strumentoSlam}\npb ${this.holdItem}\nhold ${this.strumentoSlam}`)\n  if (this.autosong) {\n    if (this.strumentoSlam == this.strumentoPercussione) {\n    \tthis.ultimaSong = \"song of w\"\n    } else {\n      this.ultimaSong = \"song of d\"\n    }\n  }\n}\nsend(\"~slam \" + $1)",
      "regex": false,
      "is_script": true,
      "class": "bard",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fog",
      "id": "",
      "value": "send(\"+faerie-fog\")",
      "regex": false,
      "is_script": true,
      "class": "mage",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fog",
      "id": "",
      "value": "send(\"+faerie-fog\")",
      "regex": false,
      "is_script": true,
      "class": "druid",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^(bash|bas|kick) ?(.+)?",
      "id": "",
      "value": "const param = ($2) ? ($2) : \"\"\nsend(\"~kick \" + param)",
      "regex": true,
      "is_script": true,
      "class": "monk",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "ident_init",
      "id": "",
      "value": "toggleClass(\"Ident\", !!this.enableident)\nif (!this.enableident) {return;}\n\nvar util = (window.dbIdentUtil = {})\nconst indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n\n\n//aggiungere abilitazione this.enableident == true\nutil.autoprovenienzaclear = function() {\n\tutil.autoprovenienza = {area:null, mob:null, room:null};\n}\n\n\nvar debug = () => this.debug;\n\n//Carica da indexedDB to memory (util.db) la lista ident pubblica e privata\nutil.init_load = async function() {\n  util.db = {};\n  util.db.lastID = -1;\n  util.db.dbinfo = {};\n  util.db.ogglistPubl = [];\n  util.db.ogglistPriv = [];\n  util.db.fields = [];\n  util.db.fieldsPos = {};\n  util.debug = debug;\n  util.autoprovenienzaclear();\n  \n  return new Promise(function(resolve, reject) {\n\n    function buildFieldsPos() {\n      for ( let fieldidx in util.db.fields) {\n        util.db.fieldsPos[util.db.fields[fieldidx].nome] = fieldidx;\n      } \n    }\n\n\n    const dbconn = indexedDB.open(\"IdentDb\", 1);\n    dbconn.onerror = (event) => {\n      const err = \"Errore nella connessione al DB degli ident\"\n      reject(err)\n      print(err);\n    };\n\n    dbconn.onupgradeneeded = (event) => {\n      const dbresult = event.target.result;\n\n      // Create an objectStore for this database\n      const objectStore = dbresult.createObjectStore(\"JSONstore\", { keyPath: \"ID\" });\n      objectStore.createIndex(\"JSONstring\", \"JSONstring\", { unique: true });\n    }; \n\n    dbconn.onsuccess = (event) => {\n      const dbresult = event.target.result;\n      const transaction = dbresult.transaction(\"JSONstore\", \"readonly\");\n      const store = transaction.objectStore(\"JSONstore\");\n      //nel record 1 di JSONStore c'è il db pubblico\n      //nel record 2 di JSONStore c'è il db privato\n      const jsonqueryPubl = store.get(1);\n      const jsonqueryPriv = store.get(2);\n\n      jsonqueryPubl.onsuccess = function(event) {\n      if (util.debug()) {print(\"Ident DB Pubblico caricato\");}\n        const r = event.target.result;\n        if (r != undefined) {\n          const objsaved = JSON.parse(r.JSONstring);\n          util.db.fields = objsaved.fields;\n          buildFieldsPos();\n          util.db.ogglistPubl = objsaved.data;\n          util.db.dbinfo = objsaved.dbinfo;\n        }\n      };\n\n      jsonqueryPubl.onerror = (event) => {\n        if (util.debug()) {\n          print(\"jsonqueryPubl error. Vedi console\");\n          console.log(event.target.errorCode);\n        }\n        reject(\"jsonqueryPubl error. Vedi console\")\n      };\n\n      jsonqueryPriv.onsuccess = function(event) {\n      \tif (util.debug()) {print(\"Ident DB Privato caricato\");}\n        const r = event.target.result;\n        if (r != undefined) {\n          const objsaved = JSON.parse(r.JSONstring);\n          if (!util.db.fields || !util.db.fields.length) {\n            util.db.fields = objsaved.fields;\n            buildFieldsPos();\n          }\n          util.db.ogglistPriv = objsaved.data || [];\n          if (!util.db.dbinfo) {\n            util.db.dbinfo = objsaved.dbinfo;\n          }\n        }\n      };\n\n      jsonqueryPriv.onerror = (event) => {\n        if (util.debug()) {\n          print(\"jsonqueryPriv error. Vedi console\");\n          console.log(event.target.errorCode);\n        }\n        reject(\"jsonqueryPriv error. Vedi console\")\n      };    \n\n      transaction.oncomplete = function() {    \n        if (util.debug()) {\n          print(\"Transaction complete\");\n          print(\"LOG Ident Publico DB Size:\" + util.getSize()[0]);\n          print(\"LOG Ident Privato DB Size:\" + util.getSize()[1]);\n        }\n        print(\"Database degli ident caricato. Versione: \" + util.db.dbinfo.ver + \" (\" + util.db.dbinfo.data + \") - \" + util.db.dbinfo.msg);\n        print(\"Elementi caricati nel db pubblico: \" + util.getSize()[0]);\n        print(\"Elementi caricati nel db privato:  \" + util.getSize()[1]);\n\n\n        if (!util.db.fields || !util.db.fields.length) {\n          util.db.fields = [{\"nome\":\"Oggetto\",\"type\":\"TEXT\"},{\"nome\":\"Tipo\",\"type\":\"TEXT\"},{\"nome\":\"DescrizioneShort\",\"type\":\"TEXT\"},{\"nome\":\"PosizioneIndossabile\",\"type\":\"TEXT\"},{\"nome\":\"Proprieta\",\"type\":\"TEXT\"},{\"nome\":\"Peso\",\"type\":\"NUMBER\"},{\"nome\":\"Valore\",\"type\":\"NUMBER\"},{\"nome\":\"Rent\",\"type\":\"NUMBER\"},{\"nome\":\"DescrizioneLong\",\"type\":\"TEXT\"},{\"nome\":\"Identify\",\"type\":\"TEXT\"},{\"nome\":\"Provenienza\",\"type\":\"TEXT\"},{\"nome\":\"Rare\",\"type\":\"BOOL\"},{\"nome\":\"NoRent\",\"type\":\"BOOL\"},{\"nome\":\"DannoArma\",\"type\":\"NUMBER\"},{\"nome\":\"Danno\",\"type\":\"NUMBER\"},{\"nome\":\"SP\",\"type\":\"NUMBER\"},{\"nome\":\"HP\",\"type\":\"NUMBER\"},{\"nome\":\"Mana\",\"type\":\"NUMBER\"},{\"nome\":\"Affect1Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect1Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect2Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect2Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect3Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect3Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect4Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect4Valore\",\"type\":\"TEXT\"},{\"nome\":\"Affect5Tipo\",\"type\":\"TEXT\"},{\"nome\":\"Affect5Valore\",\"type\":\"TEXT\"},{\"nome\":\"ID\",\"type\":\"TEXT/NUMBER\"},{\"nome\":\"Nota\",\"type\":\"TEXT\"}];\n          buildFieldsPos();\n          if (util.debug()) {\n            print(\"Caricamento preset Fields\");\n          }\n        }\n\n\n\n        dbresult.close();\n        resolve()\n      };  \n    };\n  });\n}\n\n\n//Salve da memoria a indexedDB i 2 database.\nutil.save = async function(savePublic=false) {\n  return new Promise(function(resolve, reject) {\n    const dbconn = indexedDB.open(\"IdentDb\", 1);\n    dbconn.onerror = (event) => {\n      print(\"Errore nella connessione al DB degli ident\");\n      reject(\"Errore nella connessione al DB degli ident\")\n    };\n\n    dbconn.onsuccess = (event) => {\n      const dbresult = event.target.result;\n      const transaction = dbresult.transaction(\"JSONstore\", \"readwrite\");\n      const store = transaction.objectStore(\"JSONstore\");\n      if (savePublic) {\n        const saveobj = {dbinfo: util.db.dbinfo, fields:util.db.fields, data:util.db.ogglistPubl}\n        const addqueryPubl = store.put({ID:1, JSONstring: JSON.stringify(saveobj)});\n\n        addqueryPubl.onsuccess = function(event) {\n          if (util.debug()) {print(\"Ident DB Pubblico salvato\");}\n        };\n\n        addqueryPubl.onerror = (event) => {\n          if (util.debug()) {\n            print(\"addqueryPubl error. Vedi console\");\n            console.log(event.target.errorCode);\n          }\n          reject(\"addqueryPubl error. Vedi console\")\n        };   \n      } else {\n        const saveobjPriv = {dbinfo: {}, fields:util.db.fields, data:util.db.ogglistPriv}\n        const addqueryPriv = store.put({ID:2, JSONstring: JSON.stringify(saveobjPriv)});\n\n        addqueryPriv.onsuccess = function(event) {\n          if (util.debug()) {print(\"Ident DB Privato salvato\");}\n        };\n\n        addqueryPriv.onerror = (event) => {\n          if (util.debug()) {\n            print(\"addqueryPriv error. Vedi console\");\n            console.log(event.target.errorCode);\n          }\n          reject(\"addqueryPriv error. Vedi console\")\n        };\n      }    \n\n      transaction.oncomplete = function() {\n        if (util.debug()) {\n          print(\"Transaction complete\");\n          print(\"LOG Ident Publico DB Size:\" + util.getSize()[0]);\n          print(\"LOG Ident Privato DB Size:\" + util.getSize()[1]);\n        }\n        dbresult.close();\n        resolve()\n      };  \n    };\n  });\n}\n\n\n//Cerca l'oggetto basando su key, descshort e desclong\n//restituisce l'oggetto se trovato oppure null\n//Si usa l'assunto che gli oggetti del db sono univoci per Oggetto+Short+Long\n//Qualora ce ne fossero più d'uno viene restituito il primo\nutil.find = function(ogg) {\n  for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n    if (\n        (objdb[util.db.fieldsPos.Oggetto] === ogg.Oggetto) &&\n        (objdb[util.db.fieldsPos.DescrizioneShort] === ogg.DescrizioneShort) &&\n        (objdb[util.db.fieldsPos.DescrizioneLong] === ogg.DescrizioneLong)\n    )\n    {return objdb;}\n  }\n  return null;\n}\n\n\n//restituisce l'elenco degli oggetti con la descshort specificata\nutil.withshort = function(descshort) {\n    let found = [];\n    for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n        if ((objdb[util.db.fieldsPos.DescrizioneShort] == descshort) && !this.isalreadyin(found, objdb))  {\n            found.push(objdb)\n        }\n    }\n    return found;\n}\n\n//restituisce l'elenco degli oggetti con la desclong specificata\nutil.withlong = function(desclong) {\n    let found = [];\n    for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n        if ((objdb[util.db.fieldsPos.DescrizioneLong].split(\"\\n\")[0] == desclong) && !this.isalreadyin(found, objdb))  {\n            found.push(objdb)\n        }\n    }\n    return found;\n}\n\n\n//Cerca l'oggetto basando su ID\n//restituisce l'oggetto se trovato oppure null\n//Si usa l'assunto che gli oggetti del db sono univoci per ID\n//Qualora ce ne fossero più d'uno viene restituito il primo\nutil.findID = function(id) {\t\n    if (this.debug()) {\n\t\tprint(\"Ricerca dell'oggetto con ID: -->\" + id + \"<--\");\n\t}\n\tfor (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n      if (String(objdb[util.db.fieldsPos.ID]) === String(id)) {return objdb;}\n  \t}\n  \treturn null;\n}\n\n\n//La funzione delID permette di rimuovere un elemento dal db\n//è inernamente limitata a cancellare solo da db Privato.\nutil.delID = function(id) {\n  this.db.ogglistPriv = this.db.ogglistPriv.filter( _obj => (String(_obj[util.db.fieldsPos.ID]) != String(id)) ); \n  this.save();\n}\n\n\n//restituisce l'elenco degli oggetti che contengono\n//tutti gli elementi specificati nel testo e divisi da |, nell'ident\nutil.search = function(text) {\n    let criteriricerca = text.split(\"|\");\n    let found = [];\n    for (let objdb of this.db.ogglistPriv.concat(this.db.ogglistPubl)) {\n      let criteriotrovato = true; \n      for (let criterio of criteriricerca) {\n      \t  if (\n            (objdb[util.db.fieldsPos.Identify] + \"\\n\" + objdb[util.db.fieldsPos.Provenienza]).toLowerCase().search(criterio.toLowerCase())<0\n          ) {\n          criteriotrovato = false;\n          break;\n          }\n        } \n      if ( criteriotrovato && !this.isalreadyin(found, objdb) ) {\n      \t//trovato un oggetto che soddisfa i requisiti\n        //e non già tra quelli trovati       \n        found.push(objdb);\n      }    \n    }\n    return found;\n}\n\n//Data una lista, verifica se l'oggetto è già presente nella lista\n//Da usare nelle varie funzioni find e search per non mettere duplicati\nutil.isalreadyin = function(list, ogg) {\n  let isgiatrovato = false;\n  for (let oggettolista of list) {\n    if (\n      (oggettolista[util.db.fieldsPos.Oggetto] === ogg[util.db.fieldsPos.Oggetto]) && \n      (oggettolista[util.db.fieldsPos.DescrizioneShort] === ogg[util.db.fieldsPos.DescrizioneShort]) &&\n      (oggettolista[util.db.fieldsPos.DescrizioneLong] === ogg[util.db.fieldsPos.DescrizioneLong])  \n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//Aggiunge l'oggetto passato al DB Privato e salva.\n//Assegna automaticamente il nuovo ID\nutil.add = function(ogg, oggisarray=false) {\n  function formattedDate(d = new Date) {\n    return [d.getDate(), d.getMonth()+1, d.getFullYear()].map(n => n < 10 ? `0${n}` : `${n}`).join('/');\n  }\n  \n  if (util.debug()) {print(\"LOG (util.add): Aggiunta dell'oggetto al DB Privato\");}    \n  util.db.lastID = \"Priv\" + String(this.getMaxID() + 1);\n  if (oggisarray) {    \n    ogg[util.db.fieldsPos.ID] = util.db.lastID;\n  \tif (util.debug()) {print(JSON.stringify(ogg));}\n  \tthis.db.ogglistPriv.push(ogg);    \n  } else {\n    ogg.ID = util.db.lastID;\n    let objarr = [ogg.Oggetto,\n                  null, //ogg.Tipo,\n                  ogg.DescrizioneShort,\n                  null, //ogg.PosizioneIndossabile,\n                  null, //ogg.Proprieta,\n                  null, //ogg.Peso,\n                  null, //ogg.Valore,\n                  null, //ogg.Rent,\n                  ogg.DescrizioneLong,\n                  ogg.Identify,\n                  ogg.Provenienza,\n                  null, //ogg.Rare,\n                  null, //ogg.NoRent,\n                  null, //ogg.DannoArma,\n                  null, //ogg.Danno,\n                  null, //ogg.SP,\n                  null, //ogg.HP,\n                  null, //ogg.Mana,\n                  null, //ogg.Affect1Tipo,\n                  null, //ogg.Affect1Valore,\n                  null, //ogg.Affect2Tipo,\n                  null, //ogg.Affect2Valore,\n                  null, //ogg.Affect3Tipo,\n                  null, //ogg.Affect3Valore,\n                  null, //ogg.Affect4Tipo,\n                  null, //ogg.Affect4Valore,\n                  null, //ogg.Affect5Tipo,\n                  null, //ogg.Affect5Valore,\n                  ogg.ID,\n                  formattedDate() //ogg.Nota\n                 ];\n  \tif (util.debug()) {print(JSON.stringify(objarr));}\n  \tthis.db.ogglistPriv.push(objarr);\n  }\n  this.save();\n  print(\"Oggetto aggiunto all'archivio privato con ID: \" + util.db.lastID)\n}\n\nutil.getStringIdents = function(arr) {\n  let out=\"\";\n  for (let ogg of arr) {\n      out += \"ID: \" + color(ogg[util.db.fieldsPos.ID],\"yellow\") + \"\\n\";\n      out += ogg[util.db.fieldsPos.Identify] + \"\\n\";\n      out += \"Provenienza: \" + ogg[util.db.fieldsPos.Provenienza] + \"\\n\\n\";\n  }\n  return(out);\n}\n\nutil.getSize = function() {\n  return [this.db.ogglistPubl?.length, this.db.ogglistPriv?.length];\n}\n\n//restituisce l'ID maggiore nell'db Privato\n//Nel DB privato gli ID vengono salvati nella forma PrivXXXX\nutil.getMaxID = function() {\n  let id = 0;\n  for (let objdb of this.db.ogglistPriv) {\n    let objdbid = Number(objdb[util.db.fieldsPos.ID].substring(4));\n    if (objdbid>id) {id=objdbid;}\n  }\n  return id;\n}\n\nutil.parseident = function(identText) {\n  let obj={};\n\n  try {\n    obj.Oggetto = identText.match(/^Oggetto '(.+?)' - Tipo: (.+)$/m)[1];\n    obj.Tipo = identText.match(/^Oggetto '(.+?)' - Tipo: (.+)$/m)[2];\n  }\n  catch(err) {\n    obj.Oggetto = \"\";\n    obj.Tipo = \"\";\n  }\n  \n  try {\n    obj.DescrizioneShort = identText.match(/^Descrizione (?:corta|short): '(.+?)'$/ms)[1].replace(\"\\n\",\" \");\n  }\n  catch(err) {\n    obj.DescrizioneShort = \"\";\n  }\n\n  try {\n    obj.DescrizioneLong = identText.match(/^Descrizione (?:lunga|long): '(.*?)'$/ms)[1].replace(\"\\n\",\" \");\n  }\n  catch(err) {\n    obj.DescrizioneLong = \"\";\n  }\n  \n  obj.Identify = identText;\n  obj.Provenienza = \"\"; \n  return obj;\n}\n\nutil.getCurrentZonaLabel = function() {\n  if (util.mapZones === undefined) {\n    util.mapZones = new Map(\n  \t\tmapper.db.zones.map(object => {\n    \t\treturn [object.id, object.label];\n  \t\t}),\n\t);\n  }\n  return util.mapZones.get(mapper.current.zone_id);\n}\n\n\nutil.getautoprovenienza = function() {\n  let prov = this.getCurrentZonaLabel();\n  if (util.autoprovenienza.ultimoMobUcciso != null) {\n    prov += \" - \" + util.autoprovenienza.ultimoMobUcciso;\n  }\n  if (util.autoprovenienza.room != null) {\n    prov += \" (\" + util.autoprovenienza.room + \")\";\n  }\n  return prov;\n}\n\n\nutil.buildautoprovenienza = function() {\n    print(link(\"Click per aggiungere la provenienza:\",()=>{\n      send(\"setprovenienza \\\"\" + util.getautoprovenienza() + \"\\\"\");\n    }\n    ) + \" \" + util.getautoprovenienza());\n  \n    print(link(\"Aggiungi ultimo mob ucciso:\", ()=>{\n        util.autoprovenienza.ultimoMobUcciso = (window.ultimoMobUcciso || null);\n        this.buildautoprovenienza();  \n    }                                                   \n    ) + \" \" + (window.ultimoMobUcciso || \"\") ); \n  \n    print(link(\"Aggiungi stanza:\", ()=>{\n        util.autoprovenienza.room = mapper.current.id;\n        this.buildautoprovenienza();\n    }                                                   \n    ) + \" \" + mapper.current.id);  \n    print(\"\\n\");\n}\n\nawait util.init_load();\n\n",
      "regex": false,
      "is_script": true,
      "class": "IdentInit",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^identimport( privato$| pubblico$| online$| purge$|$)",
      "id": "",
      "value": "let util = window.dbIdentUtil;\nif (!util) {\n  send(\"ident_init\")\n}\nutil = window.dbIdentUtil;\n\nconst database = match[1].trim() || \"privato\";\n\n\nasync function importPublicoObj(objparsed) {\n  util.db.ogglistPubl = objparsed.data;\n  util.db.dbinfo = objparsed.dbinfo;  \n  util.db.fields = objparsed.fields;\n  await util.save(true);\n}\n\nasync function importPublico(text) {\n  let objparsed = JSON.parse(text);\n  await importPublicoObj(objparsed)\n}\n\nasync function importPrivato(text) {\n  let objparsed = JSON.parse(text);\n  util.db.ogglistPriv = objparsed.data;\n  await util.save(false);\n}\n\n\nfunction importFromFile(callback) {\n    if (!callback) return;\n    let inp = document.createElement(\"input\");\n    inp.type = \"file\";\n    inp.style.visibility = \"hidden\";\n\n    inp.addEventListener(\"change\", (e) => {\n        let file = e.target.files[0];\n        if (!file) {\n            return;\n        }\n\n        let reader = new FileReader();\n        reader.onload = (e1) => {\n            let text = e1.target.result;\n            callback(text)\n        };\n        reader.readAsText(file);\n\n    });\n\n    document.body.appendChild(inp);\n    inp.click();\n    document.body.removeChild(inp);\n}\n\nasync function loadOnlineDB(prefix) {\n  //print(prefix + \"/identDbPublicVersion.json?rng=\"+Math.random())\n  const res1 = await fetch(prefix + \"/identDbPublicVersion.json?rng=\"+Math.random())\n  const verData = await res1.json();\n\n  if (verData.dbinfo.ver > (util.db.dbinfo?.ver || 0)) {\n    // versione nuova online, aggiorniamo il pubblico\n    \n  \tconst res2 = await fetch(prefix + \"/identDbPublic.json?rng=\"+Math.random())\n  \tconst dbObj = await res2.json();\n    importPublicoObj(dbObj)\n\t  print(\"Eseguo aggiornamento del DB Identify pubblico a v\" + verData.dbinfo.ver)\n  \n  } else {\n    //print(\"La versione del DB Identify pubblico e' aggiornata all'ultima versione disponibile sul server.\")\n  }\n}\n\nif (database == \"pubblico\") {\n  importFromFile(importPublico);\n} else if (database == \"privato\") {\n  importFromFile(importPrivato);\n} else if (database == \"purge\") {\n  util.db.ogglistPubl = [];\n  util.db.ogglistPriv = [];\n  util.db.dbinfo = {};  \n  util.db.fields = [];\n  util.save(true);\n  util.save(false);\n} else if (database == \"online\") {\n  //print(window.location)\n\n  let prefix = \"\"\n  if (window.ipcRenderer) {\n    // nel binario primo fetch locale, quello sotto non sovrascrive\n    // se contiene il piu recente in quanto fa il version check\n    prefix = \"electron://./dist/public\"\n    await loadOnlineDB(prefix);\n  }\n  \n  if (window.ipcRenderer) {\n    // binario prova a aggiornare dal live casomai abbia vecchio\n    prefix = \"https://www.temporasanguinis.it/client\"\n  } else if (window.location.hostname.indexOf(\"temporasanguinis\")!=-1) {\n     // online sul web nella cartella client\n    prefix = \"/client\"\n  } else {\n    // altri siti hostati in locale nel root\n    prefix = \"\"\n  }\n\n  loadOnlineDB(prefix);\n  \n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^l(o|$)(o|$)k{0,1} ?(.*)$",
      "id": "look",
      "value": "if (classEnabled(\"Ident\") && !($3)) toggleTrigger(\"usciteVisibili\", true);\nthis.Mobs = \"\"\nsend(\"~look\" + (($3) ? (\" \" + ($3)) : \"\"))",
      "regex": true,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^identdel (Priv\\d+|All)$",
      "id": "",
      "value": "var util = window.dbIdentUtil;\nif (match[1] == \"All\") {\n  util.db.ogglistPriv = [];\n  util.save();\n  print(\"il database privato è stato svuotato\");\n} else {\n\tutil.delID(match[1]);\n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^setprovenienza (?:(Priv\\d+|\\d+) |)\\\"(.*)\\\"$|^setprovenienza$",
      "id": "",
      "value": "/*\nEsempi:\nsetprovenienza 1234 \"nuova provenienza\"\nsetprovenienza Priv456 \"nuova provenienza\"\nsetprovenienza \"nuova provenienza\"\nsetprovenienza Priv333 \"\"\nsetprovenienza \"\"\n\n\nConfigurazioni non ok:\nsetprovenienza test232 \"\"\nsetprovenienza 123a \"\"\nsetprovenienza Priv333\n*/\n\n//Volendo le \" \" si potrebbero togliere ma aggiungerebbe dubbi interpretativi il alcuni comandi\nvar util = window.dbIdentUtil;\n\n\nif (match[0] == \"setprovenienza\") {\n  util.buildautoprovenienza();\n  return;\n} \n\n\nlet objID = match[1] || util.db.lastID;\nlet provenienza = match[2] || \"\";\n\nlet oggdb = util.findID(objID);\nif (oggdb == null) {\n  print(\"L'oggetto con ID \" + objID + \" non esiste\");\n} else {\n  //2 possibili casi: \n  //1) Se l'oggetto è già nel db privato posso cambiare direttamente la provenienza\n  //2) Se l'oggetto è nel db pubblico devo fare una copia dell'oggetto \n  //con la nuova provenienza da mettere nel privato\n  if (String(oggdb[util.db.fieldsPos.ID]).slice(0,4)==\"Priv\") {\n    let provenienza_old = oggdb[util.db.fieldsPos.Provenienza];\n    oggdb[util.db.fieldsPos.Provenienza] = provenienza;\n    print(\"La provenienza dell'oggetto \\\"\" + oggdb[util.db.fieldsPos.Oggetto] + \"\\\" è stata cambiata\");\n    print(\"DA: \" + provenienza_old);\n    print(\"A: \" + provenienza);\n  } else {\n    let provenienza_old = oggdb[util.db.fieldsPos.Provenienza];\n\tlet oggcopiato = JSON.parse(JSON.stringify(oggdb));\n    oggcopiato[util.db.fieldsPos.Provenienza] = provenienza;\n    print(\"La provenienza dell'oggetto \\\"\" + oggdb[util.db.fieldsPos.Oggetto] + \"\\\" è stata cambiata creando una copia nell'elenco privato\");\n    print(\"DA: \" + provenienza_old);\n    print(\"A: \" + provenienza);    \n    util.add(oggcopiato, true);\n  }  \n  util.save();\n}",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^identexport( privato$| pubblico$|$)",
      "id": "",
      "value": "var util = window.dbIdentUtil;\nconst database = match[1].trim() || \"privato\";\n\nfunction downloadJsonToFile(json, filename) {\n    let jsonstr = JSON.stringify(json, null, 2);\n    downloadString(jsonstr, filename);\n}\n\nfunction downloadString(jsonstr, filename) {\n    let blob = new Blob([jsonstr], { type: \"octet/stream\" });\n    let url = window.URL.createObjectURL(blob);\n\n    let link = document.createElement(\"a\");\n    link.setAttribute(\"href\", url);\n    link.setAttribute(\"download\", filename);\n    link.style.visibility = \"hidden\";\n\n    document.body.appendChild(link);\n    link.click();\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(link);\n}\n\nfunction formattedDate(d = new Date) {\n    return [d.getDate(), d.getMonth()+1, d.getFullYear()].map(n => n < 10 ? `0${n}` : `${n}`).join('/');\n  }\n\nif (database == \"pubblico\") {\n  const saveobj = {dbinfo: util.db.dbinfo, fields:util.db.fields, data: util.db.ogglistPubl}\n  downloadJsonToFile(saveobj,\"identdbPubblico.json\");\n} else if (database == \"privato\") {\n  const privdbinfo = {\n    ver: util.db.dbinfo.ver,\n    data: formattedDate(),\n    msg: \"Exported from WebClient\" \n  }\n  const saveobj = {dbinfo: privdbinfo, fields:util.db.fields, data: util.db.ogglistPriv}\n  downloadJsonToFile(saveobj,\"identdbPrivato.json\");\n}\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^cani$",
      "id": "",
      "value": "const sogliaminima = 200;\n\nlet numclassi = 1;\nlet psimono = false;\nif (this.classi && this.classi.length) {\n  numclassi = this.classi.length || 1;\n  psimono = this.classi.includes(\"Ps\");\n}\n//print(numclassi);\n//print(\"\"+psimono);\nlet coeff=1;\nif ((numclassi == 1) && psimono) {\n  coeff = 0.5;\n} else if (numclassi ==1) {\n  coeff = 1\n} else {\n  coeff = 1.25\n}\n//print(coeff)\n\nlet deltaMana = Number(this.TSMaxMana) - Number(this.TSMana);\n//print(\"deltaMana:\" + deltaMana)\nlet caniAmount = Math.trunc(deltaMana*coeff);\n//print(\"caniAmount:\" + caniAmount)\nsend(\"canibalize \" + String(Math.min(caniAmount, this.TSHp-sogliaminima)));",
      "regex": true,
      "is_script": true,
      "class": "cani",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "cambiaarma",
      "id": "",
      "value": "if (this.rotazioneArmi) rotazioneArmi()",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "arco",
      "id": "",
      "value": "if (!this.arco || this.ultimaArma == this.arco) {\n  if (this.freccia) {\n  \tsend(`load ${this.freccia}`)\n  }\n  return;\n}\n//send(`rem ${this.borsa}`);\nsend(`get ${this.arco} ${this.borsaArmi||this.borsa}`);\nsend(`get faretra ${this.borsaArmi||this.borsa}`);\nif (this.ultimaArma) {\n  send(`rem ${this.ultimaArma}`);\n} else {\n  if (this.armaPierce) send(`rem ${this.armaPierce}`);\n  if (this.armaSlash) send(`rem ${this.armaSlash}`);\n  if (this.armaExtra) send(`rem ${this.armaExtra}`);\n  if (this.armaBlunt) send(`rem ${this.armaBlunt}`);\n}\nsend(`~wield ${this.arco}`);\nif (this.freccia) {\n  send(`get ${this.freccia} ${this.borsaArmi||this.borsa}`)\n  send(`load ${this.freccia}`)\n}\nif (this.ultimaArma) {\n  send(`put ${this.ultimaArma} ${this.borsaArmi||this.borsa}`);\n} else {\n  if (this.armaExtra) send(`put ${this.armaExtra} ${this.borsaArmi||this.borsa}`);\n  if (this.armaBlunt) send(`put ${this.armaBlunt} ${this.borsaArmi||this.borsa}`);\n  if (this.armaPierce) send(`put ${this.armaPierce} ${this.borsaArmi||this.borsa}`);\n  if (this.armaSlash) send(`put ${this.armaSlash} ${this.borsaArmi||this.borsa}`);\n}\n//send(`wear ${this.borsa}`);\nthis.usiSlash = false;\nthis.usiBlunt = false;\nthis.usiPierce = false;\nthis.usiExtra = false;\nthis.usiArco = true;\nthis.ultimaArma = this.arco;",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "fire",
      "id": "",
      "value": "if (this.scoccato || this.scoccato === undefined) {\n\tsend(`~load faretra`)\n  this.scoccato = false\n}\nsend(`~fire ${$1}`)",
      "regex": false,
      "is_script": true,
      "class": "armi",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^ident$|^ident(Dev|) (.*)$",
      "id": "",
      "value": "var util = window.dbIdentUtil;\nconst isDev = (match[1] === \"Dev\")\nconst searchKey = (match[2] || \"\")\n\nif (searchKey==\"\") {\n  print(color(\"HELP COMANDI WEBCLIENT PER IDENT\",\"white\"));\n  print(color(\"\\n\" \n             +\"Sono disponibili 2 archivi di oggetti:\\n\"\n             +\"* uno pubblico non modificabile che viene scaricato dal server\\n\"\n             +\"* uno privato che può essere popolato dai giocatori\\n\"\n             +\"\\n\"\n             +\"Comandi per la gestione degli identify:\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"RICERCA: ident key1|key2|...|keyn\\n\",\"yellow\"));\n  print(color(\"Restituisce l'identify o l'elenco degli oggetti che hanno \"\n             +\"nel testo dell'identify tutte le parole indicate nelle chiavi.\\n\"\n             +\"Esempio: ident spada del sole|slayer\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"AGGIUNTA DI UN IDENTIFY:\",\"yellow\"));\n  print(color(\"Dopo l'identify di un oggetto compariranno alcune scritte per informare se \"\n             +\"l'oggetto è già nell'archivio oppure no.\\n\"\n             +\"In questo secondo caso cliccando su \\\"Click per aggiungerlo\\\" l'identify verrà aggiunto \"\n             +\"all'archivio privato e gli sarà assegnato un identificativo del tipo Priv#\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"AGGIUNTA/MODIFICA DELLA PROVENIENZA: setprovenienza ID \\\"testo libero\\\"\",\"yellow\"));\n  print(color(\"Ad ogni oggetto si possono aggiungere informazioni utili (normalmente la provenienza)\\n\"\n             +\"- ID e' l'identificativo dell'oggetto nell'archivio pubblico o privato\\n\"\n             +\"- testo libero, racchiuso tra virgolette e' il testo che si vuole aggiungere \"\n             +\"solitamente nella forma Area - Mob Locazione Altre info\\n\"\n             +\"Esempio: setprovenienza Priv5 \\\"Blackmouth - Alchimista teneborsa (10781)\\\"\",\"lightgray\")); \n  print(color(\"EXTRA: setprovenienza \\\"testo libero\\\"\",\"yellow\"));\n  print(color(\"setprovenienza senza indicare l'ID agisce sull'ultimo oggetto che e' stato aggiunto al database\\n\",\"lightgray\"));\n  print(color(\"EXTRA: setprovenienza\",\"yellow\"));\n  print(color(\"setprovenienza senza indicare nulla deve essere lanciato nella locazione dove si \"\n             +\"raccoglie l'oggetto appena dopo averlo preso.\\n\"\n             +\"Apre una piccola interfaccia per facilitare la compilazione della provenienza\\n\"\n             +\"\\n\",\"lightgray\")); \n  print(color(\"CANCELLAZIONE DI UN IDENTIFY: identdel Priv#\",\"yellow\"));\n  print(color(\"Rimuove dall'archivio privato l'oggetto con l'id indicato\\n\"\n             +\"Esempio: idendel Priv1\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"CANCELLAZIONE DELL'ARCHIVIO PRIVATO: identdel All\",\"yellow\"));\n  print(color(\"Svuota l'archivio privato. Tipicamente utile dopo una esportazione.\\n\"\n             +\"\\n\",\"lightgray\"));\n  print(color(\"ESPORTAZIONE: identexport\",\"yellow\"));\n  print(color(\"Viene aperta una machera per salvare in locale sul proprio pc l'archivio privato.\\n\"\n             +\"\\n\",\"lightgray\"));   \n  print(color(\"IMPORTAZIONE: identimport\",\"yellow\"));\n  print(color(\"Viene aperta una maschera per scegliere dal proprio pc il file da utilizzare \"\n             +\"per popolare l'archivio privato\",\"lightgray\")); \n  return;\n}\n\n\nlet r;\nif (searchKey.search(/^\\d+$|^Priv\\d+/)==0) {\n  r = [util.findID(searchKey)];\n} else {\n  r = util.search(searchKey);\n}\n\nfunction buildIdentifyStr(ogg, dev) {\n  let out = (\"ID: \" + color(ogg[util.db.fieldsPos.ID],\"yellow\") + \"\\n\");\n  out += (ogg[util.db.fieldsPos.Identify] + \"\\n\");\n  out += (\"Provenienza: \" + ogg[util.db.fieldsPos.Provenienza] + \"\\n\");\n  \n  if (dev) {\n  \tout += \"Oggetto: \" + ogg[util.db.fieldsPos.Oggetto] + \"\\n\";\n  \tout += \"DescrizioneShort: \" + ogg[util.db.fieldsPos.DescrizioneShort] + \"\\n\";\n  \tout += \"DescrizioneLong: \" + ogg[util.db.fieldsPos.DescrizioneLong] + \"\\n\";    \n  \tout += \"Tipo: \" + ogg[util.db.fieldsPos.Tipo] + \"\\n\";\n  \tout += \"PosizioneIndossabile: \" + ogg[util.db.fieldsPos.PosizioneIndossabile] + \"\\n\";\n  \tout += \"Proprieta: \" + ogg[util.db.fieldsPos.Proprieta] + \"\\n\";\n  \tout += \"Peso: \" + ogg[util.db.fieldsPos.Peso] + \"\\n\";\n  \tout += \"Valore: \" + ogg[util.db.fieldsPos.Valore] + \"\\n\";\n  \tout += \"Rent: \" + ogg[util.db.fieldsPos.Rent] + \"\\n\";   \n  \tout += \"Rare: \" + ogg[util.db.fieldsPos.Rare] + \"\\n\";\n  \tout += \"NoRent: \" + ogg[util.db.fieldsPos.NoRent] + \"\\n\";\n  \tout += \"DannoArma: \" + ogg[util.db.fieldsPos.DannoArma] + \"\\n\";\n    out += \"Danno: \" + ogg[util.db.fieldsPos.Danno] + \"\\n\";\n  \tout += \"SP: \" + ogg[util.db.fieldsPos.SP] + \"\\n\";\n  \tout += \"HP: \" + ogg[util.db.fieldsPos.HP] + \"\\n\";\n  \tout += \"Mana: \" + ogg[util.db.fieldsPos.Mana] + \"\\n\";\n  \tout += \"Affect1Tipo: \" + ogg[util.db.fieldsPos.Affect1Tipo] + \"\\n\";\n  \tout += \"Affect1Valore: \" + ogg[util.db.fieldsPos.Affect1Valore] + \"\\n\";\n  \tout += \"Affect2Tipo: \" + ogg[util.db.fieldsPos.Affect2Tipo] + \"\\n\";\n  \tout += \"Affect2Valore: \" + ogg[util.db.fieldsPos.Affect2Valore] + \"\\n\";\n  \tout += \"Affect3Tipo: \" + ogg[util.db.fieldsPos.Affect3Tipo] + \"\\n\";\n  \tout += \"Affect3Valore: \" + ogg[util.db.fieldsPos.Affect3Valore] + \"\\n\";\n  \tout += \"Affect4Tipo: \" + ogg[util.db.fieldsPos.Affect4Tipo] + \"\\n\";\n  \tout += \"Affect4Valore: \" + ogg[util.db.fieldsPos.Affect4Valore] + \"\\n\";\n  \tout += \"Affect5Tipo: \" + ogg[util.db.fieldsPos.Affect5Tipo] + \"\\n\";\n  \tout += \"Affect5Valore: \" + ogg[util.db.fieldsPos.Affect5Valore] + \"\\n\";\n \n  }\n  out += \"\\n\";\n  return out;\n}\n\nconsole.log(r);\n\nif (r[0]==null) { //Nessun oggetto trovato => notifica\n  print(\"Nessun oggetto trovato con i criteri richiesti\");\n} else if (r.length == 1) { //1 solo oggetto trovato => mando direttamente a screen principale\n  print(buildIdentifyStr(r[0], isDev));\n} else { //Più oggetti trovati => Mando a window specifica\n  \n  pageContent(\"Identify\", (pageIndex, pageSize) => {\n    let total = 0\n    let data = r;\n    if (data && (total = data.length))\n    {\n      for (let i = pageIndex * pageSize; i < (pageIndex+1) * pageSize && i < total; i++) {\n        let line = link(color(data[i][util.db.fieldsPos.ID], !data[i][util.db.fieldsPos.Provenienza]?\"yellow\":\"lighgreen\", null, false, true) + color(\" \", \"lightgray\") + color(data[i][util.db.fieldsPos.Oggetto], !data[i][util.db.fieldsPos.Provenienza]?\"yellow\":\"lighgreen\", null, true), () => print(buildIdentifyStr(data[i], isDev)))\n        line += \"\\n \" + color(data[i][util.db.fieldsPos.DescrizioneShort], \"lightgray\")\n        print(line,\"Identify\")\n      }\n    } else {\n      print(color(\" Nessuno :(\",\"red\"), \"Ricerca locazioni\")\n    }\n    return total;\n  }, \"Oggetti trovati per: \"+color(searchKey,\"yellow\"), 0, 10, 450, 440)\n  \n}\n\n",
      "regex": true,
      "is_script": true,
      "class": "Ident",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "rc",
      "id": "",
      "value": "if (this.healtype?.indexOf(\"C\")>-1) {\n\tsend(`cast remove-curse ${$1}`)\n} else {\n\tsend(`unstash scrigno-remove;get pergamena scrigno;stash scrigno;recite pergamena ${$1}`)\n}",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^help($| client full$| client$| blocco (.+)$)",
      "id": "",
      "value": "if (!match[1]) {\n  \tsend('~help');\n  \tsend(\"echo $c0015Per il help degli alias o trigger del client digita '$c1115help client$c0015', oppure '$c1115help client full$c0015'.\");  \n\treturn;\n}\n\nconst helptxt = `\nElenco comandi webclient\nredatto sulla base della versione 25\n\n\n-----COMBATTIMENTO-----\n\nKILL\n    kill | kill \\<target\\> \n      Corrisponde a \"kill\" o \"kill <target>\"\n\nSTOP\n    stop\n      Toglie l'autoassist e interrompe il combattimento\n\nASSIST\n    ass | ass <target>\n      Assiste il Tank o il <target> specificato\n\nRESCUE\n    rescue|r | rescue <target>|r <target>\n      Viene \"rescuato\" il tank o il <target> specificato\n\nTHROW\n    shuri\n      Prende l'oggetto da lancio dalla borsa\n    shuri <target>\n      Prende l'oggetto da lancio dalla borsa e chiama il <target>\n\nATTACK\n    attack\n      Attacca il primo mob della stanza con l'attacco predefinito dalla classe\n    attack <target>\n      Attacca il <target> specificato con l'attacco predefinito dalla classe\n\nARCO\n    fire <target>\n      carica l'arco e spara una freccia al <target>\n\nORDER FOLLOWERS\n    of <comando>\n      Corrisponde a \"order followers <comando>\"\n\n\n\n-----AUTOMATISMI-----\n\nAUTOASSIST\n  Assist automatico all'entrata in combat del gruppo\n    autoassist on|true\n      Abilita l'autoassit\n    autoassist off|false\n      Disabilita l'autoassit\n    autoassist|aa\n      Inverte l'attivazione dell'autoassist\n\nAUTOBASH\n  Bash o kick automatico quando in combat\n    autobash on|true\n      Abilita l'autobash\n    autobash off|false  \n      Disabilita l'autobash\n    autobash|ab\n      Inverte l'attivazione dell'autobash\n\nAUTOCLERIC\n  Cura e refresh automatici dei membri del gruppo sotto la soglia impostata [Routine: cura]\n    autocleric <num>\n      Abilita l'autocleric impostando la soglia specificata in <num>. Se <num> e' 0 disabilita      \n    autocleric|acl\n      Se abilitato, disabilita l'autoassist. Se disabilitato lo abilita con la soglia preimpostata del 70%\n\nAUTOGROUP\n  Gruppa automaticamente chi segue\n    autogroup on|true\n      Abilita l'autogroup\n    autogroup off|false\n      Disabilita l'autogroup\n    autogroup\n      Inverte l'attivazione dell'autogroup\n\nAUTOLOOT\n  Evocazione del famiglio per la raccolta automatica dei loot\n    autoloot on|true\n      Abilita l'autoloot\n    autoloot off|false\n      Disabilita l'autoloot\n    autoloot\n      Inverte l'attivazione dell'autoloot\n    \nAUTOFOLLOW\n  Inseguimento automatico del capogruppo quando entra nei portali, negli stagni o qualora dovesse tornare in rece\n    autofollow on|true\n      Abilita l'autofollow\n    autofollow off|false\n      Disabilita l'autofollow\n    autofollow\n      Inverte l'attivazione dell'autofollow\n    \nAUTOORDER\n  Permette di ricevere comandi dal capogruppo in group tell della forma <nomepg>:<comando>\n  Oppure all:<comando>\n    autoorder on|true\n      Abilita l'autoorder\n    autoorder off|false\n      Disabilita l'autoorder\n    autoorder\n      Inverte l'attivazione dell'autoorder\n\nSELFSHIELD \n  Abitlita l'autocast su se stessi dello scudo al suo scadere\n    selfshield on|true\n      Abilita il selfshield\n    selfshield off|false\n      Disabilita il selfshield\n    selfshield\n      Inverte l'attivazione del selfshield\n\nSELFSANC \n  Autocast su se stessi del sanc al suo scadere\n    selfsanc on|true\n      Abilita il selfsanc\n    selfsanc off|false\n      Disabilita il selfsanc\n    selfsanc\n      Inverte l'attivazione del selfsanc  \n\nAUTOSANC\n  Autocast del sanc sulla lista dei target impostata oppure Gard [routine: sancaAutosanc]\n    autosanc|asanc\n      Inverte la selezione dell'autosanc senza cancellare la lista dei target\n    autosanc|asanc off|false\n      Disabilita l'autosanc e svuota la lista.\n    autosanc|asanc <target>\n      Abilita l'autosanc e aggiunge il target alla lista\n\nAUTOSTAB E AUTOSLAM\n  Stab o slam automatici nell'entrata in combat\n    autostab|autoslam|as on|true\n      Abilita l'autostab o l'autoslam\n    autostab|autoslam|as off|false\n      Disabilita l'autostab o l'autoslam\n    autostab|autoslam|as \n      Inverte l'attivazione dell'autostab o dell'autoslam\n\nAUTOFURY\n  Fury automatico nell'entrata in combat\n    autofury|af on|true\n      Abilita l'autofury\n    autofury|af off|false\n      Disabilita l'autofury\n    autofury|af\n      Inverte l'attivazione dell'autofury  \n    \nAUTOCAST\n  Casta automaticamente durante il combat\n    autocast on|true\n      Abilita l'autocast\n    autocast off|false\n      Disabilita l'autocast\n    autocast|ac \n      Inverte l'attivazione dell'autocast   \n\n    casta\n      Casta il cast predefinito di attacco al mob in combat\n    casta <target>\n      Casta il cast predefinito di attacco al <target>\n\nAUTORESCUE\n  \"Rescua\" automaticamente\n    autoresccue on|true\n      Abilita l'autorescue\n    autoresccue off|false\n      Disabilita l'autorescue\n    autoresccue|ar\n      Inverte l'attivazione dell'autorescue   \n\nAUTOSTOP\n  Interrompe automaticamente il combattimento\n    autostop on|true\n      Abilita l'autostop\n    autostop off|false\n      Disabilita l'autostop\n    autostop \n      Inverte l'attivazione dell'autostop   \n\nAUTOARMI\n  Cambio automatico dell'arma se il client si accorge che l'arma impugnata non coplisce\n    autoarmi on|true\n      Abilita l'autoarmi\n    autoarmi off|false\n      Disabilita l'autoarmi\n    autoarmi \n      Inverte l'attivazione dell'autoarmi   \n\nANTISPALM\n  Cambio automatico degli scudi se il client si accorge di ricevere danni su uno scudo del mob\n    antispalm on|true\n      Abilita l'antispalm\n    antispalm off|false\n      Disabilita l'antispalm\n    antispalm \n      Inverte l'attivazione dell'antispalm   \n\nAUTOKILL\n  Kill automatico dei mob (per la lista dei mob su cui funziona l'autokill: variables autoKillMobs)\n    autokill on|true\n      Abilita l'autokill\n    autokill off|false\n      Disabilita l'autokill\n    autokill|ak\n      Inverte l'attivazione dell'autokill\n\nSTATUS\n    status\n      Comunica sul gruppo lo stato di abilitazione degli automatismi\n\nALLOFF\n    alloff\n      Spegne tutti gli automatismi\n\n\n\n-----CAST-----\n\nCURA\n    heal|h\n      Cura se stessi con il migliore cast a disposizione della classe, oppure con second wind\n    heal <target> | h <target>\n      Cura il <target> con il migliore cast a disposizione della classe\n\nASTRAL\n    astral\n      Trasferisce il pg e il gruppo in astral utilizzando il cast adeguato alla classe\n\nREMOVE CURSE\n    rc <target>\n      Casta remove curse sul target.\n      Per i non chierici prende la pergamena dallo scrigno e usa quella.\n\nPORTAL\n    portal <mob> | po <mob>\n      Corrispondente a \"cast 'portal' <mob>\" \n\nFIRESHIELD\n    fs\n      Casta fireshield o flame shroud in base alla classe\n\nDISPEL\n    dispe|dispel \n      Corrisponde a \"cast 'dispel magic' \"\n    dispe|dispel <target>\n      Corrisponde a \"cast 'dispel magic' <target> \"\n\nSILENCE\n    sil|sile|sila\n      Corrisponde a \"cast 'silence' \"\n    sil|sile|sila <target>\n      Corrisponde a \"cast 'silence' <target>\"\n\nSANC\n    sanc\n      Corrisponde a \"cast 'sanc'\" oppure \"cast 'natures prot' su se stessi \n    sanc <target>\n      Corrisponde a \"cast 'sanc'\" oppure \"cast 'natures prot' sul target specificato \n\nCHAIN\n    chain | chain <target>\n      Corrisponde a \"cast 'chain lightn'\" su se stessi o sul <target> specificato\n\nFLY\n    fly | fly <target>\n      Corrisponde a \"cast 'fly'\" su se stessi o sul <target> specificato\n\n    gfly\n      Corrisponde a \"cast 'group fly'\"\n\nTRUE SIGHT\n    ts | ts <target>\n      Corrisponde a \"cast 'true sig'\" su se stessi o sul <target> specificato\n\nWATCH\n    wat|watc|watch\n      Rimuove l'oggetto che fornisce true sight prima di usare l'abilita' watch\n\nREMOVE PARAL\n    rp <target>\n      Corrisponde a 'remove paralisis' sul <target> specificato\n\nSNARE\n    snare | snare <target>\n      Corrisponde a \"cast 'snare' \" sul mob in combattimento o sul <target> specificato\n\nREFRESH\n    refresh <target>\n      Se possibile casta 'second wind' sul <target> oppure comunica sul gruppo\n\nFOG\n    fog\n      Corrisponde a \"cast 'faerie-fog' \"\n\nCANIBALIZE\n    cani\n      cani senza parametri corrisponde al cani per recuperare tutto il mana ma restando con almeno 200hp\n\nCAST\n    cast '<spell>' | cast '<spell>' <target>\n      Sceglie cast, recall o mind in funzione della classe del pg\n\n\n-----MAPPER-----\n\nVAI\n    vai <destinazione>\n      Abilita l'autodirezioni per andare alla locazione <destinazione>.\n      <destinazione> puo' essere il numero di room oppure un descrittivo associato alla stanza.\n    vai\n      vai senza parametro va alla stanza successiva dell'elenco restituito dal comando cerca\n\n    room\n      Restituisce la stanza in cui ci si trova\n\n    cerca <criterio>\n      Restituisce le stanze e l'area il cui nome corriponde al <criterio> specificato\n\n    ricercaprecedente\n      Restituisce le stanze trovate dalla ricerca già effettuata\n\n    salta | salta <num_room>\n      Toglie dall'elenco delle stanze trovate dal comando cerca la prima stanza o la stanza specificata\n\n    roomedit\n      Modifca la room del mapper\n\n    tesoro|tesori\n      Mostra un elenco cliccabile dei tesori da raccogliere\n\nAPERTURA USCITE\n    dig <target>\n      Impugna l'oggetto per dig e cut giusto il tempo per scavare il <target>\n\n    cut <target>\n      Impugna l'oggetto per dig e cut giusto il tempo per tagliare il <target>\n\n    porte\n      Apre tutte le porte presenti nella stanza\n\nENTRATA VELOCE\n    es\n      Corrisponde a \"enter stagno\"\n    ep\n      Corrisponde a \"enter portale\"\n\n\n    \n-----CAMBIO EQ-----\n\nSCUDI\n    ia|immuacid\n      Indossa lo scudo acido\n    ic|immucold|immuice\n      Indossa lo scudo cold\n    ie|immuele\n      Indossa lo scudo elettrico\n    if|immufire\n      Indossa lo scudo fire\n\nARMI\n    blunt\n      Cambia l'arma e impugna l'arma blunt    \n    slash\n      Cambia l'arma e impugna l'arma slash    \n    pierce\n      Cambia l'arma e impugna l'arma pierce \n    extra\n      Cambia l'arma e impugla l'arma extra\n    arco\n      Cambia l'arma e impugna l'arco\n\n\n-----ALTRO-----\n\nAFK\n  Nota: in AFK alcuni automatismi si comportano in modo diverso\n    afk on|true\n      Abilita lo stato di afk del personaggio e aggiorna il title\n    afk off|false\n      Disabilita lo stato di afk del personaggio e aggiorna il title\n    afk\n      Inverte lo stato di afk del personaggio e aggiorna il title.\n\nBORSA\n    gb <item>\n      Prende l'item dalla borsa\n    pb <item>\n      Metti l'item in borsa\n\nCOMUNICAZIONE\n    gui|guild|gt|ot|sh|hg|herog|shout|gos|goss|gossip|grida|say <messaggio>\n      Manda il messaggio sul canale richiesto\n    t|tell|suss|send|telep|mess <destinatario> <messaggio>\n      Manda il messaggio al destinatario scelto\n    gtTrigget <messaggio>\n      Manda il messaggio al gruppo anteponendo la scritta (trigger).\n      Usato per i messaggi mandati in automatico dagli script\n\n    manca\n      Comunica al gruppo chi non e' nella stanza\n\n    tick\n      Comunica quanto rimane alla scadenza dell'ora\n\n    sessione\n      Comunica al gruppo quanti divini e quanti xp sono stati fatti nella sessione di gioco      \n\nALIGN\n    align\n      Estra dallo score il valore dell'align e lo manda a schermo\n\nCASA\n    rece|casa\n      Ritorna a casa con il metodo concesso dalla classe.\n      Per chi non ha cast viene cercata una pergamenta di ritorno in uno scrigno tenuto in borsa\n\nTOUCH\n    touch\n      Inverte l'abilitazione del pannellino per il touchscreen\n\nORDINABORSA\n    ordinaborsa\n      Mette in ordine la borsa spostando tutti i cristalli e gemme nel loro contenitore\n\nMESTIERI\n    mining\n      Svolge la sequenza opportuna per poter minare\n\n    fishing\n      Svolge la sequenza opportuna per poter pescare\n\n    esca <target>\n      Imposta l'esca da utilizzare per la pesca a <target>\n\nDHETHOR\n    qr\n      Corrisponde a \"quest request\"\n    qc\n      Corrisponde a \"quest complete\"\n\nFIX\n    fixxa <pg>\n      Toglie gli oggetti e richiede il fix a <pg>\n\nIDENTIFICA IL PROPRIO EQ\n    identeq\n      Da eseguire da Gwiryn: identifica tutto il proprio eq e scarica il file con esso\n\n\n-----SPECIFICI DELLA CLASSE BARDO-----\n\nREVEAL\n    fog\n      Corrisponde a \"cast 'reveal'\"\n\nPOISON\n    poison\n      Casta 'poison' sull'arma e sull'oggetto tenuto\n\nAUTOINSPIRE\n  Mantiene automaticamente l'ispirazione del bardo al massimo livello\n    autoinspire on|true\n      Abilita l'autonspire\n    autoinspire off|false\n      Disabilita l'autonspire\n    autoinspire\n      Inverte lo stato di attivazione dell'autonspire\n\nPLAY\n  Mantiene automaticamente suonata la canzone attivata\n    autosong on|true\n      Abilita l'autsong\n    autosong off|false\n      Disabilita l'autsong\n    autosong\n      Inverte lo stato di attivazione dell'autsong\n\n    war\n      corrisponde a \"play song of war\"\n    life\n      corrisponde a \"play song of life\"\n    nat\n      corrisponde a \"play song of nature\"\n    dumb\n      corrisponde a \"play song of dumb\"\n    peace\n      corrisponde a \"play song of peace\"\n\n    play\n      risuona l'ultima song suonata\n    play <song>\n      suona la song scelta\n\nFOCUS\n    focus\n      Casta \"spirit-focus\" sul primo oggetto personale dell'equipaggiamento\n\nTALES\n    bash|gig|giga <target>\n      Effettua la tale sul <target>\n    ven|vend <target>\n      Effettua la tale sul <target>\n    spi|spir <target>\n      Effettua la tale sul <target>\n    ero|eroe <target>\n      Effettua la tale sul <target>\n    dra|drag <target>\n      Effettua la tale sul <target>\n    fug|fugg <target>\n      Effettua la tale sul <target>\n    idi|idio <target>\n      Effettua la tale sul <target>\n\nSLAM\n    slam\n      Effettua lo slam indossando se necessario prima lo strumento adeguato (e cambiando la song per l'autosong)\n\n\n\n-----SPECIFICI DELLA CLASSE DRUIDO-----\n\nBUFF\n    bark | bark <taget>\n      Corrisponde a \"cast 'barkskin'\" su se stessi o sul <target> specificato\n    \n    anim | anim <taget>\n      Corrisponde a \"cast 'animal aff'\" su se stessi o sul <target> specificato\n\n    do | do <taget>\n      Corrisponde a \"cast 'detect original'\" su se stessi o sul <target> specificato\n\n    hum|grow |  hum <taget>|grow <taget>\n      Corrisponde a \"cast 'humanoid grow'\" su se stessi o sul <target> specificato\n\n    bloom\n      Corrisponde a \"cast 'bloom'\"\n\nOFFENSIVE CAST\n    storm|sblinka\n      Corrisponde a \"cast 'firestorm'\"\n\n    heat | heat <target>\n      Corrisponde a \"cast 'heat st'\" sul mob target del combattimento o sul <target> specificato\n\n    flo | flo <target>\n      Corrisponde a \"cast 'floating l'\" sul mob target del combattimento o sul <target> specificato\n\n    enta | enta <target>\n      Corrisponde a \"cast 'entangle'\" sul mob target del combattimento o sul <target> specificato\n\nEVOCATI\n    terra\n      Corrisponde a \"cast 'earth se'\"\n    aria\n      Corrisponde a \"cast 'wind se'\"\n    acqua\n      Corrisponde a \"cast 'water se'\"\n    fuoco\n      Corrisponde a \"cast 'fire se'\"\n\nALTRO\n    portal|tran|transport\n      Apre un menu' di scelta per il portal o il transport via plant\n    portal|tran|transport <albero>\n      Effettua il portal o il tansport via plant per l'<albero> selezionato\n\n\n\n-----SPECIFICI DELLE CLASSI MAGO-----\n\nPOLYMORPH\n    pola <creatura>\n      Casta polymorph self nella creatura specificata\n\nOFFENSIVE CAST\n    storm|sblinka\n      Corrisponde a \"cast 'incendiary'\"\n\n\n\n-----SPECIFICI DELLA CLASSE STREGONE-----\n\nGESTIONE DEL LIBRO DEGLI INCANTESIMI\n    libro assegna\n      Legge il contenuto del tuo libro e lo usa come template per memmare\n    libro aggiorna\n      Simile ad assegna ma se fai cambiamenti aggiorni il libro voluto (template)\n    libro cancella\n      Cancella il libro voluto (template), e quindi automemorize non funziona piu\n\n    mem|memo <num> '<cast>'  \n      Si siede e studia <num> volte il <cast> indicato\n\n    forg|forge|forget '<cast>'\n      Dimentica il <cast>. Il libro voluto (template) non viene alterato\n\n    memma\n      Si siede e studia gli incantesimi necessari a ripopolare il libro voluto (template)\n\nAUTOMEM\n  Memorizzazione automatica all'avvicinarsi del tick per ripopolare il libro [routine: automemma, finememorize]\n    automem|automemo on|true\n      Abilita l'automem\n    automem|automemo off|false\n      Disabilita l'automem\n    automem|automemo \n      Inverte lo stato dell'automem\n\n\n-----SPECIFICI DELLA CLASSE LADRO-----\n\nRESTAB\n    restab|rs\n      Flea, ritorna e stabba\n\n`\nlet helplist = helptxt.replaceAll('<','&lt;').replaceAll('>','&gt;').split(\"\\n\");\n\nif (match[1] == \" client full\") {\n  print(color(helplist.join(\"\\n\"),\"lightgray\").replaceAll(/-----(.+)-----/g,color(\"-----$1-----\",\"yellow\")))\n  return\n}\n\nlet sezioni=[]\n\nfor (let riga of helplist) {\n  if (riga.substr(0,5) == '-----') {\n    //Inizio sezione\n    let sezione = {};\n    sezione.nome = riga.substr(5,riga.length-10);\n    sezione.blocchi = [];\n    sezioni.push(sezione)\n    continue;\n  }\n  if (sezioni.length == 0) continue; //Scarta tutte le righe iniziali prima della prima sezione\n  if ((riga.trim()==\"\") || (riga.trim()==\"Uso:\")) continue; //Salta le righe vuote e quelle con la scritta Uso:\n\n  if (riga.substr(0,1)!=\" \") { //se la riga inizia con un comando allora è un blocco\n    let blocco = {};\n    blocco.nome = riga.trim();\n    blocco.comandi = [];\n    let sezionecorrente = sezioni[sezioni.length-1];\n    sezionecorrente.blocchi.push(blocco);\n  } else if ((riga.substr(0,2)==\"  \") && (riga.substr(2,1)!=\" \")) { //se la riga ha solo 2 spazi di indentazione è la descrizione del blocco\n    let sezionecorrente = sezioni[sezioni.length-1];\n    let bloccocorrente = sezionecorrente.blocchi[sezionecorrente.blocchi.length-1];\n    bloccocorrente.descrizione = riga.trim();\n  } else if ((riga.substr(0,4)==\"    \") && (riga.substr(4,1)!=\" \")) { //se la riga ha solo 4 spazi di indentazione è il nome di un comando\n    let comando = {};\n    let sezionecorrente = sezioni[sezioni.length-1];\n    let bloccocorrente = sezionecorrente.blocchi[sezionecorrente.blocchi.length-1];\n    comando.nome = riga.trim();\n    comando.descrizione = \"\";\n    bloccocorrente.comandi.push(comando);\n  } else if ((riga.substr(0,6)==\"      \") && (riga.substr(6,1)!=\" \")) { //se la riga ha solo 6 spazi di indentazione è la spiegazione del comando\n    let sezionecorrente = sezioni[sezioni.length-1];\n    let bloccocorrente = sezionecorrente.blocchi[sezionecorrente.blocchi.length-1];\n    let comandocorrente = bloccocorrente.comandi[bloccocorrente.comandi.length-1];\n    comandocorrente.descrizione += riga.trim();\n  }\n}\n\nif (match[1] == \" client\") {\n  //menu degli help del client\n  for (let sezione of sezioni) {\n    print(color(sezione.nome,\"yellow\"));\n    let blocconomi = [];\n    for (let blocco of sezione.blocchi) {\n      const strcomandi = blocco.comandi.map( (comando)=> {return (comando.nome)} ).join(\", \");\n      blocconomi.push( link(blocco.nome, ()=>{send('help blocco ' + sezione.nome + \"|\" + blocco.nome)}, strcomandi))\n    }\n    print(\"  \" + color(blocconomi.join(\", \"),\"lightgray\") + \"\\n\");\n  }\n} else if (match[1].substr(1,6) == \"blocco\") {\n  let ricerca_sezione = match[2].split(\"|\")[0] || \"\";\n  let ricerca_blocco = match[2].split(\"|\")[1] || \"\";\n  //print(\"Ricerca sezione:\" + ricerca_sezione);\n  //print(\"Ricerca blocco: ->\" + ricerca_blocco + \"<-\");\n  for (let sezione of sezioni) {\n    //print(sezione.nome);\n    if (sezione.nome != ricerca_sezione) continue;\n    for (let blocco of sezione.blocchi) {\n      if (blocco.nome.trim() != ricerca_blocco.trim()) continue;\n\t  //print(\"INNER: \" + blocco.nome);\n      print(color(ricerca_sezione + \" - \" + ricerca_blocco + \":\",\"yellow\") + \"\\n\");\n      if (blocco.descrizione) print(color(blocco.descrizione,\"lightgray\") + \"\\n\");\n      for (let comando of blocco.comandi) {\n      \tprint(color(comando.nome + \":\",\"yellow\"));\n        print(color(\"   \" + comando.descrizione,\"lightgray\") + \"\\n\");\n      }\n    }\n  }\n}\n",
      "regex": true,
      "is_script": true,
      "class": "help",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "relinkLab",
      "id": "",
      "value": "const rooms = mapper.getZoneRooms(157)\nconst current = mapper.current\nfor (const room of rooms) {\n\tif (room.name == \"Nel Labirinto\")\n    {\n      room.color = \"rgb(177,177,177)\"\n      room.exits = {}\n    }\n}\nmapper.prepare()\nif (current) {\n\tmapper.setRoomById(current.id)\n}",
      "regex": false,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "kirin",
      "id": "",
      "value": "ask ki aiuto\nask ki libera\nask ki foresta\nask ki imperatrice\nask ki pace\nask ki veleno\nask ki artefatti",
      "regex": false,
      "is_script": false,
      "class": "zone:135",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^clearlab",
      "id": "",
      "value": "//LAB\n//zone:157\n/*\n#ALIAS clearLab {\n\t#VAR arcieri {0};\n    #VAR paladini {0};\n    #VAR inquisitori {0};\n    #VAR arcangeli {0};\n    #VAR maghi {0};\n    #VAR scudieri {0};\n    #VAR lab_multi 0\n} */\nconst LAB_AREA_ID = 35; //157;\n\n\nlet lab = window.lab;\nif (lab == undefined) {\n  print(\"lanciare prima initlab\");\n  return;\n}\nlab.arcieri = 0;\nlab.paladini = 0;\nlab.inquisitori = 0;\nlab.arcangeli = 0;\nlab.maghi = 0;\nlab.scudieri = 0;\nlab.lab_multi = 0;\n\nsend(\"relinklab\")",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^initlab ?(\\d)?",
      "id": "",
      "value": "var lab = (window.lab = {});\nsend(\"clearlab\");\nsend(\"setlab \" + match[1] || \"\");\nif (isCapogruppo()) {\n\tprint(\"\\nSei capogruppo. Mapper messo in modalita' mappaggio.\\nVerra' disabilitato appena esci di zona.\")\n\tmapper.mapmode = true\n}",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^setlab ?(\\d)?",
      "id": "",
      "value": "//LAB\n//zone:157\n/* #ALIAS setlab {\n\t#IF (@lab_multi<%int( %1) or @lab_multi==0) {\n    \t#VAR lab_multi {%if( %1!=\"\", %int( %1), 1)};\n        #SH %ansi( high, green)Labirinto inizializzato x@lab_Multi, per cambiare moltiplicatore usa 'setlab numero' dove numero e' 1, 2 o 3. Per riavviarlo 'initlab'. Per status: 'statuslab'.\n    }\n}\n*/\nlet lab = window.lab;\nif (lab == undefined) {\n  print(\"lanciare prima initlab\");\n  return;\n}\nif ( (parseInt(lab.lab_multi)<parseInt(match[1])) || (lab.lab_multi == 0) ) {\n\tlab.lab_multi = match[1] || 1;\n\tprint(\"Labirinto inizializzato X\" + lab.lab_multi +\"\\nPer cambiarlo:  'setlab numero' dove numero e' 1, 2 o 3.\\nPer riavviarlo: 'initlab'.\\nPer status:     'statuslab'.\");\n}\n",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "^statuslab$",
      "id": "",
      "value": "//LAB\n//zone:157\n/* #ALIAS statuslab {\ngt ~(trigger~) Al Lab x@lab_multi abbiamo ucciso:;\ngt $c0009Arcieri: @arcieri su %eval( 30*@lab_multi) $c0009~(%int( %eval( (%float( @arcieri)/(30*@lab_multi))*100))%~);\ngt $c0009Scudieri: @scudieri su %eval( 10*@lab_multi) $c0009~(%int( %eval( (%float( @scudieri)/(10*@lab_multi))*100))%~);\ngt $c0009Paladini: @paladini su %eval( 5*@lab_multi) $c0009~(%int( %eval( (%float( @paladini)/(5*@lab_multi))*100))%~);\ngt $c0009Inquisitori: @inquisitori su %eval( 8*@lab_multi) $c0009~(%int( %eval( (%float( @inquisitori)/(8*@lab_multi))*100))%~);\ngt $c0009Maghi: @maghi su %eval( 6*@lab_multi) $c0009~(%int( %eval( (%float( @maghi)/(6*@lab_multi))*100))%~);\ngt $c0009Arcangeli: @arcangeli su %eval( 7*@lab_multi) $c0009~(%int( %eval( (%float( @arcangeli)/(7*@lab_multi))*100))%~)}\n*/\nlet lab = window.lab;\nif (lab == undefined) {\n  print(\"lanciare prima initlab\");\n  return;\n}\nconst saycmd=\"gt\";\n\nlet percentuale = (num,tot) => {return (\"\"+parseInt(100*num/tot).toString().padStart(3,' ')+\"%\")}\nlet struccisioni = (mob,num,coeff) => {return (\n  \"\"+mob+\": \"+num.toString().padStart(3,' ')+\" su \"+(coeff*lab.lab_multi).toString().padStart(3,' ')+\" (\"+percentuale(num,coeff*lab.lab_multi)+\")\"\n  )} \n\nsend(saycmd+\" Al Lab X\" + lab.lab_multi + \" abbiamo ucciso:\");\nsend(saycmd+\" \"+struccisioni(\"Arcieri    \",lab.arcieri, 30));\nsend(saycmd+\" \"+struccisioni(\"Scudieri   \",lab.scudieri, 10));\nsend(saycmd+\" \"+struccisioni(\"Paladini   \",lab.paladini, 5));\nsend(saycmd+\" \"+struccisioni(\"Inquisitori\",lab.inquisitori, 8));\nsend(saycmd+\" \"+struccisioni(\"Maghi      \",lab.maghi, 6));\nsend(saycmd+\" \"+struccisioni(\"Arcangeli  \",lab.arcangeli, 7));\n",
      "regex": true,
      "is_script": true,
      "class": "zone:157",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "followorder",
      "id": "",
      "value": "const order = ($1).toString()\nconst ordiniVietati = [\"trai\",\"pr\",\"alle\",\"wit\",\"de\",\"prel\",\"grid\",\"sh\",\"ot\",\"gos\",\"sa\",\"par\",\"di\",\"set\",\"pwp\",\"rpg\",\"tit\",\"quit\"]\nif (ordiniVietati.find((e) => order.toLowerCase() == e || order.toLowerCase().startsWith(e + \" \"))) {\n  this.parlaStato = true\n  send(\"sayStatus Ordine vietato\")\n  this.parlaStato = this.afk\n  return\n}\nsend(order)",
      "regex": false,
      "is_script": true,
      "class": "",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    },
    {
      "pattern": "identeq",
      "id": "",
      "value": "toggleTrigger(\"fineidentifyeq\", true)\nNotification.Show(\"Inizio identify EQ\")\nsend(\"rem \"+oggettoTrueSight)\nif (healtype==\"C\"||healtype==\"D\"||canPlay) {\n  send(\"ts\")\n} else {\n  send(\"watch\")\n}\nsend(\"wear \"+oggettoTrueSight)\nfor(let i = 1; i<22; i++) {\n  send(\"rem \"+i+\";give ed\"+@TSPersonaggio+\" gwiryn;\"+(i==16?\"~wield\":\"wear\")+\" ed\"+@TSPersonaggio)\n}\noutputManager.outputWin.log=true\nsend(\"echo $c4011Fine identify EQ$c0007\")",
      "regex": false,
      "is_script": true,
      "class": "util",
      "enabled": true,
      "is_prompt": false,
      "shortcut": "",
      "script": null
    }
  ],
  "classes": [
    [
      "cleric",
      {
        "name": "cleric",
        "enabled": false
      }
    ],
    [
      "druid",
      {
        "name": "druid",
        "enabled": false
      }
    ],
    [
      "mage",
      {
        "name": "mage",
        "enabled": false
      }
    ],
    [
      "fight",
      {
        "name": "fight",
        "enabled": true
      }
    ],
    [
      "autocleric",
      {
        "name": "autocleric",
        "enabled": false
      }
    ],
    [
      "autoassist",
      {
        "name": "autoassist",
        "enabled": false
      }
    ],
    [
      "autobash",
      {
        "name": "autobash",
        "enabled": false
      }
    ],
    [
      "autologin",
      {
        "name": "autologin",
        "enabled": false
      }
    ],
    [
      "autorescue",
      {
        "name": "autorescue",
        "enabled": false
      }
    ],
    [
      "autoarmi",
      {
        "name": "autoarmi",
        "enabled": false
      }
    ],
    [
      "antispalm",
      {
        "name": "antispalm",
        "enabled": false
      }
    ],
    [
      "debug",
      {
        "name": "debug",
        "enabled": false
      }
    ],
    [
      "autogroup",
      {
        "name": "autogroup",
        "enabled": false
      }
    ],
    [
      "autoloot",
      {
        "name": "autoloot",
        "enabled": false
      }
    ],
    [
      "gtalign",
      {
        "name": "gtalign",
        "enabled": false
      }
    ],
    [
      "fixxa",
      {
        "name": "fixxa",
        "enabled": false
      }
    ],
    [
      "autostab",
      {
        "name": "autostab",
        "enabled": false
      }
    ],
    [
      "indietro",
      {
        "name": "indietro",
        "enabled": false
      }
    ],
    [
      "autosanc",
      {
        "name": "autosanc",
        "enabled": false
      }
    ],
    [
      "memorize",
      {
        "name": "memorize",
        "enabled": false
      }
    ],
    [
      "automemorize",
      {
        "name": "automemorize",
        "enabled": true
      }
    ],
    [
      "psionic",
      {
        "name": "psionic",
        "enabled": false
      }
    ],
    [
      "sorcerer",
      {
        "name": "sorcerer",
        "enabled": false
      }
    ],
    [
      "selfsanc",
      {
        "name": "selfsanc",
        "enabled": false
      }
    ],
    [
      "selfshield",
      {
        "name": "selfshield",
        "enabled": false
      }
    ],
    [
      "login",
      {
        "name": "login",
        "enabled": true
      }
    ],
    [
      "bard",
      {
        "name": "bard",
        "enabled": false
      }
    ],
    [
      "autosong",
      {
        "name": "autosong",
        "enabled": false
      }
    ],
    [
      "autoinspire",
      {
        "name": "autoinspire",
        "enabled": false
      }
    ],
    [
      "util",
      {
        "name": "util",
        "enabled": true
      }
    ],
    [
      "thief",
      {
        "name": "thief",
        "enabled": false
      }
    ],
    [
      "autokill",
      {
        "name": "autokill",
        "enabled": false
      }
    ],
    [
      "afk",
      {
        "name": "afk",
        "enabled": false
      }
    ],
    [
      "immortal",
      {
        "name": "immortal",
        "enabled": false
      }
    ],
    [
      "Ident",
      {
        "name": "Ident",
        "enabled": false
      }
    ],
    [
      "IdentInit",
      {
        "name": "IdentInit",
        "enabled": true
      }
    ],
    [
      "cani",
      {
        "name": "cani",
        "enabled": true
      }
    ],
    [
      "mapper",
      {
        "name": "mapper",
        "enabled": true
      }
    ],
    [
      "config",
      {
        "name": "config",
        "enabled": true
      }
    ],
    [
      "help",
      {
        "name": "help",
        "enabled": true
      }
    ],
    [
      "zone:157",
      {
        "name": "zone:157",
        "enabled": false
      }
    ],
    [
      "questor",
      {
        "name": "questor",
        "enabled": false
      }
    ],
    [
      "monk",
      {
        "name": "monk",
        "enabled": false
      }
    ]
  ],
  "triggersEnabled": true,
  "aliasesEnabled": true,
  "soundsEnabled": true,
  "numpad": {
    "NumpadSubtract": "immufire",
    "NumpadAdd": "cambiaarma",
    "NumpadMultiply": "immuele",
    "NumpadDivide": "immucold",
    "NumpadEnter": "",
    "NumpadDecimal": "porte",
    "Numpad0": "cura",
    "Numpad1": "casta",
    "Numpad2": "south",
    "Numpad3": "down",
    "Numpad4": "west",
    "Numpad5": "stoporfleeorlook",
    "Numpad6": "east",
    "Numpad7": "attack",
    "Numpad8": "north",
    "Numpad9": "up"
  }
}
